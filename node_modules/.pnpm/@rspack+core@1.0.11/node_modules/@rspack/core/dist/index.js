"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  for (var name2 in all)
    __defProp(target2, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter2) => (__accessCheck(obj, member, "read from private field"), getter2 ? getter2.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// package.json
var require_package = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "@rspack/core",
      version: "1.0.11",
      webpackVersion: "5.75.0",
      license: "MIT",
      description: "The fast Rust-based web bundler with webpack-compatible API",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      publishConfig: {
        access: "public",
        provenance: true
      },
      exports: {
        ".": {
          default: "./dist/index.js"
        },
        "./hot/*": "./hot/*.js",
        "./hot/*.js": "./hot/*.js",
        "./package.json": "./package.json",
        "./module": "./module.d.ts"
      },
      scripts: {
        build: "tsc -b ./tsconfig.build.json && tsc-alias -p tsconfig.build.json && tsup && npm run prepare-container-runtime",
        "build:force": "tsc -b ./tsconfig.build.json --force && tsc-alias -p tsconfig.build.json && tsup && npm run prepare-container-runtime",
        dev: "pnpm run --stream /^dev:.*/",
        "dev:types": "tsc -w",
        "dev:js": "tsup --watch",
        prepare: "prebundle",
        "prepare-container-runtime": "node ./scripts/prepare-container-runtime.js",
        "doc-coverage": "node scripts/check-documentation-coverage.mjs",
        "api-extractor": "api-extractor run --verbose",
        "api-extractor:ci": "api-extractor run --verbose || diff temp/api.md etc/api.md"
      },
      files: [
        "dist",
        "hot",
        "compiled",
        "module.d.ts"
      ],
      engines: {
        node: ">=16.0.0"
      },
      homepage: "https://rspack.dev",
      bugs: "https://github.com/web-infra-dev/rspack/issues",
      repository: {
        type: "git",
        url: "https://github.com/web-infra-dev/rspack",
        directory: "packages/rspack"
      },
      devDependencies: {
        "@swc/core": "1.4.0",
        "@types/graceful-fs": "4.1.9",
        "@types/neo-async": "^2.6.6",
        "@types/watchpack": "^2.4.0",
        "@types/webpack-sources": "3.2.3",
        browserslist: "^4.21.3",
        "cross-env": "^7.0.3",
        "enhanced-resolve": "5.12.0",
        "graceful-fs": "4.2.10",
        "json-parse-even-better-errors": "^3.0.0",
        "neo-async": "2.6.2",
        prebundle: "^1.1.0",
        "tsc-alias": "^1.8.8",
        tsup: "^8.3.0",
        typescript: "5.0.2",
        watchpack: "^2.4.0",
        "webpack-dev-server": "5.0.4",
        "webpack-sources": "3.2.3",
        zod: "^3.23.8",
        "zod-validation-error": "3.3.1"
      },
      dependencies: {
        "@module-federation/runtime-tools": "0.5.1",
        "@rspack/binding": "workspace:*",
        "@rspack/lite-tapable": "1.0.1",
        "caniuse-lite": "^1.0.30001616"
      },
      peerDependencies: {
        "@swc/helpers": ">=0.5.1"
      },
      peerDependenciesMeta: {
        "@swc/helpers": {
          optional: true
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/neo-async@2.6.2/node_modules/neo-async/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/neo-async@2.6.2/node_modules/neo-async/async.js"(exports2, module2) {
    "use strict";
    (function(global, factory) {
      "use strict";
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : global.async ? factory(global.neo_async = global.neo_async || {}) : factory(global.async = global.async || {});
    })(exports2, function(exports3) {
      "use strict";
      var noop = function noop2() {
      };
      var throwError = function throwError2() {
        throw new Error("Callback was already called.");
      };
      var DEFAULT_TIMES = 5;
      var DEFAULT_INTERVAL = 0;
      var obj = "object";
      var func = "function";
      var isArray = Array.isArray;
      var nativeKeys = Object.keys;
      var nativePush = Array.prototype.push;
      var iteratorSymbol = typeof Symbol === func && Symbol.iterator;
      var nextTick, asyncNextTick, asyncSetImmediate;
      createImmediate();
      var each = createEach(arrayEach, baseEach, symbolEach);
      var map = createMap(arrayEachIndex, baseEachIndex, symbolEachIndex, true);
      var mapValues = createMap(arrayEachIndex, baseEachKey, symbolEachKey, false);
      var filter = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, true);
      var filterSeries = createFilterSeries(true);
      var filterLimit = createFilterLimit(true);
      var reject = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, false);
      var rejectSeries = createFilterSeries(false);
      var rejectLimit = createFilterLimit(false);
      var detect = createDetect(arrayEachValue, baseEachValue, symbolEachValue, true);
      var detectSeries = createDetectSeries(true);
      var detectLimit = createDetectLimit(true);
      var every = createEvery(arrayEachValue, baseEachValue, symbolEachValue);
      var everySeries = createEverySeries();
      var everyLimit = createEveryLimit();
      var pick = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, true);
      var pickSeries = createPickSeries(true);
      var pickLimit = createPickLimit(true);
      var omit = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, false);
      var omitSeries = createPickSeries(false);
      var omitLimit = createPickLimit(false);
      var transform = createTransform(arrayEachResult, baseEachResult, symbolEachResult);
      var sortBy = createSortBy(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue);
      var concat = createConcat(arrayEachIndex, baseEachIndex, symbolEachIndex);
      var groupBy = createGroupBy(arrayEachValue, baseEachValue, symbolEachValue);
      var parallel = createParallel(arrayEachFunc, baseEachFunc);
      var applyEach = createApplyEach(map);
      var applyEachSeries = createApplyEach(mapSeries);
      var log = createLogger("log");
      var dir = createLogger("dir");
      var index = {
        VERSION: "2.6.2",
        // Collections
        each,
        eachSeries,
        eachLimit,
        forEach: each,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit,
        eachOf: each,
        eachOfSeries: eachSeries,
        eachOfLimit: eachLimit,
        forEachOf: each,
        forEachOfSeries: eachSeries,
        forEachOfLimit: eachLimit,
        map,
        mapSeries,
        mapLimit,
        mapValues,
        mapValuesSeries,
        mapValuesLimit,
        filter,
        filterSeries,
        filterLimit,
        select: filter,
        selectSeries: filterSeries,
        selectLimit: filterLimit,
        reject,
        rejectSeries,
        rejectLimit,
        detect,
        detectSeries,
        detectLimit,
        find: detect,
        findSeries: detectSeries,
        findLimit: detectLimit,
        pick,
        pickSeries,
        pickLimit,
        omit,
        omitSeries,
        omitLimit,
        reduce,
        inject: reduce,
        foldl: reduce,
        reduceRight,
        foldr: reduceRight,
        transform,
        transformSeries,
        transformLimit,
        sortBy,
        sortBySeries,
        sortByLimit,
        some,
        someSeries,
        someLimit,
        any: some,
        anySeries: someSeries,
        anyLimit: someLimit,
        every,
        everySeries,
        everyLimit,
        all: every,
        allSeries: everySeries,
        allLimit: everyLimit,
        concat,
        concatSeries,
        concatLimit,
        groupBy,
        groupBySeries,
        groupByLimit,
        // Control Flow
        parallel,
        series,
        parallelLimit,
        tryEach,
        waterfall,
        angelFall,
        angelfall: angelFall,
        whilst,
        doWhilst,
        until,
        doUntil,
        during,
        doDuring,
        forever,
        compose,
        seq,
        applyEach,
        applyEachSeries,
        queue,
        priorityQueue,
        cargo,
        auto,
        autoInject,
        retry,
        retryable,
        iterator,
        times,
        timesSeries,
        timesLimit,
        race,
        // Utils
        apply,
        nextTick: asyncNextTick,
        setImmediate: asyncSetImmediate,
        memoize: memoize2,
        unmemoize,
        ensureAsync,
        constant,
        asyncify,
        wrapSync: asyncify,
        log,
        dir,
        reflect,
        reflectAll,
        timeout,
        createLogger,
        // Mode
        safe,
        fast
      };
      exports3["default"] = index;
      baseEachSync(
        index,
        function(func2, key) {
          exports3[key] = func2;
        },
        nativeKeys(index)
      );
      function createImmediate(safeMode) {
        var delay = function delay2(fn2) {
          var args = slice(arguments, 1);
          setTimeout(function() {
            fn2.apply(null, args);
          });
        };
        asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay;
        if (typeof process === obj && typeof process.nextTick === func) {
          nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick;
          asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick;
        } else {
          asyncNextTick = nextTick = asyncSetImmediate;
        }
        if (safeMode === false) {
          nextTick = function(cb) {
            cb();
          };
        }
      }
      function createArray(array) {
        var index2 = -1;
        var size = array.length;
        var result2 = Array(size);
        while (++index2 < size) {
          result2[index2] = array[index2];
        }
        return result2;
      }
      function slice(array, start) {
        var end = array.length;
        var index2 = -1;
        var size = end - start;
        if (size <= 0) {
          return [];
        }
        var result2 = Array(size);
        while (++index2 < size) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function objectClone(object) {
        var keys = nativeKeys(object);
        var size = keys.length;
        var index2 = -1;
        var result2 = {};
        while (++index2 < size) {
          var key = keys[index2];
          result2[key] = object[key];
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1;
        var size = array.length;
        var result2 = [];
        while (++index2 < size) {
          var value = array[index2];
          if (value) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      function reverse(array) {
        var index2 = -1;
        var size = array.length;
        var result2 = Array(size);
        var resIndex = size;
        while (++index2 < size) {
          result2[--resIndex] = array[index2];
        }
        return result2;
      }
      function has(object, key) {
        return object.hasOwnProperty(key);
      }
      function notInclude(array, target2) {
        var index2 = -1;
        var size = array.length;
        while (++index2 < size) {
          if (array[index2] === target2) {
            return false;
          }
        }
        return true;
      }
      function arrayEachSync(array, iterator2) {
        var index2 = -1;
        var size = array.length;
        while (++index2 < size) {
          iterator2(array[index2], index2);
        }
        return array;
      }
      function baseEachSync(object, iterator2, keys) {
        var index2 = -1;
        var size = keys.length;
        while (++index2 < size) {
          var key = keys[index2];
          iterator2(object[key], key);
        }
        return object;
      }
      function timesSync(n, iterator2) {
        var index2 = -1;
        while (++index2 < n) {
          iterator2(index2);
        }
      }
      function sortByCriteria(array, criteria) {
        var l = array.length;
        var indices = Array(l);
        var i;
        for (i = 0; i < l; i++) {
          indices[i] = i;
        }
        quickSort(criteria, 0, l - 1, indices);
        var result2 = Array(l);
        for (var n = 0; n < l; n++) {
          i = indices[n];
          result2[n] = i === void 0 ? array[n] : array[i];
        }
        return result2;
      }
      function partition(array, i, j, mid, indices) {
        var l = i;
        var r = j;
        while (l <= r) {
          i = l;
          while (l < r && array[l] < mid) {
            l++;
          }
          while (r >= i && array[r] >= mid) {
            r--;
          }
          if (l > r) {
            break;
          }
          swap(array, indices, l++, r--);
        }
        return l;
      }
      function swap(array, indices, l, r) {
        var n = array[l];
        array[l] = array[r];
        array[r] = n;
        var i = indices[l];
        indices[l] = indices[r];
        indices[r] = i;
      }
      function quickSort(array, i, j, indices) {
        if (i === j) {
          return;
        }
        var k = i;
        while (++k <= j && array[i] === array[k]) {
          var l = k - 1;
          if (indices[l] > indices[k]) {
            var index2 = indices[l];
            indices[l] = indices[k];
            indices[k] = index2;
          }
        }
        if (k > j) {
          return;
        }
        var p = array[i] > array[k] ? i : k;
        k = partition(array, i, j, array[p], indices);
        quickSort(array, i, k - 1, indices);
        quickSort(array, k, j, indices);
      }
      function makeConcatResult(array) {
        var result2 = [];
        arrayEachSync(array, function(value) {
          if (value === noop) {
            return;
          }
          if (isArray(value)) {
            nativePush.apply(result2, value);
          } else {
            result2.push(value);
          }
        });
        return result2;
      }
      function arrayEach(array, iterator2, callback) {
        var index2 = -1;
        var size = array.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            iterator2(array[index2], index2, onlyOnce(callback));
          }
        } else {
          while (++index2 < size) {
            iterator2(array[index2], onlyOnce(callback));
          }
        }
      }
      function baseEach(object, iterator2, callback, keys) {
        var key;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            iterator2(object[key], key, onlyOnce(callback));
          }
        } else {
          while (++index2 < size) {
            iterator2(object[keys[index2]], onlyOnce(callback));
          }
        }
      }
      function symbolEach(collection, iterator2, callback) {
        var iter = collection[iteratorSymbol]();
        var index2 = 0;
        var item;
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            iterator2(item.value, index2++, onlyOnce(callback));
          }
        } else {
          while ((item = iter.next()).done === false) {
            index2++;
            iterator2(item.value, onlyOnce(callback));
          }
        }
        return index2;
      }
      function arrayEachResult(array, result2, iterator2, callback) {
        var index2 = -1;
        var size = array.length;
        if (iterator2.length === 4) {
          while (++index2 < size) {
            iterator2(result2, array[index2], index2, onlyOnce(callback));
          }
        } else {
          while (++index2 < size) {
            iterator2(result2, array[index2], onlyOnce(callback));
          }
        }
      }
      function baseEachResult(object, result2, iterator2, callback, keys) {
        var key;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 4) {
          while (++index2 < size) {
            key = keys[index2];
            iterator2(result2, object[key], key, onlyOnce(callback));
          }
        } else {
          while (++index2 < size) {
            iterator2(result2, object[keys[index2]], onlyOnce(callback));
          }
        }
      }
      function symbolEachResult(collection, result2, iterator2, callback) {
        var item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 4) {
          while ((item = iter.next()).done === false) {
            iterator2(result2, item.value, index2++, onlyOnce(callback));
          }
        } else {
          while ((item = iter.next()).done === false) {
            index2++;
            iterator2(result2, item.value, onlyOnce(callback));
          }
        }
        return index2;
      }
      function arrayEachFunc(array, createCallback) {
        var index2 = -1;
        var size = array.length;
        while (++index2 < size) {
          array[index2](createCallback(index2));
        }
      }
      function baseEachFunc(object, createCallback, keys) {
        var key;
        var index2 = -1;
        var size = keys.length;
        while (++index2 < size) {
          key = keys[index2];
          object[key](createCallback(key));
        }
      }
      function arrayEachIndex(array, iterator2, createCallback) {
        var index2 = -1;
        var size = array.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            iterator2(array[index2], index2, createCallback(index2));
          }
        } else {
          while (++index2 < size) {
            iterator2(array[index2], createCallback(index2));
          }
        }
      }
      function baseEachIndex(object, iterator2, createCallback, keys) {
        var key;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            iterator2(object[key], key, createCallback(index2));
          }
        } else {
          while (++index2 < size) {
            iterator2(object[keys[index2]], createCallback(index2));
          }
        }
      }
      function symbolEachIndex(collection, iterator2, createCallback) {
        var item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            iterator2(item.value, index2, createCallback(index2++));
          }
        } else {
          while ((item = iter.next()).done === false) {
            iterator2(item.value, createCallback(index2++));
          }
        }
        return index2;
      }
      function baseEachKey(object, iterator2, createCallback, keys) {
        var key;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            iterator2(object[key], key, createCallback(key));
          }
        } else {
          while (++index2 < size) {
            key = keys[index2];
            iterator2(object[key], createCallback(key));
          }
        }
      }
      function symbolEachKey(collection, iterator2, createCallback) {
        var item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            iterator2(item.value, index2, createCallback(index2++));
          }
        } else {
          while ((item = iter.next()).done === false) {
            iterator2(item.value, createCallback(index2++));
          }
        }
        return index2;
      }
      function arrayEachValue(array, iterator2, createCallback) {
        var value;
        var index2 = -1;
        var size = array.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            value = array[index2];
            iterator2(value, index2, createCallback(value));
          }
        } else {
          while (++index2 < size) {
            value = array[index2];
            iterator2(value, createCallback(value));
          }
        }
      }
      function baseEachValue(object, iterator2, createCallback, keys) {
        var key, value;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            value = object[key];
            iterator2(value, key, createCallback(value));
          }
        } else {
          while (++index2 < size) {
            value = object[keys[index2]];
            iterator2(value, createCallback(value));
          }
        }
      }
      function symbolEachValue(collection, iterator2, createCallback) {
        var value, item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            value = item.value;
            iterator2(value, index2++, createCallback(value));
          }
        } else {
          while ((item = iter.next()).done === false) {
            index2++;
            value = item.value;
            iterator2(value, createCallback(value));
          }
        }
        return index2;
      }
      function arrayEachIndexValue(array, iterator2, createCallback) {
        var value;
        var index2 = -1;
        var size = array.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            value = array[index2];
            iterator2(value, index2, createCallback(index2, value));
          }
        } else {
          while (++index2 < size) {
            value = array[index2];
            iterator2(value, createCallback(index2, value));
          }
        }
      }
      function baseEachIndexValue(object, iterator2, createCallback, keys) {
        var key, value;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            value = object[key];
            iterator2(value, key, createCallback(index2, value));
          }
        } else {
          while (++index2 < size) {
            value = object[keys[index2]];
            iterator2(value, createCallback(index2, value));
          }
        }
      }
      function symbolEachIndexValue(collection, iterator2, createCallback) {
        var value, item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            value = item.value;
            iterator2(value, index2, createCallback(index2++, value));
          }
        } else {
          while ((item = iter.next()).done === false) {
            value = item.value;
            iterator2(value, createCallback(index2++, value));
          }
        }
        return index2;
      }
      function baseEachKeyValue(object, iterator2, createCallback, keys) {
        var key, value;
        var index2 = -1;
        var size = keys.length;
        if (iterator2.length === 3) {
          while (++index2 < size) {
            key = keys[index2];
            value = object[key];
            iterator2(value, key, createCallback(key, value));
          }
        } else {
          while (++index2 < size) {
            key = keys[index2];
            value = object[key];
            iterator2(value, createCallback(key, value));
          }
        }
      }
      function symbolEachKeyValue(collection, iterator2, createCallback) {
        var value, item;
        var index2 = 0;
        var iter = collection[iteratorSymbol]();
        if (iterator2.length === 3) {
          while ((item = iter.next()).done === false) {
            value = item.value;
            iterator2(value, index2, createCallback(index2++, value));
          }
        } else {
          while ((item = iter.next()).done === false) {
            value = item.value;
            iterator2(value, createCallback(index2++, value));
          }
        }
        return index2;
      }
      function onlyOnce(func2) {
        return function(err, res) {
          var fn2 = func2;
          func2 = throwError;
          fn2(err, res);
        };
      }
      function once(func2) {
        return function(err, res) {
          var fn2 = func2;
          func2 = noop;
          fn2(err, res);
        };
      }
      function createEach(arrayEach2, baseEach2, symbolEach2) {
        return function each2(collection, iterator2, callback) {
          callback = once(callback || noop);
          var size, keys;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            arrayEach2(collection, iterator2, done);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = symbolEach2(collection, iterator2, done);
            size && size === completed && callback(null);
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            baseEach2(collection, iterator2, done, keys);
          }
          if (!size) {
            callback(null);
          }
          function done(err, bool) {
            if (err) {
              callback = once(callback);
              callback(err);
            } else if (++completed === size) {
              callback(null);
            } else if (bool === false) {
              callback = once(callback);
              callback(null);
            }
          }
        };
      }
      function createMap(arrayEach2, baseEach2, symbolEach2, useArray) {
        var init, clone;
        if (useArray) {
          init = Array;
          clone = createArray;
        } else {
          init = function() {
            return {};
          };
          clone = objectClone;
        }
        return function(collection, iterator2, callback) {
          callback = callback || noop;
          var size, keys, result2;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            result2 = init(size);
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            result2 = init(0);
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, result2);
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            result2 = init(size);
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            callback(null, init());
          }
          function createCallback(key) {
            return function done(err, res) {
              if (key === null) {
                throwError();
              }
              if (err) {
                key = null;
                callback = once(callback);
                callback(err, clone(result2));
                return;
              }
              result2[key] = res;
              key = null;
              if (++completed === size) {
                callback(null, result2);
              }
            };
          }
        };
      }
      function createFilter(arrayEach2, baseEach2, symbolEach2, bool) {
        return function(collection, iterator2, callback) {
          callback = callback || noop;
          var size, keys, result2;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            result2 = Array(size);
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            result2 = [];
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, compact(result2));
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            result2 = Array(size);
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            return callback(null, []);
          }
          function createCallback(index2, value) {
            return function done(err, res) {
              if (index2 === null) {
                throwError();
              }
              if (err) {
                index2 = null;
                callback = once(callback);
                callback(err);
                return;
              }
              if (!!res === bool) {
                result2[index2] = value;
              }
              index2 = null;
              if (++completed === size) {
                callback(null, compact(result2));
              }
            };
          }
        };
      }
      function createFilterSeries(bool) {
        return function(collection, iterator2, callback) {
          callback = onlyOnce(callback || noop);
          var size, key, value, keys, iter, item, iterate;
          var sync = false;
          var completed = 0;
          var result2 = [];
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size) {
            return callback(null, []);
          }
          iterate();
          function arrayIterator() {
            value = collection[completed];
            iterator2(value, done);
          }
          function arrayIteratorWithIndex() {
            value = collection[completed];
            iterator2(value, completed, done);
          }
          function symbolIterator() {
            item = iter.next();
            value = item.value;
            item.done ? callback(null, result2) : iterator2(value, done);
          }
          function symbolIteratorWithKey() {
            item = iter.next();
            value = item.value;
            item.done ? callback(null, result2) : iterator2(value, completed, done);
          }
          function objectIterator() {
            key = keys[completed];
            value = collection[key];
            iterator2(value, done);
          }
          function objectIteratorWithKey() {
            key = keys[completed];
            value = collection[key];
            iterator2(value, key, done);
          }
          function done(err, res) {
            if (err) {
              callback(err);
              return;
            }
            if (!!res === bool) {
              result2[result2.length] = value;
            }
            if (++completed === size) {
              iterate = throwError;
              callback(null, result2);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          }
        };
      }
      function createFilterLimit(bool) {
        return function(collection, limit, iterator2, callback) {
          callback = callback || noop;
          var size, index2, key, value, keys, iter, item, iterate, result2;
          var sync = false;
          var started = 0;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            result2 = [];
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size || isNaN(limit) || limit < 1) {
            return callback(null, []);
          }
          result2 = result2 || Array(size);
          timesSync(limit > size ? size : limit, iterate);
          function arrayIterator() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, createCallback(value, index2));
            }
          }
          function arrayIteratorWithIndex() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, index2, createCallback(value, index2));
            }
          }
          function symbolIterator() {
            item = iter.next();
            if (item.done === false) {
              value = item.value;
              iterator2(value, createCallback(value, started++));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null, compact(result2));
            }
          }
          function symbolIteratorWithKey() {
            item = iter.next();
            if (item.done === false) {
              value = item.value;
              iterator2(value, started, createCallback(value, started++));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null, compact(result2));
            }
          }
          function objectIterator() {
            index2 = started++;
            if (index2 < size) {
              value = collection[keys[index2]];
              iterator2(value, createCallback(value, index2));
            }
          }
          function objectIteratorWithKey() {
            index2 = started++;
            if (index2 < size) {
              key = keys[index2];
              value = collection[key];
              iterator2(value, key, createCallback(value, index2));
            }
          }
          function createCallback(value2, index3) {
            return function(err, res) {
              if (index3 === null) {
                throwError();
              }
              if (err) {
                index3 = null;
                iterate = noop;
                callback = once(callback);
                callback(err);
                return;
              }
              if (!!res === bool) {
                result2[index3] = value2;
              }
              index3 = null;
              if (++completed === size) {
                callback = onlyOnce(callback);
                callback(null, compact(result2));
              } else if (sync) {
                nextTick(iterate);
              } else {
                sync = true;
                iterate();
              }
              sync = false;
            };
          }
        };
      }
      function eachSeries(collection, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var size, key, keys, iter, item, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null);
        }
        iterate();
        function arrayIterator() {
          iterator2(collection[completed], done);
        }
        function arrayIteratorWithIndex() {
          iterator2(collection[completed], completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          item.done ? callback(null) : iterator2(item.value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          item.done ? callback(null) : iterator2(item.value, completed, done);
        }
        function objectIterator() {
          iterator2(collection[keys[completed]], done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          iterator2(collection[key], key, done);
        }
        function done(err, bool) {
          if (err) {
            callback(err);
          } else if (++completed === size || bool === false) {
            iterate = throwError;
            callback(null);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function eachLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, index2, key, keys, iter, item, iterate;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        } else {
          return callback(null);
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null);
        }
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          if (started < size) {
            iterator2(collection[started++], done);
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[index2], index2, done);
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            started++;
            iterator2(item.value, done);
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null);
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, started++, done);
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null);
          }
        }
        function objectIterator() {
          if (started < size) {
            iterator2(collection[keys[started++]], done);
          }
        }
        function objectIteratorWithKey() {
          index2 = started++;
          if (index2 < size) {
            key = keys[index2];
            iterator2(collection[key], key, done);
          }
        }
        function done(err, bool) {
          if (err || bool === false) {
            iterate = noop;
            callback = once(callback);
            callback(err);
          } else if (++completed === size) {
            iterator2 = noop;
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(null);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function mapSeries(collection, iterator2, callback) {
        callback = callback || noop;
        var size, key, keys, iter, item, result2, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          result2 = [];
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, []);
        }
        result2 = result2 || Array(size);
        iterate();
        function arrayIterator() {
          iterator2(collection[completed], done);
        }
        function arrayIteratorWithIndex() {
          iterator2(collection[completed], completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, completed, done);
        }
        function objectIterator() {
          iterator2(collection[keys[completed]], done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          iterator2(collection[key], key, done);
        }
        function done(err, res) {
          if (err) {
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(err, createArray(result2));
            return;
          }
          result2[completed] = res;
          if (++completed === size) {
            iterate = throwError;
            callback(null, result2);
            callback = throwError;
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function mapLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, index2, key, keys, iter, item, result2, iterate;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          result2 = [];
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, []);
        }
        result2 = result2 || Array(size);
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[index2], createCallback(index2));
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[index2], index2, createCallback(index2));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, started, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function objectIterator() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[keys[index2]], createCallback(index2));
          }
        }
        function objectIteratorWithKey() {
          index2 = started++;
          if (index2 < size) {
            key = keys[index2];
            iterator2(collection[key], key, createCallback(index2));
          }
        }
        function createCallback(index3) {
          return function(err, res) {
            if (index3 === null) {
              throwError();
            }
            if (err) {
              index3 = null;
              iterate = noop;
              callback = once(callback);
              callback(err, createArray(result2));
              return;
            }
            result2[index3] = res;
            index3 = null;
            if (++completed === size) {
              iterate = throwError;
              callback(null, result2);
              callback = throwError;
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function mapValuesSeries(collection, iterator2, callback) {
        callback = callback || noop;
        var size, key, keys, iter, item, iterate;
        var sync = false;
        var result2 = {};
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, result2);
        }
        iterate();
        function arrayIterator() {
          key = completed;
          iterator2(collection[completed], done);
        }
        function arrayIteratorWithIndex() {
          key = completed;
          iterator2(collection[completed], completed, done);
        }
        function symbolIterator() {
          key = completed;
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, done);
        }
        function symbolIteratorWithKey() {
          key = completed;
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, completed, done);
        }
        function objectIterator() {
          key = keys[completed];
          iterator2(collection[key], done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          iterator2(collection[key], key, done);
        }
        function done(err, res) {
          if (err) {
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(err, objectClone(result2));
            return;
          }
          result2[key] = res;
          if (++completed === size) {
            iterate = throwError;
            callback(null, result2);
            callback = throwError;
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function mapValuesLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, index2, key, keys, iter, item, iterate;
        var sync = false;
        var result2 = {};
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, result2);
        }
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[index2], createCallback(index2));
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            iterator2(collection[index2], index2, createCallback(index2));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, started, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function objectIterator() {
          index2 = started++;
          if (index2 < size) {
            key = keys[index2];
            iterator2(collection[key], createCallback(key));
          }
        }
        function objectIteratorWithKey() {
          index2 = started++;
          if (index2 < size) {
            key = keys[index2];
            iterator2(collection[key], key, createCallback(key));
          }
        }
        function createCallback(key2) {
          return function(err, res) {
            if (key2 === null) {
              throwError();
            }
            if (err) {
              key2 = null;
              iterate = noop;
              callback = once(callback);
              callback(err, objectClone(result2));
              return;
            }
            result2[key2] = res;
            key2 = null;
            if (++completed === size) {
              callback(null, result2);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function createDetect(arrayEach2, baseEach2, symbolEach2, bool) {
        return function(collection, iterator2, callback) {
          callback = callback || noop;
          var size, keys;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null);
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            callback(null);
          }
          function createCallback(value) {
            var called = false;
            return function done(err, res) {
              if (called) {
                throwError();
              }
              called = true;
              if (err) {
                callback = once(callback);
                callback(err);
              } else if (!!res === bool) {
                callback = once(callback);
                callback(null, value);
              } else if (++completed === size) {
                callback(null);
              }
            };
          }
        };
      }
      function createDetectSeries(bool) {
        return function(collection, iterator2, callback) {
          callback = onlyOnce(callback || noop);
          var size, key, value, keys, iter, item, iterate;
          var sync = false;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size) {
            return callback(null);
          }
          iterate();
          function arrayIterator() {
            value = collection[completed];
            iterator2(value, done);
          }
          function arrayIteratorWithIndex() {
            value = collection[completed];
            iterator2(value, completed, done);
          }
          function symbolIterator() {
            item = iter.next();
            value = item.value;
            item.done ? callback(null) : iterator2(value, done);
          }
          function symbolIteratorWithKey() {
            item = iter.next();
            value = item.value;
            item.done ? callback(null) : iterator2(value, completed, done);
          }
          function objectIterator() {
            value = collection[keys[completed]];
            iterator2(value, done);
          }
          function objectIteratorWithKey() {
            key = keys[completed];
            value = collection[key];
            iterator2(value, key, done);
          }
          function done(err, res) {
            if (err) {
              callback(err);
            } else if (!!res === bool) {
              iterate = throwError;
              callback(null, value);
            } else if (++completed === size) {
              iterate = throwError;
              callback(null);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          }
        };
      }
      function createDetectLimit(bool) {
        return function(collection, limit, iterator2, callback) {
          callback = callback || noop;
          var size, index2, key, value, keys, iter, item, iterate;
          var sync = false;
          var started = 0;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size || isNaN(limit) || limit < 1) {
            return callback(null);
          }
          timesSync(limit > size ? size : limit, iterate);
          function arrayIterator() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, createCallback(value));
            }
          }
          function arrayIteratorWithIndex() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, index2, createCallback(value));
            }
          }
          function symbolIterator() {
            item = iter.next();
            if (item.done === false) {
              started++;
              value = item.value;
              iterator2(value, createCallback(value));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null);
            }
          }
          function symbolIteratorWithKey() {
            item = iter.next();
            if (item.done === false) {
              value = item.value;
              iterator2(value, started++, createCallback(value));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null);
            }
          }
          function objectIterator() {
            index2 = started++;
            if (index2 < size) {
              value = collection[keys[index2]];
              iterator2(value, createCallback(value));
            }
          }
          function objectIteratorWithKey() {
            if (started < size) {
              key = keys[started++];
              value = collection[key];
              iterator2(value, key, createCallback(value));
            }
          }
          function createCallback(value2) {
            var called = false;
            return function(err, res) {
              if (called) {
                throwError();
              }
              called = true;
              if (err) {
                iterate = noop;
                callback = once(callback);
                callback(err);
              } else if (!!res === bool) {
                iterate = noop;
                callback = once(callback);
                callback(null, value2);
              } else if (++completed === size) {
                callback(null);
              } else if (sync) {
                nextTick(iterate);
              } else {
                sync = true;
                iterate();
              }
              sync = false;
            };
          }
        };
      }
      function createPick(arrayEach2, baseEach2, symbolEach2, bool) {
        return function(collection, iterator2, callback) {
          callback = callback || noop;
          var size, keys;
          var completed = 0;
          var result2 = {};
          if (isArray(collection)) {
            size = collection.length;
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, result2);
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            return callback(null, {});
          }
          function createCallback(key, value) {
            return function done(err, res) {
              if (key === null) {
                throwError();
              }
              if (err) {
                key = null;
                callback = once(callback);
                callback(err, objectClone(result2));
                return;
              }
              if (!!res === bool) {
                result2[key] = value;
              }
              key = null;
              if (++completed === size) {
                callback(null, result2);
              }
            };
          }
        };
      }
      function createPickSeries(bool) {
        return function(collection, iterator2, callback) {
          callback = onlyOnce(callback || noop);
          var size, key, value, keys, iter, item, iterate;
          var sync = false;
          var result2 = {};
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size) {
            return callback(null, {});
          }
          iterate();
          function arrayIterator() {
            key = completed;
            value = collection[completed];
            iterator2(value, done);
          }
          function arrayIteratorWithIndex() {
            key = completed;
            value = collection[completed];
            iterator2(value, completed, done);
          }
          function symbolIterator() {
            key = completed;
            item = iter.next();
            value = item.value;
            item.done ? callback(null, result2) : iterator2(value, done);
          }
          function symbolIteratorWithKey() {
            key = completed;
            item = iter.next();
            value = item.value;
            item.done ? callback(null, result2) : iterator2(value, key, done);
          }
          function objectIterator() {
            key = keys[completed];
            value = collection[key];
            iterator2(value, done);
          }
          function objectIteratorWithKey() {
            key = keys[completed];
            value = collection[key];
            iterator2(value, key, done);
          }
          function done(err, res) {
            if (err) {
              callback(err, result2);
              return;
            }
            if (!!res === bool) {
              result2[key] = value;
            }
            if (++completed === size) {
              iterate = throwError;
              callback(null, result2);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          }
        };
      }
      function createPickLimit(bool) {
        return function(collection, limit, iterator2, callback) {
          callback = callback || noop;
          var size, index2, key, value, keys, iter, item, iterate;
          var sync = false;
          var result2 = {};
          var started = 0;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = Infinity;
            iter = collection[iteratorSymbol]();
            iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
          }
          if (!size || isNaN(limit) || limit < 1) {
            return callback(null, {});
          }
          timesSync(limit > size ? size : limit, iterate);
          function arrayIterator() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, createCallback(value, index2));
            }
          }
          function arrayIteratorWithIndex() {
            index2 = started++;
            if (index2 < size) {
              value = collection[index2];
              iterator2(value, index2, createCallback(value, index2));
            }
          }
          function symbolIterator() {
            item = iter.next();
            if (item.done === false) {
              value = item.value;
              iterator2(value, createCallback(value, started++));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null, result2);
            }
          }
          function symbolIteratorWithKey() {
            item = iter.next();
            if (item.done === false) {
              value = item.value;
              iterator2(value, started, createCallback(value, started++));
            } else if (completed === started && iterator2 !== noop) {
              iterator2 = noop;
              callback(null, result2);
            }
          }
          function objectIterator() {
            if (started < size) {
              key = keys[started++];
              value = collection[key];
              iterator2(value, createCallback(value, key));
            }
          }
          function objectIteratorWithKey() {
            if (started < size) {
              key = keys[started++];
              value = collection[key];
              iterator2(value, key, createCallback(value, key));
            }
          }
          function createCallback(value2, key2) {
            return function(err, res) {
              if (key2 === null) {
                throwError();
              }
              if (err) {
                key2 = null;
                iterate = noop;
                callback = once(callback);
                callback(err, objectClone(result2));
                return;
              }
              if (!!res === bool) {
                result2[key2] = value2;
              }
              key2 = null;
              if (++completed === size) {
                iterate = throwError;
                callback = onlyOnce(callback);
                callback(null, result2);
              } else if (sync) {
                nextTick(iterate);
              } else {
                sync = true;
                iterate();
              }
              sync = false;
            };
          }
        };
      }
      function reduce(collection, result2, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var size, key, keys, iter, item, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 4 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 4 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 4 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, result2);
        }
        iterate(result2);
        function arrayIterator(result3) {
          iterator2(result3, collection[completed], done);
        }
        function arrayIteratorWithIndex(result3) {
          iterator2(result3, collection[completed], completed, done);
        }
        function symbolIterator(result3) {
          item = iter.next();
          item.done ? callback(null, result3) : iterator2(result3, item.value, done);
        }
        function symbolIteratorWithKey(result3) {
          item = iter.next();
          item.done ? callback(null, result3) : iterator2(result3, item.value, completed, done);
        }
        function objectIterator(result3) {
          iterator2(result3, collection[keys[completed]], done);
        }
        function objectIteratorWithKey(result3) {
          key = keys[completed];
          iterator2(result3, collection[key], key, done);
        }
        function done(err, result3) {
          if (err) {
            callback(err, result3);
          } else if (++completed === size) {
            iterator2 = throwError;
            callback(null, result3);
          } else if (sync) {
            nextTick(function() {
              iterate(result3);
            });
          } else {
            sync = true;
            iterate(result3);
          }
          sync = false;
        }
      }
      function reduceRight(collection, result2, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var resIndex, index2, key, keys, iter, item, col, iterate;
        var sync = false;
        if (isArray(collection)) {
          resIndex = collection.length;
          iterate = iterator2.length === 4 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          col = [];
          iter = collection[iteratorSymbol]();
          index2 = -1;
          while ((item = iter.next()).done === false) {
            col[++index2] = item.value;
          }
          collection = col;
          resIndex = col.length;
          iterate = iterator2.length === 4 ? arrayIteratorWithIndex : arrayIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          resIndex = keys.length;
          iterate = iterator2.length === 4 ? objectIteratorWithKey : objectIterator;
        }
        if (!resIndex) {
          return callback(null, result2);
        }
        iterate(result2);
        function arrayIterator(result3) {
          iterator2(result3, collection[--resIndex], done);
        }
        function arrayIteratorWithIndex(result3) {
          iterator2(result3, collection[--resIndex], resIndex, done);
        }
        function objectIterator(result3) {
          iterator2(result3, collection[keys[--resIndex]], done);
        }
        function objectIteratorWithKey(result3) {
          key = keys[--resIndex];
          iterator2(result3, collection[key], key, done);
        }
        function done(err, result3) {
          if (err) {
            callback(err, result3);
          } else if (resIndex === 0) {
            iterate = throwError;
            callback(null, result3);
          } else if (sync) {
            nextTick(function() {
              iterate(result3);
            });
          } else {
            sync = true;
            iterate(result3);
          }
          sync = false;
        }
      }
      function createTransform(arrayEach2, baseEach2, symbolEach2) {
        return function transform2(collection, accumulator, iterator2, callback) {
          if (arguments.length === 3) {
            callback = iterator2;
            iterator2 = accumulator;
            accumulator = void 0;
          }
          callback = callback || noop;
          var size, keys, result2;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            result2 = accumulator !== void 0 ? accumulator : [];
            arrayEach2(collection, result2, iterator2, done);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            result2 = accumulator !== void 0 ? accumulator : {};
            size = symbolEach2(collection, result2, iterator2, done);
            size && size === completed && callback(null, result2);
          } else if (typeof collection === obj) {
            keys = nativeKeys(collection);
            size = keys.length;
            result2 = accumulator !== void 0 ? accumulator : {};
            baseEach2(collection, result2, iterator2, done, keys);
          }
          if (!size) {
            callback(null, accumulator !== void 0 ? accumulator : result2 || {});
          }
          function done(err, bool) {
            if (err) {
              callback = once(callback);
              callback(err, isArray(result2) ? createArray(result2) : objectClone(result2));
            } else if (++completed === size) {
              callback(null, result2);
            } else if (bool === false) {
              callback = once(callback);
              callback(null, isArray(result2) ? createArray(result2) : objectClone(result2));
            }
          }
        };
      }
      function transformSeries(collection, accumulator, iterator2, callback) {
        if (arguments.length === 3) {
          callback = iterator2;
          iterator2 = accumulator;
          accumulator = void 0;
        }
        callback = onlyOnce(callback || noop);
        var size, key, keys, iter, item, iterate, result2;
        var sync = false;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          result2 = accumulator !== void 0 ? accumulator : [];
          iterate = iterator2.length === 4 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          result2 = accumulator !== void 0 ? accumulator : {};
          iterate = iterator2.length === 4 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          result2 = accumulator !== void 0 ? accumulator : {};
          iterate = iterator2.length === 4 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, accumulator !== void 0 ? accumulator : result2 || {});
        }
        iterate();
        function arrayIterator() {
          iterator2(result2, collection[completed], done);
        }
        function arrayIteratorWithIndex() {
          iterator2(result2, collection[completed], completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(result2, item.value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(result2, item.value, completed, done);
        }
        function objectIterator() {
          iterator2(result2, collection[keys[completed]], done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          iterator2(result2, collection[key], key, done);
        }
        function done(err, bool) {
          if (err) {
            callback(err, result2);
          } else if (++completed === size || bool === false) {
            iterate = throwError;
            callback(null, result2);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function transformLimit(collection, limit, accumulator, iterator2, callback) {
        if (arguments.length === 4) {
          callback = iterator2;
          iterator2 = accumulator;
          accumulator = void 0;
        }
        callback = callback || noop;
        var size, index2, key, keys, iter, item, iterate, result2;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          result2 = accumulator !== void 0 ? accumulator : [];
          iterate = iterator2.length === 4 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          result2 = accumulator !== void 0 ? accumulator : {};
          iterate = iterator2.length === 4 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          result2 = accumulator !== void 0 ? accumulator : {};
          iterate = iterator2.length === 4 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, accumulator !== void 0 ? accumulator : result2 || {});
        }
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          index2 = started++;
          if (index2 < size) {
            iterator2(result2, collection[index2], onlyOnce(done));
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            iterator2(result2, collection[index2], index2, onlyOnce(done));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            started++;
            iterator2(result2, item.value, onlyOnce(done));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            iterator2(result2, item.value, started++, onlyOnce(done));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function objectIterator() {
          index2 = started++;
          if (index2 < size) {
            iterator2(result2, collection[keys[index2]], onlyOnce(done));
          }
        }
        function objectIteratorWithKey() {
          index2 = started++;
          if (index2 < size) {
            key = keys[index2];
            iterator2(result2, collection[key], key, onlyOnce(done));
          }
        }
        function done(err, bool) {
          if (err || bool === false) {
            iterate = noop;
            callback(err || null, isArray(result2) ? createArray(result2) : objectClone(result2));
            callback = noop;
          } else if (++completed === size) {
            iterator2 = noop;
            callback(null, result2);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function createSortBy(arrayEach2, baseEach2, symbolEach2) {
        return function sortBy2(collection, iterator2, callback) {
          callback = callback || noop;
          var size, array, criteria;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            array = Array(size);
            criteria = Array(size);
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            array = [];
            criteria = [];
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, sortByCriteria(array, criteria));
          } else if (typeof collection === obj) {
            var keys = nativeKeys(collection);
            size = keys.length;
            array = Array(size);
            criteria = Array(size);
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            callback(null, []);
          }
          function createCallback(index2, value) {
            var called = false;
            array[index2] = value;
            return function done(err, criterion) {
              if (called) {
                throwError();
              }
              called = true;
              criteria[index2] = criterion;
              if (err) {
                callback = once(callback);
                callback(err);
              } else if (++completed === size) {
                callback(null, sortByCriteria(array, criteria));
              }
            };
          }
        };
      }
      function sortBySeries(collection, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var size, key, value, keys, iter, item, array, criteria, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          array = collection;
          criteria = Array(size);
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          array = [];
          criteria = [];
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          array = Array(size);
          criteria = Array(size);
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, []);
        }
        iterate();
        function arrayIterator() {
          value = collection[completed];
          iterator2(value, done);
        }
        function arrayIteratorWithIndex() {
          value = collection[completed];
          iterator2(value, completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done) {
            return callback(null, sortByCriteria(array, criteria));
          }
          value = item.value;
          array[completed] = value;
          iterator2(value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done) {
            return callback(null, sortByCriteria(array, criteria));
          }
          value = item.value;
          array[completed] = value;
          iterator2(value, completed, done);
        }
        function objectIterator() {
          value = collection[keys[completed]];
          array[completed] = value;
          iterator2(value, done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          value = collection[key];
          array[completed] = value;
          iterator2(value, key, done);
        }
        function done(err, criterion) {
          criteria[completed] = criterion;
          if (err) {
            callback(err);
          } else if (++completed === size) {
            iterate = throwError;
            callback(null, sortByCriteria(array, criteria));
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function sortByLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, index2, key, value, array, keys, iter, item, criteria, iterate;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          array = collection;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          array = [];
          criteria = [];
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          array = Array(size);
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, []);
        }
        criteria = criteria || Array(size);
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          if (started < size) {
            value = collection[started];
            iterator2(value, createCallback(value, started++));
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            value = collection[index2];
            iterator2(value, index2, createCallback(value, index2));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            value = item.value;
            array[started] = value;
            iterator2(value, createCallback(value, started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, sortByCriteria(array, criteria));
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            value = item.value;
            array[started] = value;
            iterator2(value, started, createCallback(value, started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, sortByCriteria(array, criteria));
          }
        }
        function objectIterator() {
          if (started < size) {
            value = collection[keys[started]];
            array[started] = value;
            iterator2(value, createCallback(value, started++));
          }
        }
        function objectIteratorWithKey() {
          if (started < size) {
            key = keys[started];
            value = collection[key];
            array[started] = value;
            iterator2(value, key, createCallback(value, started++));
          }
        }
        function createCallback(value2, index3) {
          var called = false;
          return function(err, criterion) {
            if (called) {
              throwError();
            }
            called = true;
            criteria[index3] = criterion;
            if (err) {
              iterate = noop;
              callback(err);
              callback = noop;
            } else if (++completed === size) {
              callback(null, sortByCriteria(array, criteria));
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function some(collection, iterator2, callback) {
        callback = callback || noop;
        detect(collection, iterator2, done);
        function done(err, res) {
          if (err) {
            return callback(err);
          }
          callback(null, !!res);
        }
      }
      function someSeries(collection, iterator2, callback) {
        callback = callback || noop;
        detectSeries(collection, iterator2, done);
        function done(err, res) {
          if (err) {
            return callback(err);
          }
          callback(null, !!res);
        }
      }
      function someLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        detectLimit(collection, limit, iterator2, done);
        function done(err, res) {
          if (err) {
            return callback(err);
          }
          callback(null, !!res);
        }
      }
      function createEvery(arrayEach2, baseEach2, symbolEach2) {
        var deny = createDetect(arrayEach2, baseEach2, symbolEach2, false);
        return function every2(collection, iterator2, callback) {
          callback = callback || noop;
          deny(collection, iterator2, done);
          function done(err, res) {
            if (err) {
              return callback(err);
            }
            callback(null, !res);
          }
        };
      }
      function createEverySeries() {
        var denySeries = createDetectSeries(false);
        return function everySeries2(collection, iterator2, callback) {
          callback = callback || noop;
          denySeries(collection, iterator2, done);
          function done(err, res) {
            if (err) {
              return callback(err);
            }
            callback(null, !res);
          }
        };
      }
      function createEveryLimit() {
        var denyLimit = createDetectLimit(false);
        return function everyLimit2(collection, limit, iterator2, callback) {
          callback = callback || noop;
          denyLimit(collection, limit, iterator2, done);
          function done(err, res) {
            if (err) {
              return callback(err);
            }
            callback(null, !res);
          }
        };
      }
      function createConcat(arrayEach2, baseEach2, symbolEach2) {
        return function concat2(collection, iterator2, callback) {
          callback = callback || noop;
          var size, result2;
          var completed = 0;
          if (isArray(collection)) {
            size = collection.length;
            result2 = Array(size);
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            result2 = [];
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, result2);
          } else if (typeof collection === obj) {
            var keys = nativeKeys(collection);
            size = keys.length;
            result2 = Array(size);
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            callback(null, []);
          }
          function createCallback(index2) {
            return function done(err, res) {
              if (index2 === null) {
                throwError();
              }
              if (err) {
                index2 = null;
                callback = once(callback);
                arrayEachSync(result2, function(array, index3) {
                  if (array === void 0) {
                    result2[index3] = noop;
                  }
                });
                callback(err, makeConcatResult(result2));
                return;
              }
              switch (arguments.length) {
                case 0:
                case 1:
                  result2[index2] = noop;
                  break;
                case 2:
                  result2[index2] = res;
                  break;
                default:
                  result2[index2] = slice(arguments, 1);
                  break;
              }
              index2 = null;
              if (++completed === size) {
                callback(null, makeConcatResult(result2));
              }
            };
          }
        };
      }
      function concatSeries(collection, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var size, key, keys, iter, item, iterate;
        var sync = false;
        var result2 = [];
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, result2);
        }
        iterate();
        function arrayIterator() {
          iterator2(collection[completed], done);
        }
        function arrayIteratorWithIndex() {
          iterator2(collection[completed], completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          item.done ? callback(null, result2) : iterator2(item.value, completed, done);
        }
        function objectIterator() {
          iterator2(collection[keys[completed]], done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          iterator2(collection[key], key, done);
        }
        function done(err, array) {
          if (isArray(array)) {
            nativePush.apply(result2, array);
          } else if (arguments.length >= 2) {
            nativePush.apply(result2, slice(arguments, 1));
          }
          if (err) {
            callback(err, result2);
          } else if (++completed === size) {
            iterate = throwError;
            callback(null, result2);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function concatLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, key, iter, item, iterate, result2;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          result2 = [];
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          var keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, []);
        }
        result2 = result2 || Array(size);
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          if (started < size) {
            iterator2(collection[started], createCallback(started++));
          }
        }
        function arrayIteratorWithIndex() {
          if (started < size) {
            iterator2(collection[started], started, createCallback(started++));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, makeConcatResult(result2));
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            iterator2(item.value, started, createCallback(started++));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, makeConcatResult(result2));
          }
        }
        function objectIterator() {
          if (started < size) {
            iterator2(collection[keys[started]], createCallback(started++));
          }
        }
        function objectIteratorWithKey() {
          if (started < size) {
            key = keys[started];
            iterator2(collection[key], key, createCallback(started++));
          }
        }
        function createCallback(index2) {
          return function(err, res) {
            if (index2 === null) {
              throwError();
            }
            if (err) {
              index2 = null;
              iterate = noop;
              callback = once(callback);
              arrayEachSync(result2, function(array, index3) {
                if (array === void 0) {
                  result2[index3] = noop;
                }
              });
              callback(err, makeConcatResult(result2));
              return;
            }
            switch (arguments.length) {
              case 0:
              case 1:
                result2[index2] = noop;
                break;
              case 2:
                result2[index2] = res;
                break;
              default:
                result2[index2] = slice(arguments, 1);
                break;
            }
            index2 = null;
            if (++completed === size) {
              iterate = throwError;
              callback(null, makeConcatResult(result2));
              callback = throwError;
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function createGroupBy(arrayEach2, baseEach2, symbolEach2) {
        return function groupBy2(collection, iterator2, callback) {
          callback = callback || noop;
          var size;
          var completed = 0;
          var result2 = {};
          if (isArray(collection)) {
            size = collection.length;
            arrayEach2(collection, iterator2, createCallback);
          } else if (!collection) {
          } else if (iteratorSymbol && collection[iteratorSymbol]) {
            size = symbolEach2(collection, iterator2, createCallback);
            size && size === completed && callback(null, result2);
          } else if (typeof collection === obj) {
            var keys = nativeKeys(collection);
            size = keys.length;
            baseEach2(collection, iterator2, createCallback, keys);
          }
          if (!size) {
            callback(null, {});
          }
          function createCallback(value) {
            var called = false;
            return function done(err, key) {
              if (called) {
                throwError();
              }
              called = true;
              if (err) {
                callback = once(callback);
                callback(err, objectClone(result2));
                return;
              }
              var array = result2[key];
              if (!array) {
                result2[key] = [value];
              } else {
                array.push(value);
              }
              if (++completed === size) {
                callback(null, result2);
              }
            };
          }
        };
      }
      function groupBySeries(collection, iterator2, callback) {
        callback = onlyOnce(callback || noop);
        var size, key, value, keys, iter, item, iterate;
        var sync = false;
        var completed = 0;
        var result2 = {};
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size) {
          return callback(null, result2);
        }
        iterate();
        function arrayIterator() {
          value = collection[completed];
          iterator2(value, done);
        }
        function arrayIteratorWithIndex() {
          value = collection[completed];
          iterator2(value, completed, done);
        }
        function symbolIterator() {
          item = iter.next();
          value = item.value;
          item.done ? callback(null, result2) : iterator2(value, done);
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          value = item.value;
          item.done ? callback(null, result2) : iterator2(value, completed, done);
        }
        function objectIterator() {
          value = collection[keys[completed]];
          iterator2(value, done);
        }
        function objectIteratorWithKey() {
          key = keys[completed];
          value = collection[key];
          iterator2(value, key, done);
        }
        function done(err, key2) {
          if (err) {
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(err, objectClone(result2));
            return;
          }
          var array = result2[key2];
          if (!array) {
            result2[key2] = [value];
          } else {
            array.push(value);
          }
          if (++completed === size) {
            iterate = throwError;
            callback(null, result2);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function groupByLimit(collection, limit, iterator2, callback) {
        callback = callback || noop;
        var size, index2, key, value, keys, iter, item, iterate;
        var sync = false;
        var started = 0;
        var completed = 0;
        var result2 = {};
        if (isArray(collection)) {
          size = collection.length;
          iterate = iterator2.length === 3 ? arrayIteratorWithIndex : arrayIterator;
        } else if (!collection) {
        } else if (iteratorSymbol && collection[iteratorSymbol]) {
          size = Infinity;
          iter = collection[iteratorSymbol]();
          iterate = iterator2.length === 3 ? symbolIteratorWithKey : symbolIterator;
        } else if (typeof collection === obj) {
          keys = nativeKeys(collection);
          size = keys.length;
          iterate = iterator2.length === 3 ? objectIteratorWithKey : objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, result2);
        }
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          if (started < size) {
            value = collection[started++];
            iterator2(value, createCallback(value));
          }
        }
        function arrayIteratorWithIndex() {
          index2 = started++;
          if (index2 < size) {
            value = collection[index2];
            iterator2(value, index2, createCallback(value));
          }
        }
        function symbolIterator() {
          item = iter.next();
          if (item.done === false) {
            started++;
            value = item.value;
            iterator2(value, createCallback(value));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function symbolIteratorWithKey() {
          item = iter.next();
          if (item.done === false) {
            value = item.value;
            iterator2(value, started++, createCallback(value));
          } else if (completed === started && iterator2 !== noop) {
            iterator2 = noop;
            callback(null, result2);
          }
        }
        function objectIterator() {
          if (started < size) {
            value = collection[keys[started++]];
            iterator2(value, createCallback(value));
          }
        }
        function objectIteratorWithKey() {
          if (started < size) {
            key = keys[started++];
            value = collection[key];
            iterator2(value, key, createCallback(value));
          }
        }
        function createCallback(value2) {
          var called = false;
          return function(err, key2) {
            if (called) {
              throwError();
            }
            called = true;
            if (err) {
              iterate = noop;
              callback = once(callback);
              callback(err, objectClone(result2));
              return;
            }
            var array = result2[key2];
            if (!array) {
              result2[key2] = [value2];
            } else {
              array.push(value2);
            }
            if (++completed === size) {
              callback(null, result2);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function createParallel(arrayEach2, baseEach2) {
        return function parallel2(tasks, callback) {
          callback = callback || noop;
          var size, keys, result2;
          var completed = 0;
          if (isArray(tasks)) {
            size = tasks.length;
            result2 = Array(size);
            arrayEach2(tasks, createCallback);
          } else if (tasks && typeof tasks === obj) {
            keys = nativeKeys(tasks);
            size = keys.length;
            result2 = {};
            baseEach2(tasks, createCallback, keys);
          }
          if (!size) {
            callback(null, result2);
          }
          function createCallback(key) {
            return function(err, res) {
              if (key === null) {
                throwError();
              }
              if (err) {
                key = null;
                callback = once(callback);
                callback(err, result2);
                return;
              }
              result2[key] = arguments.length <= 2 ? res : slice(arguments, 1);
              key = null;
              if (++completed === size) {
                callback(null, result2);
              }
            };
          }
        };
      }
      function series(tasks, callback) {
        callback = callback || noop;
        var size, key, keys, result2, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(tasks)) {
          size = tasks.length;
          result2 = Array(size);
          iterate = arrayIterator;
        } else if (tasks && typeof tasks === obj) {
          keys = nativeKeys(tasks);
          size = keys.length;
          result2 = {};
          iterate = objectIterator;
        } else {
          return callback(null);
        }
        if (!size) {
          return callback(null, result2);
        }
        iterate();
        function arrayIterator() {
          key = completed;
          tasks[completed](done);
        }
        function objectIterator() {
          key = keys[completed];
          tasks[key](done);
        }
        function done(err, res) {
          if (err) {
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(err, result2);
            return;
          }
          result2[key] = arguments.length <= 2 ? res : slice(arguments, 1);
          if (++completed === size) {
            iterate = throwError;
            callback(null, result2);
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function parallelLimit(tasks, limit, callback) {
        callback = callback || noop;
        var size, index2, key, keys, result2, iterate;
        var sync = false;
        var started = 0;
        var completed = 0;
        if (isArray(tasks)) {
          size = tasks.length;
          result2 = Array(size);
          iterate = arrayIterator;
        } else if (tasks && typeof tasks === obj) {
          keys = nativeKeys(tasks);
          size = keys.length;
          result2 = {};
          iterate = objectIterator;
        }
        if (!size || isNaN(limit) || limit < 1) {
          return callback(null, result2);
        }
        timesSync(limit > size ? size : limit, iterate);
        function arrayIterator() {
          index2 = started++;
          if (index2 < size) {
            tasks[index2](createCallback(index2));
          }
        }
        function objectIterator() {
          if (started < size) {
            key = keys[started++];
            tasks[key](createCallback(key));
          }
        }
        function createCallback(key2) {
          return function(err, res) {
            if (key2 === null) {
              throwError();
            }
            if (err) {
              key2 = null;
              iterate = noop;
              callback = once(callback);
              callback(err, result2);
              return;
            }
            result2[key2] = arguments.length <= 2 ? res : slice(arguments, 1);
            key2 = null;
            if (++completed === size) {
              callback(null, result2);
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function tryEach(tasks, callback) {
        callback = callback || noop;
        var size, keys, iterate;
        var sync = false;
        var completed = 0;
        if (isArray(tasks)) {
          size = tasks.length;
          iterate = arrayIterator;
        } else if (tasks && typeof tasks === obj) {
          keys = nativeKeys(tasks);
          size = keys.length;
          iterate = objectIterator;
        }
        if (!size) {
          return callback(null);
        }
        iterate();
        function arrayIterator() {
          tasks[completed](done);
        }
        function objectIterator() {
          tasks[keys[completed]](done);
        }
        function done(err, res) {
          if (!err) {
            if (arguments.length <= 2) {
              callback(null, res);
            } else {
              callback(null, slice(arguments, 1));
            }
          } else if (++completed === size) {
            callback(err);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function checkWaterfallTasks(tasks, callback) {
        if (!isArray(tasks)) {
          callback(new Error("First argument to waterfall must be an array of functions"));
          return false;
        }
        if (tasks.length === 0) {
          callback(null);
          return false;
        }
        return true;
      }
      function waterfallIterator(func2, args, next) {
        switch (args.length) {
          case 0:
          case 1:
            return func2(next);
          case 2:
            return func2(args[1], next);
          case 3:
            return func2(args[1], args[2], next);
          case 4:
            return func2(args[1], args[2], args[3], next);
          case 5:
            return func2(args[1], args[2], args[3], args[4], next);
          case 6:
            return func2(args[1], args[2], args[3], args[4], args[5], next);
          default:
            args = slice(args, 1);
            args.push(next);
            return func2.apply(null, args);
        }
      }
      function waterfall(tasks, callback) {
        callback = callback || noop;
        if (!checkWaterfallTasks(tasks, callback)) {
          return;
        }
        var func2, args, done, sync;
        var completed = 0;
        var size = tasks.length;
        waterfallIterator(tasks[0], [], createCallback(0));
        function iterate() {
          waterfallIterator(func2, args, createCallback(func2));
        }
        function createCallback(index2) {
          return function next(err, res) {
            if (index2 === void 0) {
              callback = noop;
              throwError();
            }
            index2 = void 0;
            if (err) {
              done = callback;
              callback = throwError;
              done(err);
              return;
            }
            if (++completed === size) {
              done = callback;
              callback = throwError;
              if (arguments.length <= 2) {
                done(err, res);
              } else {
                done.apply(null, createArray(arguments));
              }
              return;
            }
            if (sync) {
              args = arguments;
              func2 = tasks[completed] || throwError;
              nextTick(iterate);
            } else {
              sync = true;
              waterfallIterator(tasks[completed] || throwError, arguments, createCallback(completed));
            }
            sync = false;
          };
        }
      }
      function angelFall(tasks, callback) {
        callback = callback || noop;
        if (!checkWaterfallTasks(tasks, callback)) {
          return;
        }
        var completed = 0;
        var sync = false;
        var size = tasks.length;
        var func2 = tasks[completed];
        var args = [];
        var iterate = function() {
          switch (func2.length) {
            case 0:
              try {
                next(null, func2());
              } catch (e) {
                next(e);
              }
              return;
            case 1:
              return func2(next);
            case 2:
              return func2(args[1], next);
            case 3:
              return func2(args[1], args[2], next);
            case 4:
              return func2(args[1], args[2], args[3], next);
            case 5:
              return func2(args[1], args[2], args[3], args[4], next);
            default:
              args = slice(args, 1);
              args[func2.length - 1] = next;
              return func2.apply(null, args);
          }
        };
        iterate();
        function next(err, res) {
          if (err) {
            iterate = throwError;
            callback = onlyOnce(callback);
            callback(err);
            return;
          }
          if (++completed === size) {
            iterate = throwError;
            var done = callback;
            callback = throwError;
            if (arguments.length === 2) {
              done(err, res);
            } else {
              done.apply(null, createArray(arguments));
            }
            return;
          }
          func2 = tasks[completed];
          args = arguments;
          if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function whilst(test, iterator2, callback) {
        callback = callback || noop;
        var sync = false;
        if (test()) {
          iterate();
        } else {
          callback(null);
        }
        function iterate() {
          if (sync) {
            nextTick(next);
          } else {
            sync = true;
            iterator2(done);
          }
          sync = false;
        }
        function next() {
          iterator2(done);
        }
        function done(err, arg) {
          if (err) {
            return callback(err);
          }
          if (arguments.length <= 2) {
            if (test(arg)) {
              iterate();
            } else {
              callback(null, arg);
            }
            return;
          }
          arg = slice(arguments, 1);
          if (test.apply(null, arg)) {
            iterate();
          } else {
            callback.apply(null, [null].concat(arg));
          }
        }
      }
      function doWhilst(iterator2, test, callback) {
        callback = callback || noop;
        var sync = false;
        next();
        function iterate() {
          if (sync) {
            nextTick(next);
          } else {
            sync = true;
            iterator2(done);
          }
          sync = false;
        }
        function next() {
          iterator2(done);
        }
        function done(err, arg) {
          if (err) {
            return callback(err);
          }
          if (arguments.length <= 2) {
            if (test(arg)) {
              iterate();
            } else {
              callback(null, arg);
            }
            return;
          }
          arg = slice(arguments, 1);
          if (test.apply(null, arg)) {
            iterate();
          } else {
            callback.apply(null, [null].concat(arg));
          }
        }
      }
      function until(test, iterator2, callback) {
        callback = callback || noop;
        var sync = false;
        if (!test()) {
          iterate();
        } else {
          callback(null);
        }
        function iterate() {
          if (sync) {
            nextTick(next);
          } else {
            sync = true;
            iterator2(done);
          }
          sync = false;
        }
        function next() {
          iterator2(done);
        }
        function done(err, arg) {
          if (err) {
            return callback(err);
          }
          if (arguments.length <= 2) {
            if (!test(arg)) {
              iterate();
            } else {
              callback(null, arg);
            }
            return;
          }
          arg = slice(arguments, 1);
          if (!test.apply(null, arg)) {
            iterate();
          } else {
            callback.apply(null, [null].concat(arg));
          }
        }
      }
      function doUntil(iterator2, test, callback) {
        callback = callback || noop;
        var sync = false;
        next();
        function iterate() {
          if (sync) {
            nextTick(next);
          } else {
            sync = true;
            iterator2(done);
          }
          sync = false;
        }
        function next() {
          iterator2(done);
        }
        function done(err, arg) {
          if (err) {
            return callback(err);
          }
          if (arguments.length <= 2) {
            if (!test(arg)) {
              iterate();
            } else {
              callback(null, arg);
            }
            return;
          }
          arg = slice(arguments, 1);
          if (!test.apply(null, arg)) {
            iterate();
          } else {
            callback.apply(null, [null].concat(arg));
          }
        }
      }
      function during(test, iterator2, callback) {
        callback = callback || noop;
        _test();
        function _test() {
          test(iterate);
        }
        function iterate(err, truth) {
          if (err) {
            return callback(err);
          }
          if (truth) {
            iterator2(done);
          } else {
            callback(null);
          }
        }
        function done(err) {
          if (err) {
            return callback(err);
          }
          _test();
        }
      }
      function doDuring(iterator2, test, callback) {
        callback = callback || noop;
        iterate(null, true);
        function iterate(err, truth) {
          if (err) {
            return callback(err);
          }
          if (truth) {
            iterator2(done);
          } else {
            callback(null);
          }
        }
        function done(err, res) {
          if (err) {
            return callback(err);
          }
          switch (arguments.length) {
            case 0:
            case 1:
              test(iterate);
              break;
            case 2:
              test(res, iterate);
              break;
            default:
              var args = slice(arguments, 1);
              args.push(iterate);
              test.apply(null, args);
              break;
          }
        }
      }
      function forever(iterator2, callback) {
        var sync = false;
        iterate();
        function iterate() {
          iterator2(next);
        }
        function next(err) {
          if (err) {
            if (callback) {
              return callback(err);
            }
            throw err;
          }
          if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function compose() {
        return seq.apply(null, reverse(arguments));
      }
      function seq() {
        var fns = createArray(arguments);
        return function() {
          var self = this;
          var args = createArray(arguments);
          var callback = args[args.length - 1];
          if (typeof callback === func) {
            args.pop();
          } else {
            callback = noop;
          }
          reduce(fns, args, iterator2, done);
          function iterator2(newargs, fn2, callback2) {
            var func2 = function(err) {
              var nextargs = slice(arguments, 1);
              callback2(err, nextargs);
            };
            newargs.push(func2);
            fn2.apply(self, newargs);
          }
          function done(err, res) {
            res = isArray(res) ? res : [res];
            res.unshift(err);
            callback.apply(self, res);
          }
        };
      }
      function createApplyEach(func2) {
        return function applyEach2(fns) {
          var go = function() {
            var self = this;
            var args2 = createArray(arguments);
            var callback = args2.pop() || noop;
            return func2(fns, iterator2, callback);
            function iterator2(fn2, done) {
              fn2.apply(self, args2.concat([done]));
            }
          };
          if (arguments.length > 1) {
            var args = slice(arguments, 1);
            return go.apply(this, args);
          } else {
            return go;
          }
        };
      }
      function DLL() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      DLL.prototype._removeLink = function(node3) {
        var prev = node3.prev;
        var next = node3.next;
        if (prev) {
          prev.next = next;
        } else {
          this.head = next;
        }
        if (next) {
          next.prev = prev;
        } else {
          this.tail = prev;
        }
        node3.prev = null;
        node3.next = null;
        this.length--;
        return node3;
      };
      DLL.prototype.empty = DLL;
      DLL.prototype._setInitial = function(node3) {
        this.length = 1;
        this.head = this.tail = node3;
      };
      DLL.prototype.insertBefore = function(node3, newNode) {
        newNode.prev = node3.prev;
        newNode.next = node3;
        if (node3.prev) {
          node3.prev.next = newNode;
        } else {
          this.head = newNode;
        }
        node3.prev = newNode;
        this.length++;
      };
      DLL.prototype.unshift = function(node3) {
        if (this.head) {
          this.insertBefore(this.head, node3);
        } else {
          this._setInitial(node3);
        }
      };
      DLL.prototype.push = function(node3) {
        var tail = this.tail;
        if (tail) {
          node3.prev = tail;
          node3.next = tail.next;
          this.tail = node3;
          tail.next = node3;
          this.length++;
        } else {
          this._setInitial(node3);
        }
      };
      DLL.prototype.shift = function() {
        return this.head && this._removeLink(this.head);
      };
      DLL.prototype.splice = function(end) {
        var task;
        var tasks = [];
        while (end-- && (task = this.shift())) {
          tasks.push(task);
        }
        return tasks;
      };
      DLL.prototype.remove = function(test) {
        var node3 = this.head;
        while (node3) {
          if (test(node3)) {
            this._removeLink(node3);
          }
          node3 = node3.next;
        }
        return this;
      };
      function baseQueue(isQueue, worker2, concurrency, payload) {
        if (concurrency === void 0) {
          concurrency = 1;
        } else if (isNaN(concurrency) || concurrency < 1) {
          throw new Error("Concurrency must not be zero");
        }
        var workers = 0;
        var workersList = [];
        var _callback, _unshift;
        var q = {
          _tasks: new DLL(),
          concurrency,
          payload,
          saturated: noop,
          unsaturated: noop,
          buffer: concurrency / 4,
          empty: noop,
          drain: noop,
          error: noop,
          started: false,
          paused: false,
          push,
          kill,
          unshift,
          remove,
          process: isQueue ? runQueue : runCargo,
          length: getLength,
          running,
          workersList: getWorkersList,
          idle,
          pause,
          resume,
          _worker: worker2
        };
        return q;
        function push(tasks, callback) {
          _insert(tasks, callback);
        }
        function unshift(tasks, callback) {
          _insert(tasks, callback, true);
        }
        function _exec(task) {
          var item = {
            data: task,
            callback: _callback
          };
          if (_unshift) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          nextTick(q.process);
        }
        function _insert(tasks, callback, unshift2) {
          if (callback == null) {
            callback = noop;
          } else if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var _tasks = isArray(tasks) ? tasks : [tasks];
          if (tasks === void 0 || !_tasks.length) {
            if (q.idle()) {
              nextTick(q.drain);
            }
            return;
          }
          _unshift = unshift2;
          _callback = callback;
          arrayEachSync(_tasks, _exec);
          _callback = void 0;
        }
        function kill() {
          q.drain = noop;
          q._tasks.empty();
        }
        function _next(q2, tasks) {
          var called = false;
          return function done(err, res) {
            if (called) {
              throwError();
            }
            called = true;
            workers--;
            var task;
            var index2 = -1;
            var size = workersList.length;
            var taskIndex = -1;
            var taskSize = tasks.length;
            var useApply = arguments.length > 2;
            var args = useApply && createArray(arguments);
            while (++taskIndex < taskSize) {
              task = tasks[taskIndex];
              while (++index2 < size) {
                if (workersList[index2] === task) {
                  if (index2 === 0) {
                    workersList.shift();
                  } else {
                    workersList.splice(index2, 1);
                  }
                  index2 = size;
                  size--;
                }
              }
              index2 = -1;
              if (useApply) {
                task.callback.apply(task, args);
              } else {
                task.callback(err, res);
              }
              if (err) {
                q2.error(err, task.data);
              }
            }
            if (workers <= q2.concurrency - q2.buffer) {
              q2.unsaturated();
            }
            if (q2._tasks.length + workers === 0) {
              q2.drain();
            }
            q2.process();
          };
        }
        function runQueue() {
          while (!q.paused && workers < q.concurrency && q._tasks.length) {
            var task = q._tasks.shift();
            workers++;
            workersList.push(task);
            if (q._tasks.length === 0) {
              q.empty();
            }
            if (workers === q.concurrency) {
              q.saturated();
            }
            var done = _next(q, [task]);
            worker2(task.data, done);
          }
        }
        function runCargo() {
          while (!q.paused && workers < q.concurrency && q._tasks.length) {
            var tasks = q._tasks.splice(q.payload || q._tasks.length);
            var index2 = -1;
            var size = tasks.length;
            var data = Array(size);
            while (++index2 < size) {
              data[index2] = tasks[index2].data;
            }
            workers++;
            nativePush.apply(workersList, tasks);
            if (q._tasks.length === 0) {
              q.empty();
            }
            if (workers === q.concurrency) {
              q.saturated();
            }
            var done = _next(q, tasks);
            worker2(data, done);
          }
        }
        function getLength() {
          return q._tasks.length;
        }
        function running() {
          return workers;
        }
        function getWorkersList() {
          return workersList;
        }
        function idle() {
          return q.length() + workers === 0;
        }
        function pause() {
          q.paused = true;
        }
        function _resume() {
          nextTick(q.process);
        }
        function resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          var count = q.concurrency < q._tasks.length ? q.concurrency : q._tasks.length;
          timesSync(count, _resume);
        }
        function remove(test) {
          q._tasks.remove(test);
        }
      }
      function queue(worker2, concurrency) {
        return baseQueue(true, worker2, concurrency);
      }
      function priorityQueue(worker2, concurrency) {
        var q = baseQueue(true, worker2, concurrency);
        q.push = push;
        delete q.unshift;
        return q;
        function push(tasks, priority, callback) {
          q.started = true;
          priority = priority || 0;
          var _tasks = isArray(tasks) ? tasks : [tasks];
          var taskSize = _tasks.length;
          if (tasks === void 0 || taskSize === 0) {
            if (q.idle()) {
              nextTick(q.drain);
            }
            return;
          }
          callback = typeof callback === func ? callback : noop;
          var nextNode = q._tasks.head;
          while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
          }
          while (taskSize--) {
            var item = {
              data: _tasks[taskSize],
              priority,
              callback
            };
            if (nextNode) {
              q._tasks.insertBefore(nextNode, item);
            } else {
              q._tasks.push(item);
            }
            nextTick(q.process);
          }
        }
      }
      function cargo(worker2, payload) {
        return baseQueue(false, worker2, 1, payload);
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency === func) {
          callback = concurrency;
          concurrency = null;
        }
        var keys = nativeKeys(tasks);
        var rest = keys.length;
        var results = {};
        if (rest === 0) {
          return callback(null, results);
        }
        var runningTasks = 0;
        var readyTasks = new DLL();
        var listeners = /* @__PURE__ */ Object.create(null);
        callback = onlyOnce(callback || noop);
        concurrency = concurrency || rest;
        baseEachSync(tasks, iterator2, keys);
        proceedQueue();
        function iterator2(task, key) {
          var _task, _taskSize;
          if (!isArray(task)) {
            _task = task;
            _taskSize = 0;
            readyTasks.push([_task, _taskSize, done]);
            return;
          }
          var dependencySize = task.length - 1;
          _task = task[dependencySize];
          _taskSize = dependencySize;
          if (dependencySize === 0) {
            readyTasks.push([_task, _taskSize, done]);
            return;
          }
          var index2 = -1;
          while (++index2 < dependencySize) {
            var dependencyName = task[index2];
            if (notInclude(keys, dependencyName)) {
              var msg = "async.auto task `" + key + "` has non-existent dependency `" + dependencyName + "` in " + task.join(", ");
              throw new Error(msg);
            }
            var taskListeners = listeners[dependencyName];
            if (!taskListeners) {
              taskListeners = listeners[dependencyName] = [];
            }
            taskListeners.push(taskListener);
          }
          function done(err, arg) {
            if (key === null) {
              throwError();
            }
            arg = arguments.length <= 2 ? arg : slice(arguments, 1);
            if (err) {
              rest = 0;
              runningTasks = 0;
              readyTasks.length = 0;
              var safeResults = objectClone(results);
              safeResults[key] = arg;
              key = null;
              var _callback = callback;
              callback = noop;
              _callback(err, safeResults);
              return;
            }
            runningTasks--;
            rest--;
            results[key] = arg;
            taskComplete(key);
            key = null;
          }
          function taskListener() {
            if (--dependencySize === 0) {
              readyTasks.push([_task, _taskSize, done]);
            }
          }
        }
        function proceedQueue() {
          if (readyTasks.length === 0 && runningTasks === 0) {
            if (rest !== 0) {
              throw new Error("async.auto task has cyclic dependencies");
            }
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency && callback !== noop) {
            runningTasks++;
            var array = readyTasks.shift();
            if (array[1] === 0) {
              array[0](array[2]);
            } else {
              array[0](results, array[2]);
            }
          }
        }
        function taskComplete(key) {
          var taskListeners = listeners[key] || [];
          arrayEachSync(taskListeners, function(task) {
            task();
          });
          proceedQueue();
        }
      }
      var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
      function parseParams(func2) {
        func2 = func2.toString().replace(STRIP_COMMENTS, "");
        func2 = func2.match(FN_ARGS)[2].replace(" ", "");
        func2 = func2 ? func2.split(FN_ARG_SPLIT) : [];
        func2 = func2.map(function(arg) {
          return arg.replace(FN_ARG, "").trim();
        });
        return func2;
      }
      function autoInject(tasks, concurrency, callback) {
        var newTasks = {};
        baseEachSync(tasks, iterator2, nativeKeys(tasks));
        auto(newTasks, concurrency, callback);
        function iterator2(task, key) {
          var params;
          var taskLength = task.length;
          if (isArray(task)) {
            if (taskLength === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            params = createArray(task);
            taskLength = params.length - 1;
            task = params[taskLength];
            if (taskLength === 0) {
              newTasks[key] = task;
              return;
            }
          } else if (taskLength === 1) {
            newTasks[key] = task;
            return;
          } else {
            params = parseParams(task);
            if (taskLength === 0 && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            taskLength = params.length - 1;
          }
          params[taskLength] = newTask;
          newTasks[key] = params;
          function newTask(results, done) {
            switch (taskLength) {
              case 1:
                task(results[params[0]], done);
                break;
              case 2:
                task(results[params[0]], results[params[1]], done);
                break;
              case 3:
                task(results[params[0]], results[params[1]], results[params[2]], done);
                break;
              default:
                var i = -1;
                while (++i < taskLength) {
                  params[i] = results[params[i]];
                }
                params[i] = done;
                task.apply(null, params);
                break;
            }
          }
        }
      }
      function retry(opts, task, callback) {
        var times2, intervalFunc, errorFilter;
        var count = 0;
        if (arguments.length < 3 && typeof opts === func) {
          callback = task || noop;
          task = opts;
          opts = null;
          times2 = DEFAULT_TIMES;
        } else {
          callback = callback || noop;
          switch (typeof opts) {
            case "object":
              if (typeof opts.errorFilter === func) {
                errorFilter = opts.errorFilter;
              }
              var interval = opts.interval;
              switch (typeof interval) {
                case func:
                  intervalFunc = interval;
                  break;
                case "string":
                case "number":
                  interval = +interval;
                  intervalFunc = interval ? function() {
                    return interval;
                  } : function() {
                    return DEFAULT_INTERVAL;
                  };
                  break;
              }
              times2 = +opts.times || DEFAULT_TIMES;
              break;
            case "number":
              times2 = opts || DEFAULT_TIMES;
              break;
            case "string":
              times2 = +opts || DEFAULT_TIMES;
              break;
            default:
              throw new Error("Invalid arguments for async.retry");
          }
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        if (intervalFunc) {
          task(intervalCallback);
        } else {
          task(simpleCallback);
        }
        function simpleIterator() {
          task(simpleCallback);
        }
        function simpleCallback(err, res) {
          if (++count === times2 || !err || errorFilter && !errorFilter(err)) {
            if (arguments.length <= 2) {
              return callback(err, res);
            }
            var args = createArray(arguments);
            return callback.apply(null, args);
          }
          simpleIterator();
        }
        function intervalIterator() {
          task(intervalCallback);
        }
        function intervalCallback(err, res) {
          if (++count === times2 || !err || errorFilter && !errorFilter(err)) {
            if (arguments.length <= 2) {
              return callback(err, res);
            }
            var args = createArray(arguments);
            return callback.apply(null, args);
          }
          setTimeout(intervalIterator, intervalFunc(count));
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        return done;
        function done() {
          var taskFn;
          var args = createArray(arguments);
          var lastIndex = args.length - 1;
          var callback = args[lastIndex];
          switch (task.length) {
            case 1:
              taskFn = task1;
              break;
            case 2:
              taskFn = task2;
              break;
            case 3:
              taskFn = task3;
              break;
            default:
              taskFn = task4;
          }
          if (opts) {
            retry(opts, taskFn, callback);
          } else {
            retry(taskFn, callback);
          }
          function task1(done2) {
            task(done2);
          }
          function task2(done2) {
            task(args[0], done2);
          }
          function task3(done2) {
            task(args[0], args[1], done2);
          }
          function task4(callback2) {
            args[lastIndex] = callback2;
            task.apply(null, args);
          }
        }
      }
      function iterator(tasks) {
        var size = 0;
        var keys = [];
        if (isArray(tasks)) {
          size = tasks.length;
        } else {
          keys = nativeKeys(tasks);
          size = keys.length;
        }
        return makeCallback(0);
        function makeCallback(index2) {
          var fn2 = function() {
            if (size) {
              var key = keys[index2] || index2;
              tasks[key].apply(null, createArray(arguments));
            }
            return fn2.next();
          };
          fn2.next = function() {
            return index2 < size - 1 ? makeCallback(index2 + 1) : null;
          };
          return fn2;
        }
      }
      function apply(func2) {
        switch (arguments.length) {
          case 0:
          case 1:
            return func2;
          case 2:
            return func2.bind(null, arguments[1]);
          case 3:
            return func2.bind(null, arguments[1], arguments[2]);
          case 4:
            return func2.bind(null, arguments[1], arguments[2], arguments[3]);
          case 5:
            return func2.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);
          default:
            var size = arguments.length;
            var index2 = 0;
            var args = Array(size);
            args[index2] = null;
            while (++index2 < size) {
              args[index2] = arguments[index2];
            }
            return func2.bind.apply(func2, args);
        }
      }
      function timeout(func2, millisec, info) {
        var callback, timer;
        return wrappedFunc;
        function wrappedFunc() {
          timer = setTimeout(timeoutCallback, millisec);
          var args = createArray(arguments);
          var lastIndex = args.length - 1;
          callback = args[lastIndex];
          args[lastIndex] = injectedCallback;
          simpleApply(func2, args);
        }
        function timeoutCallback() {
          var name2 = func2.name || "anonymous";
          var err = new Error('Callback function "' + name2 + '" timed out.');
          err.code = "ETIMEDOUT";
          if (info) {
            err.info = info;
          }
          timer = null;
          callback(err);
        }
        function injectedCallback() {
          if (timer !== null) {
            simpleApply(callback, createArray(arguments));
            clearTimeout(timer);
          }
        }
        function simpleApply(func3, args) {
          switch (args.length) {
            case 0:
              func3();
              break;
            case 1:
              func3(args[0]);
              break;
            case 2:
              func3(args[0], args[1]);
              break;
            default:
              func3.apply(null, args);
              break;
          }
        }
      }
      function times(n, iterator2, callback) {
        callback = callback || noop;
        n = +n;
        if (isNaN(n) || n < 1) {
          return callback(null, []);
        }
        var result2 = Array(n);
        timesSync(n, iterate);
        function iterate(num) {
          iterator2(num, createCallback(num));
        }
        function createCallback(index2) {
          return function(err, res) {
            if (index2 === null) {
              throwError();
            }
            result2[index2] = res;
            index2 = null;
            if (err) {
              callback(err);
              callback = noop;
            } else if (--n === 0) {
              callback(null, result2);
            }
          };
        }
      }
      function timesSeries(n, iterator2, callback) {
        callback = callback || noop;
        n = +n;
        if (isNaN(n) || n < 1) {
          return callback(null, []);
        }
        var result2 = Array(n);
        var sync = false;
        var completed = 0;
        iterate();
        function iterate() {
          iterator2(completed, done);
        }
        function done(err, res) {
          result2[completed] = res;
          if (err) {
            callback(err);
            callback = throwError;
          } else if (++completed >= n) {
            callback(null, result2);
            callback = throwError;
          } else if (sync) {
            nextTick(iterate);
          } else {
            sync = true;
            iterate();
          }
          sync = false;
        }
      }
      function timesLimit(n, limit, iterator2, callback) {
        callback = callback || noop;
        n = +n;
        if (isNaN(n) || n < 1 || isNaN(limit) || limit < 1) {
          return callback(null, []);
        }
        var result2 = Array(n);
        var sync = false;
        var started = 0;
        var completed = 0;
        timesSync(limit > n ? n : limit, iterate);
        function iterate() {
          var index2 = started++;
          if (index2 < n) {
            iterator2(index2, createCallback(index2));
          }
        }
        function createCallback(index2) {
          return function(err, res) {
            if (index2 === null) {
              throwError();
            }
            result2[index2] = res;
            index2 = null;
            if (err) {
              callback(err);
              callback = noop;
            } else if (++completed >= n) {
              callback(null, result2);
              callback = throwError;
            } else if (sync) {
              nextTick(iterate);
            } else {
              sync = true;
              iterate();
            }
            sync = false;
          };
        }
      }
      function race(tasks, callback) {
        callback = once(callback || noop);
        var size, keys;
        var index2 = -1;
        if (isArray(tasks)) {
          size = tasks.length;
          while (++index2 < size) {
            tasks[index2](callback);
          }
        } else if (tasks && typeof tasks === obj) {
          keys = nativeKeys(tasks);
          size = keys.length;
          while (++index2 < size) {
            tasks[keys[index2]](callback);
          }
        } else {
          return callback(new TypeError("First argument to race must be a collection of functions"));
        }
        if (!size) {
          callback(null);
        }
      }
      function memoize2(fn2, hasher) {
        hasher = hasher || function(hash) {
          return hash;
        };
        var memo = {};
        var queues = {};
        var memoized = function() {
          var args = createArray(arguments);
          var callback = args.pop();
          var key = hasher.apply(null, args);
          if (has(memo, key)) {
            nextTick(function() {
              callback.apply(null, memo[key]);
            });
            return;
          }
          if (has(queues, key)) {
            return queues[key].push(callback);
          }
          queues[key] = [callback];
          args.push(done);
          fn2.apply(null, args);
          function done(err) {
            var args2 = createArray(arguments);
            if (!err) {
              memo[key] = args2;
            }
            var q = queues[key];
            delete queues[key];
            var i = -1;
            var size = q.length;
            while (++i < size) {
              q[i].apply(null, args2);
            }
          }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn2;
        return memoized;
      }
      function unmemoize(fn2) {
        return function() {
          return (fn2.unmemoized || fn2).apply(null, arguments);
        };
      }
      function ensureAsync(fn2) {
        return function() {
          var args = createArray(arguments);
          var lastIndex = args.length - 1;
          var callback = args[lastIndex];
          var sync = true;
          args[lastIndex] = done;
          fn2.apply(this, args);
          sync = false;
          function done() {
            var innerArgs = createArray(arguments);
            if (sync) {
              nextTick(function() {
                callback.apply(null, innerArgs);
              });
            } else {
              callback.apply(null, innerArgs);
            }
          }
        };
      }
      function constant() {
        var args = [null].concat(createArray(arguments));
        return function(callback) {
          callback = arguments[arguments.length - 1];
          callback.apply(this, args);
        };
      }
      function asyncify(fn2) {
        return function() {
          var args = createArray(arguments);
          var callback = args.pop();
          var result2;
          try {
            result2 = fn2.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result2 && typeof result2.then === func) {
            result2.then(
              function(value) {
                invokeCallback(callback, null, value);
              },
              function(err) {
                invokeCallback(callback, err && err.message ? err : new Error(err));
              }
            );
          } else {
            callback(null, result2);
          }
        };
      }
      function invokeCallback(callback, err, value) {
        try {
          callback(err, value);
        } catch (e) {
          nextTick(rethrow, e);
        }
      }
      function rethrow(error) {
        throw error;
      }
      function reflect(func2) {
        return function() {
          var callback;
          switch (arguments.length) {
            case 1:
              callback = arguments[0];
              return func2(done);
            case 2:
              callback = arguments[1];
              return func2(arguments[0], done);
            default:
              var args = createArray(arguments);
              var lastIndex = args.length - 1;
              callback = args[lastIndex];
              args[lastIndex] = done;
              func2.apply(this, args);
          }
          function done(err, res) {
            if (err) {
              return callback(null, {
                error: err
              });
            }
            if (arguments.length > 2) {
              res = slice(arguments, 1);
            }
            callback(null, {
              value: res
            });
          }
        };
      }
      function reflectAll(tasks) {
        var newTasks, keys;
        if (isArray(tasks)) {
          newTasks = Array(tasks.length);
          arrayEachSync(tasks, iterate);
        } else if (tasks && typeof tasks === obj) {
          keys = nativeKeys(tasks);
          newTasks = {};
          baseEachSync(tasks, iterate, keys);
        }
        return newTasks;
        function iterate(func2, key) {
          newTasks[key] = reflect(func2);
        }
      }
      function createLogger(name2) {
        return function(fn2) {
          var args = slice(arguments, 1);
          args.push(done);
          fn2.apply(null, args);
        };
        function done(err) {
          if (typeof console === obj) {
            if (err) {
              if (console.error) {
                console.error(err);
              }
              return;
            }
            if (console[name2]) {
              var args = slice(arguments, 1);
              arrayEachSync(args, function(arg) {
                console[name2](arg);
              });
            }
          }
        }
      }
      function safe() {
        createImmediate();
        return exports3;
      }
      function fast() {
        createImmediate(false);
        return exports3;
      }
    });
  }
});

// ../../node_modules/.pnpm/json-parse-even-better-errors@3.0.1/node_modules/json-parse-even-better-errors/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/json-parse-even-better-errors@3.0.1/node_modules/json-parse-even-better-errors/lib/index.js"(exports2, module2) {
    "use strict";
    var INDENT = Symbol.for("indent");
    var NEWLINE = Symbol.for("newline");
    var DEFAULT_NEWLINE = "\n";
    var DEFAULT_INDENT = "  ";
    var BOM = /^\uFEFF/;
    var FORMAT = /^\s*[{[]((?:\r?\n)+)([\s\t]*)/;
    var EMPTY = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i;
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return `0x${h.length % 2 ? "0" : ""}${h}`;
    };
    var stripBOM = (txt) => String(txt).replace(BOM, "");
    var makeParsedError = (msg, parsing, position = 0) => ({
      message: `${msg} while parsing ${parsing}`,
      position
    });
    var parseError = (e, txt, context2 = 20) => {
      let msg = e.message;
      if (!txt) {
        return makeParsedError(msg, "empty string");
      }
      const badTokenMatch = msg.match(UNEXPECTED_TOKEN);
      const badIndexMatch = msg.match(/ position\s+(\d+)/i);
      if (badTokenMatch) {
        msg = msg.replace(
          UNEXPECTED_TOKEN,
          `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `
        );
      }
      let errIdx;
      if (badIndexMatch) {
        errIdx = +badIndexMatch[1];
      } else if (msg.match(/^Unexpected end of JSON.*/i)) {
        errIdx = txt.length - 1;
      }
      if (errIdx == null) {
        return makeParsedError(msg, `'${txt.slice(0, context2 * 2)}'`);
      }
      const start = errIdx <= context2 ? 0 : errIdx - context2;
      const end = errIdx + context2 >= txt.length ? txt.length : errIdx + context2;
      const slice = `${start ? "..." : ""}${txt.slice(start, end)}${end === txt.length ? "" : "..."}`;
      return makeParsedError(
        msg,
        `${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
        errIdx
      );
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context2, caller) {
        const metadata = parseError(er, txt, context2);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var parseJson = (txt, reviver) => {
      const result2 = JSON.parse(txt, reviver);
      if (result2 && typeof result2 === "object") {
        const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, "", ""];
        result2[NEWLINE] = match[1] ?? DEFAULT_NEWLINE;
        result2[INDENT] = match[2] ?? DEFAULT_INDENT;
      }
      return result2;
    };
    var parseJsonError = (raw, reviver, context2) => {
      const txt = stripBOM(raw);
      try {
        return parseJson(txt, reviver);
      } catch (e) {
        if (typeof raw !== "string" && !Buffer.isBuffer(raw)) {
          const msg = Array.isArray(raw) && raw.length === 0 ? "an empty array" : String(raw);
          throw Object.assign(
            new TypeError(`Cannot parse ${msg}`),
            { code: "EJSONPARSE", systemError: e }
          );
        }
        throw new JSONParseError(e, txt, context2, parseJsonError);
      }
    };
    module2.exports = parseJsonError;
    parseJsonError.JSONParseError = JSONParseError;
    parseJsonError.noExceptions = (raw, reviver) => {
      try {
        return parseJson(stripBOM(raw), reviver);
      } catch {
      }
    };
  }
});

// ../../node_modules/.pnpm/enhanced-resolve@5.12.0/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js
var require_CachedInputFileSystem = __commonJS({
  "../../node_modules/.pnpm/enhanced-resolve@5.12.0/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"(exports2, module2) {
    "use strict";
    var nextTick = require("process").nextTick;
    var dirname4 = (path10) => {
      let idx = path10.length - 1;
      while (idx >= 0) {
        const c = path10.charCodeAt(idx);
        if (c === 47 || c === 92) break;
        idx--;
      }
      if (idx < 0) return "";
      return path10.slice(0, idx);
    };
    var runCallbacks = (callbacks, err, result2) => {
      if (callbacks.length === 1) {
        callbacks[0](err, result2);
        callbacks.length = 0;
        return;
      }
      let error;
      for (const callback of callbacks) {
        try {
          callback(err, result2);
        } catch (e) {
          if (!error) error = e;
        }
      }
      callbacks.length = 0;
      if (error) throw error;
    };
    var OperationMergerBackend = class {
      /**
       * @param {any} provider async method
       * @param {any} syncProvider sync method
       * @param {any} providerContext call context for the provider methods
       */
      constructor(provider, syncProvider, providerContext) {
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = /* @__PURE__ */ new Map();
        this.provide = this._provider ? (path10, options, callback) => {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
          if (options) {
            return this._provider.call(
              this._providerContext,
              path10,
              options,
              callback
            );
          }
          if (typeof path10 !== "string") {
            callback(new TypeError("path must be a string"));
            return;
          }
          let callbacks = this._activeAsyncOperations.get(path10);
          if (callbacks) {
            callbacks.push(callback);
            return;
          }
          this._activeAsyncOperations.set(path10, callbacks = [callback]);
          provider(path10, (err, result2) => {
            this._activeAsyncOperations.delete(path10);
            runCallbacks(callbacks, err, result2);
          });
        } : null;
        this.provideSync = this._syncProvider ? (path10, options) => {
          return this._syncProvider.call(this._providerContext, path10, options);
        } : null;
      }
      purge() {
      }
      purgeParent() {
      }
    };
    var STORAGE_MODE_IDLE = 0;
    var STORAGE_MODE_SYNC = 1;
    var STORAGE_MODE_ASYNC = 2;
    var CacheBackend = class {
      /**
       * @param {number} duration max cache duration of items
       * @param {any} provider async method
       * @param {any} syncProvider sync method
       * @param {any} providerContext call context for the provider methods
       */
      constructor(duration, provider, syncProvider, providerContext) {
        this._duration = duration;
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = /* @__PURE__ */ new Map();
        this._data = /* @__PURE__ */ new Map();
        this._levels = [];
        for (let i = 0; i < 10; i++) this._levels.push(/* @__PURE__ */ new Set());
        for (let i = 5e3; i < duration; i += 500) this._levels.push(/* @__PURE__ */ new Set());
        this._currentLevel = 0;
        this._tickInterval = Math.floor(duration / this._levels.length);
        this._mode = STORAGE_MODE_IDLE;
        this._timeout = void 0;
        this._nextDecay = void 0;
        this.provide = provider ? this.provide.bind(this) : null;
        this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
      }
      provide(path10, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof path10 !== "string") {
          callback(new TypeError("path must be a string"));
          return;
        }
        if (options) {
          return this._provider.call(
            this._providerContext,
            path10,
            options,
            callback
          );
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._enterAsyncMode();
        }
        let cacheEntry = this._data.get(path10);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err) return nextTick(callback, cacheEntry.err);
          return nextTick(callback, null, cacheEntry.result);
        }
        let callbacks = this._activeAsyncOperations.get(path10);
        if (callbacks !== void 0) {
          callbacks.push(callback);
          return;
        }
        this._activeAsyncOperations.set(path10, callbacks = [callback]);
        this._provider.call(this._providerContext, path10, (err, result2) => {
          this._activeAsyncOperations.delete(path10);
          this._storeResult(path10, err, result2);
          this._enterAsyncMode();
          runCallbacks(callbacks, err, result2);
        });
      }
      provideSync(path10, options) {
        if (typeof path10 !== "string") {
          throw new TypeError("path must be a string");
        }
        if (options) {
          return this._syncProvider.call(this._providerContext, path10, options);
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._runDecays();
        }
        let cacheEntry = this._data.get(path10);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err) throw cacheEntry.err;
          return cacheEntry.result;
        }
        const callbacks = this._activeAsyncOperations.get(path10);
        this._activeAsyncOperations.delete(path10);
        let result2;
        try {
          result2 = this._syncProvider.call(this._providerContext, path10);
        } catch (err) {
          this._storeResult(path10, err, void 0);
          this._enterSyncModeWhenIdle();
          if (callbacks) runCallbacks(callbacks, err, void 0);
          throw err;
        }
        this._storeResult(path10, void 0, result2);
        this._enterSyncModeWhenIdle();
        if (callbacks) runCallbacks(callbacks, void 0, result2);
        return result2;
      }
      purge(what) {
        if (!what) {
          if (this._mode !== STORAGE_MODE_IDLE) {
            this._data.clear();
            for (const level of this._levels) {
              level.clear();
            }
            this._enterIdleMode();
          }
        } else if (typeof what === "string") {
          for (let [key, data] of this._data) {
            if (key.startsWith(what)) {
              this._data.delete(key);
              data.level.delete(key);
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        } else {
          for (let [key, data] of this._data) {
            for (const item of what) {
              if (key.startsWith(item)) {
                this._data.delete(key);
                data.level.delete(key);
                break;
              }
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        }
      }
      purgeParent(what) {
        if (!what) {
          this.purge();
        } else if (typeof what === "string") {
          this.purge(dirname4(what));
        } else {
          const set = /* @__PURE__ */ new Set();
          for (const item of what) {
            set.add(dirname4(item));
          }
          this.purge(set);
        }
      }
      _storeResult(path10, err, result2) {
        if (this._data.has(path10)) return;
        const level = this._levels[this._currentLevel];
        this._data.set(path10, { err, result: result2, level });
        level.add(path10);
      }
      _decayLevel() {
        const nextLevel = (this._currentLevel + 1) % this._levels.length;
        const decay = this._levels[nextLevel];
        this._currentLevel = nextLevel;
        for (let item of decay) {
          this._data.delete(item);
        }
        decay.clear();
        if (this._data.size === 0) {
          this._enterIdleMode();
        } else {
          this._nextDecay += this._tickInterval;
        }
      }
      _runDecays() {
        while (
          /** @type {number} */
          this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE
        ) {
          this._decayLevel();
        }
      }
      _enterAsyncMode() {
        let timeout = 0;
        switch (this._mode) {
          case STORAGE_MODE_ASYNC:
            return;
          case STORAGE_MODE_IDLE:
            this._nextDecay = Date.now() + this._tickInterval;
            timeout = this._tickInterval;
            break;
          case STORAGE_MODE_SYNC:
            this._runDecays();
            if (this._mode === STORAGE_MODE_IDLE) return;
            timeout = Math.max(
              0,
              /** @type {number} */
              this._nextDecay - Date.now()
            );
            break;
        }
        this._mode = STORAGE_MODE_ASYNC;
        const ref = setTimeout(() => {
          this._mode = STORAGE_MODE_SYNC;
          this._runDecays();
        }, timeout);
        if (ref.unref) ref.unref();
        this._timeout = ref;
      }
      _enterSyncModeWhenIdle() {
        if (this._mode === STORAGE_MODE_IDLE) {
          this._mode = STORAGE_MODE_SYNC;
          this._nextDecay = Date.now() + this._tickInterval;
        }
      }
      _enterIdleMode() {
        this._mode = STORAGE_MODE_IDLE;
        this._nextDecay = void 0;
        if (this._timeout) clearTimeout(this._timeout);
      }
    };
    var createBackend = (duration, provider, syncProvider, providerContext) => {
      if (duration > 0) {
        return new CacheBackend(duration, provider, syncProvider, providerContext);
      }
      return new OperationMergerBackend(provider, syncProvider, providerContext);
    };
    module2.exports = class CachedInputFileSystem {
      constructor(fileSystem, duration) {
        this.fileSystem = fileSystem;
        this._lstatBackend = createBackend(
          duration,
          this.fileSystem.lstat,
          this.fileSystem.lstatSync,
          this.fileSystem
        );
        const lstat = this._lstatBackend.provide;
        this.lstat = /** @type {FileSystem["lstat"]} */
        lstat;
        const lstatSync = this._lstatBackend.provideSync;
        this.lstatSync = /** @type {SyncFileSystem["lstatSync"]} */
        lstatSync;
        this._statBackend = createBackend(
          duration,
          this.fileSystem.stat,
          this.fileSystem.statSync,
          this.fileSystem
        );
        const stat = this._statBackend.provide;
        this.stat = /** @type {FileSystem["stat"]} */
        stat;
        const statSync = this._statBackend.provideSync;
        this.statSync = /** @type {SyncFileSystem["statSync"]} */
        statSync;
        this._readdirBackend = createBackend(
          duration,
          this.fileSystem.readdir,
          this.fileSystem.readdirSync,
          this.fileSystem
        );
        const readdir = this._readdirBackend.provide;
        this.readdir = /** @type {FileSystem["readdir"]} */
        readdir;
        const readdirSync2 = this._readdirBackend.provideSync;
        this.readdirSync = /** @type {SyncFileSystem["readdirSync"]} */
        readdirSync2;
        this._readFileBackend = createBackend(
          duration,
          this.fileSystem.readFile,
          this.fileSystem.readFileSync,
          this.fileSystem
        );
        const readFile = this._readFileBackend.provide;
        this.readFile = /** @type {FileSystem["readFile"]} */
        readFile;
        const readFileSync2 = this._readFileBackend.provideSync;
        this.readFileSync = /** @type {SyncFileSystem["readFileSync"]} */
        readFileSync2;
        this._readJsonBackend = createBackend(
          duration,
          this.fileSystem.readJson || this.readFile && ((path10, callback) => {
            this.readFile(path10, (err, buffer) => {
              if (err) return callback(err);
              if (!buffer || buffer.length === 0)
                return callback(new Error("No file content"));
              let data;
              try {
                data = JSON.parse(buffer.toString("utf-8"));
              } catch (e) {
                return callback(e);
              }
              callback(null, data);
            });
          }),
          this.fileSystem.readJsonSync || this.readFileSync && ((path10) => {
            const buffer = this.readFileSync(path10);
            const data = JSON.parse(buffer.toString("utf-8"));
            return data;
          }),
          this.fileSystem
        );
        const readJson = this._readJsonBackend.provide;
        this.readJson = /** @type {FileSystem["readJson"]} */
        readJson;
        const readJsonSync = this._readJsonBackend.provideSync;
        this.readJsonSync = /** @type {SyncFileSystem["readJsonSync"]} */
        readJsonSync;
        this._readlinkBackend = createBackend(
          duration,
          this.fileSystem.readlink,
          this.fileSystem.readlinkSync,
          this.fileSystem
        );
        const readlink = this._readlinkBackend.provide;
        this.readlink = /** @type {FileSystem["readlink"]} */
        readlink;
        const readlinkSync = this._readlinkBackend.provideSync;
        this.readlinkSync = /** @type {SyncFileSystem["readlinkSync"]} */
        readlinkSync;
      }
      purge(what) {
        this._statBackend.purge(what);
        this._lstatBackend.purge(what);
        this._readdirBackend.purgeParent(what);
        this._readFileBackend.purge(what);
        this._readlinkBackend.purge(what);
        this._readJsonBackend.purge(what);
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BannerPlugin: () => BannerPlugin,
  Compilation: () => Compilation,
  Compiler: () => Compiler,
  ContextReplacementPlugin: () => ContextReplacementPlugin,
  CopyRspackPlugin: () => CopyRspackPlugin,
  CssExtractRspackPlugin: () => CssExtractRspackPlugin,
  DefinePlugin: () => DefinePlugin,
  DynamicEntryPlugin: () => DynamicEntryPlugin,
  EntryOptionPlugin: () => EntryOptionPlugin_default,
  EntryPlugin: () => EntryPlugin,
  EnvironmentPlugin: () => EnvironmentPlugin,
  EvalDevToolModulePlugin: () => EvalDevToolModulePlugin,
  EvalSourceMapDevToolPlugin: () => EvalSourceMapDevToolPlugin,
  ExternalsPlugin: () => ExternalsPlugin,
  HotModuleReplacementPlugin: () => HotModuleReplacementPlugin,
  HtmlRspackPlugin: () => HtmlRspackPlugin,
  IgnorePlugin: () => IgnorePlugin,
  LightningCssMinimizerRspackPlugin: () => LightningCssMinimizerRspackPlugin,
  LoaderOptionsPlugin: () => LoaderOptionsPlugin,
  LoaderTargetPlugin: () => LoaderTargetPlugin,
  ModuleFilenameHelpers: () => ModuleFilenameHelpers_exports,
  MultiCompiler: () => MultiCompiler,
  MultiStats: () => MultiStats,
  NoEmitOnErrorsPlugin: () => NoEmitOnErrorsPlugin,
  NormalModule: () => NormalModule,
  NormalModuleReplacementPlugin: () => NormalModuleReplacementPlugin,
  ProgressPlugin: () => ProgressPlugin,
  ProvidePlugin: () => ProvidePlugin,
  RspackOptionsApply: () => RspackOptionsApply,
  RuntimeGlobals: () => RuntimeGlobals,
  RuntimeModule: () => RuntimeModule,
  SourceMapDevToolPlugin: () => SourceMapDevToolPlugin,
  Stats: () => Stats,
  SwcJsMinimizerRspackPlugin: () => SwcJsMinimizerRspackPlugin,
  Template: () => Template,
  ValidationError: () => ValidationError2,
  WebpackError: () => WebpackError2,
  WebpackOptionsApply: () => RspackOptionsApply,
  config: () => config,
  container: () => container,
  electron: () => electron,
  experiments: () => experiments2,
  javascript: () => javascript,
  library: () => library2,
  node: () => node2,
  optimize: () => optimize,
  rspack: () => rspack,
  rspackVersion: () => rspackVersion,
  sharing: () => sharing,
  sources: () => sources,
  util: () => util6,
  version: () => version,
  wasm: () => wasm,
  web: () => web,
  webworker: () => webworker
});
module.exports = __toCommonJS(src_exports);

// src/exports.ts
var exports_exports = {};
__export(exports_exports, {
  BannerPlugin: () => BannerPlugin,
  Compilation: () => Compilation,
  Compiler: () => Compiler,
  ContextReplacementPlugin: () => ContextReplacementPlugin,
  CopyRspackPlugin: () => CopyRspackPlugin,
  CssExtractRspackPlugin: () => CssExtractRspackPlugin,
  DefinePlugin: () => DefinePlugin,
  DynamicEntryPlugin: () => DynamicEntryPlugin,
  EntryOptionPlugin: () => EntryOptionPlugin_default,
  EntryPlugin: () => EntryPlugin,
  EnvironmentPlugin: () => EnvironmentPlugin,
  EvalDevToolModulePlugin: () => EvalDevToolModulePlugin,
  EvalSourceMapDevToolPlugin: () => EvalSourceMapDevToolPlugin,
  ExternalsPlugin: () => ExternalsPlugin,
  HotModuleReplacementPlugin: () => HotModuleReplacementPlugin,
  HtmlRspackPlugin: () => HtmlRspackPlugin,
  IgnorePlugin: () => IgnorePlugin,
  LightningCssMinimizerRspackPlugin: () => LightningCssMinimizerRspackPlugin,
  LoaderOptionsPlugin: () => LoaderOptionsPlugin,
  LoaderTargetPlugin: () => LoaderTargetPlugin,
  ModuleFilenameHelpers: () => ModuleFilenameHelpers_exports,
  MultiCompiler: () => MultiCompiler,
  MultiStats: () => MultiStats,
  NoEmitOnErrorsPlugin: () => NoEmitOnErrorsPlugin,
  NormalModule: () => NormalModule,
  NormalModuleReplacementPlugin: () => NormalModuleReplacementPlugin,
  ProgressPlugin: () => ProgressPlugin,
  ProvidePlugin: () => ProvidePlugin,
  RspackOptionsApply: () => RspackOptionsApply,
  RuntimeGlobals: () => RuntimeGlobals,
  RuntimeModule: () => RuntimeModule,
  SourceMapDevToolPlugin: () => SourceMapDevToolPlugin,
  Stats: () => Stats,
  SwcJsMinimizerRspackPlugin: () => SwcJsMinimizerRspackPlugin,
  Template: () => Template,
  ValidationError: () => ValidationError2,
  WebpackError: () => WebpackError2,
  WebpackOptionsApply: () => RspackOptionsApply,
  config: () => config,
  container: () => container,
  electron: () => electron,
  experiments: () => experiments2,
  javascript: () => javascript,
  library: () => library2,
  node: () => node2,
  optimize: () => optimize,
  rspackVersion: () => rspackVersion,
  sharing: () => sharing,
  sources: () => sources,
  util: () => util6,
  version: () => version,
  wasm: () => wasm,
  web: () => web,
  webworker: () => webworker
});
var import_package = __toESM(require_package());

// src/Compilation.ts
var import_binding6 = require("@rspack/binding");
var liteTapable = __toESM(require("@rspack/lite-tapable"));

// src/Chunk.ts
var import_binding2 = require("@rspack/binding");

// src/ChunkGroup.ts
var import_binding = require("@rspack/binding");
var ChunkGroup = class _ChunkGroup {
  #inner;
  #innerCompilation;
  static __from_binding(chunk, compilation) {
    return new _ChunkGroup(chunk, compilation);
  }
  constructor(inner, compilation) {
    this.#inner = inner;
    this.#innerCompilation = compilation;
  }
  getFiles() {
    const files = /* @__PURE__ */ new Set();
    for (const chunk of this.#inner.chunks) {
      for (const file of chunk.files) {
        files.add(file);
      }
    }
    return Array.from(files);
  }
  getParents() {
    return this.#inner.__inner_parents.map((parent) => {
      const cg = (0, import_binding.__chunk_group_inner_get_chunk_group)(
        parent,
        this.#innerCompilation
      );
      return _ChunkGroup.__from_binding(cg, this.#innerCompilation);
    });
  }
  isInitial() {
    return this.#inner.isInitial;
  }
  get chunks() {
    return this.#inner.chunks.map(
      (c) => Chunk.__from_binding(c, this.#innerCompilation)
    );
  }
  get index() {
    return this.#inner.index;
  }
  get name() {
    return this.#inner.name;
  }
  get origins() {
    return this.#inner.origins;
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__innerUkey() {
    return this.#inner.__inner_ukey;
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__innerCompilation() {
    return this.#innerCompilation;
  }
};

// src/util/comparators.ts
var TwoKeyWeakMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
  }
  get(key1, key2) {
    const childMap = this._map.get(key1);
    if (childMap === void 0) {
      return void 0;
    }
    return childMap.get(key2);
  }
  set(key1, key2, value) {
    let childMap = this._map.get(key1);
    if (childMap === void 0) {
      childMap = /* @__PURE__ */ new WeakMap();
      this._map.set(key1, childMap);
    }
    childMap.set(key2, value);
  }
};
var concatComparatorsCache = new TwoKeyWeakMap();
var concatComparators = (...comps) => {
  const [c1, c2, ...cRest] = comps;
  if (c2 === void 0) {
    return c1;
  }
  if (cRest.length > 0) {
    const [c3, ...cRest2] = cRest;
    return concatComparators(c1, concatComparators(c2, c3, ...cRest2));
  }
  const cacheEntry = concatComparatorsCache.get(c1, c2);
  if (cacheEntry !== void 0) return cacheEntry;
  const result2 = (a, b) => {
    const res = c1(a, b);
    if (res !== 0) return res;
    return c2(a, b);
  };
  concatComparatorsCache.set(c1, c2, result2);
  return result2;
};
var compareIds = (a, b) => {
  if (typeof a !== typeof b) {
    return typeof a < typeof b ? -1 : 1;
  }
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
};
var compareChunkGroupsByIndex = (a, b) => {
  return a.index < b.index ? -1 : 1;
};
var compareSelectCache = new TwoKeyWeakMap();
var compareSelect = (getter2, comparator) => {
  const cacheEntry = compareSelectCache.get(getter2, comparator);
  if (cacheEntry !== void 0) return cacheEntry;
  const result2 = (a, b) => {
    const aValue = getter2(a);
    const bValue = getter2(b);
    if (aValue !== void 0 && aValue !== null) {
      if (bValue !== void 0 && bValue !== null) {
        return comparator(aValue, bValue);
      }
      return -1;
    }
    if (bValue !== void 0 && bValue !== null) {
      return 1;
    }
    return 0;
  };
  compareSelectCache.set(getter2, comparator, result2);
  return result2;
};
var compareNumbers = (a, b) => {
  if (typeof a !== typeof b) {
    return typeof a < typeof b ? -1 : 1;
  }
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
};

// src/Chunk.ts
var Chunk = class _Chunk {
  #inner;
  #innerCompilation;
  static __from_binding(chunk, compilation) {
    if (compilation instanceof Compilation) {
      return new _Chunk(chunk, compilation.__internal_getInner());
    }
    return new _Chunk(chunk, compilation);
  }
  constructor(chunk, compilation) {
    this.#inner = chunk;
    this.#innerCompilation = compilation;
    this.name = chunk.name;
    this.id = chunk.id;
    this.ids = chunk.ids;
    this.idNameHints = chunk.idNameHints;
    this.filenameTemplate = chunk.filenameTemplate;
    this.cssFilenameTemplate = chunk.cssFilenameTemplate;
    this.files = new Set(chunk.files);
    this.runtime = new Set(chunk.runtime);
    this.hash = chunk.hash;
    this.contentHash = chunk.contentHash;
    this.renderedHash = chunk.renderedHash;
    this.chunkReason = chunk.chunkReason;
    this.auxiliaryFiles = new Set(chunk.auxiliaryFiles);
  }
  isOnlyInitial() {
    return (0, import_binding2.__chunk_inner_is_only_initial)(
      this.#inner.__inner_ukey,
      this.#innerCompilation
    );
  }
  canBeInitial() {
    return (0, import_binding2.__chunk_inner_can_be_initial)(
      this.#inner.__inner_ukey,
      this.#innerCompilation
    );
  }
  hasRuntime() {
    return (0, import_binding2.__chunk_inner_has_runtime)(
      this.#inner.__inner_ukey,
      this.#innerCompilation
    );
  }
  get groupsIterable() {
    const chunk_groups = this.#inner.__inner_groups.map((ukey) => {
      const cg = (0, import_binding2.__chunk_group_inner_get_chunk_group)(
        ukey,
        this.#innerCompilation
      );
      return ChunkGroup.__from_binding(cg, this.#innerCompilation);
    });
    chunk_groups.sort(compareChunkGroupsByIndex);
    return new Set(chunk_groups);
  }
  getChunkMaps(realHash) {
    const chunkHashMap = {};
    const chunkContentHashMap = {};
    const chunkNameMap = {};
    for (const chunk of this.getAllAsyncChunks()) {
      const id = chunk.id;
      if (!id) continue;
      const chunkHash = realHash ? chunk.hash : chunk.renderedHash;
      if (chunkHash) {
        chunkHashMap[id] = chunkHash;
      }
      for (const key of Object.keys(chunk.contentHash)) {
        if (!chunkContentHashMap[key]) {
          chunkContentHashMap[key] = {};
        }
        chunkContentHashMap[key][id] = chunk.contentHash[key];
      }
      if (chunk.name) {
        chunkNameMap[id] = chunk.name;
      }
    }
    return {
      hash: chunkHashMap,
      contentHash: chunkContentHashMap,
      name: chunkNameMap
    };
  }
  getAllAsyncChunks() {
    return new Set(
      (0, import_binding2.__chunk_inner_get_all_async_chunks)(
        this.#inner.__inner_ukey,
        this.#innerCompilation
      ).map((c) => _Chunk.__from_binding(c, this.#innerCompilation))
    );
  }
  getAllInitialChunks() {
    return new Set(
      (0, import_binding2.__chunk_inner_get_all_initial_chunks)(
        this.#inner.__inner_ukey,
        this.#innerCompilation
      ).map((c) => _Chunk.__from_binding(c, this.#innerCompilation))
    );
  }
  getAllReferencedChunks() {
    return new Set(
      (0, import_binding2.__chunk_inner_get_all_referenced_chunks)(
        this.#inner.__inner_ukey,
        this.#innerCompilation
      ).map((c) => _Chunk.__from_binding(c, this.#innerCompilation))
    );
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__innerUkey() {
    return this.#inner.__inner_ukey;
  }
  __internal_to_path_data_chunk() {
    return {
      id: this.id,
      name: this.name,
      hash: this.hash,
      contentHash: this.contentHash
    };
  }
};

// src/ChunkGraph.ts
var import_binding4 = require("@rspack/binding");

// src/Dependency.ts
var import_binding3 = require("@rspack/binding");
var Dependency = class _Dependency {
  static __from_binding(binding3) {
    return new _Dependency(binding3);
  }
  constructor(binding3) {
    Object.defineProperties(this, {
      type: {
        enumerable: true,
        get() {
          return binding3.type;
        }
      },
      category: {
        enumerable: true,
        get() {
          return binding3.category;
        }
      },
      request: {
        enumerable: true,
        get() {
          return binding3.request;
        }
      },
      critical: {
        enumerable: true,
        get() {
          return binding3.critical;
        },
        set(val) {
          if (binding3 instanceof import_binding3.JsDependencyMut) {
            binding3.critical = val;
          }
        }
      }
    });
  }
};

// src/DependenciesBlock.ts
var DependenciesBlock = class _DependenciesBlock {
  #binding;
  constructor(binding3) {
    this.#binding = binding3;
  }
  get dependencies() {
    return this.#binding.dependencies.map((d) => Dependency.__from_binding(d));
  }
  get blocks() {
    return this.#binding.blocks.map((b) => new _DependenciesBlock(b));
  }
};

// src/util/source.ts
var import_webpack_sources = require("../compiled/webpack-sources/index.js");
var JsSource = class extends import_webpack_sources.Source {
  static __from_binding(source) {
    if (source.source instanceof Buffer) {
      return new import_webpack_sources.RawSource(source.source);
    }
    if (!source.map) {
      return new import_webpack_sources.RawSource(source.source);
    }
    return new import_webpack_sources.SourceMapSource(
      source.source,
      "inmemory://from rust",
      // @ts-expect-error: SourceMapSource can accept string as source map,
      // see: https://github.com/webpack/webpack-sources/blob/9f98066311d53a153fdc7c633422a1d086528027/lib/SourceMapSource.js#L30
      source.map
    );
  }
  static __to_binding(source) {
    var _a;
    if (source instanceof import_webpack_sources.RawSource) {
      if (source.isBuffer()) {
        return {
          source: source.buffer()
        };
      }
      return {
        source: source.source()
      };
    }
    const map = JSON.stringify(
      (_a = source.map) == null ? void 0 : _a.call(source, {
        columns: true
      })
    );
    const code = source.source();
    return {
      source: typeof code === "string" ? code : Buffer.from(code).toString("utf-8"),
      map
    };
  }
};

// src/Module.ts
var ContextModuleFactoryBeforeResolveData = class _ContextModuleFactoryBeforeResolveData {
  #inner;
  static __from_binding(binding3) {
    return new _ContextModuleFactoryBeforeResolveData(binding3);
  }
  static __to_binding(data) {
    return data.#inner;
  }
  constructor(binding3) {
    this.#inner = binding3;
    Object.defineProperties(this, {
      context: {
        enumerable: true,
        get() {
          return binding3.context;
        },
        set(val) {
          binding3.context = val;
        }
      },
      request: {
        enumerable: true,
        get() {
          return binding3.request;
        },
        set(val) {
          binding3.request = val;
        }
      },
      regExp: {
        enumerable: true,
        get() {
          if (!binding3.regExp) {
            return void 0;
          }
          const { source, flags } = binding3.regExp;
          return new RegExp(source, flags);
        },
        set(val) {
          if (!val) {
            binding3.regExp = void 0;
            return;
          }
          binding3.regExp = {
            source: val.source,
            flags: val.flags
          };
        }
      },
      recursive: {
        enumerable: true,
        get() {
          return binding3.recursive;
        },
        set(val) {
          binding3.recursive = val;
        }
      }
    });
  }
};
var ContextModuleFactoryAfterResolveData = class _ContextModuleFactoryAfterResolveData {
  #inner;
  static __from_binding(binding3) {
    return new _ContextModuleFactoryAfterResolveData(binding3);
  }
  static __to_binding(data) {
    return data.#inner;
  }
  constructor(binding3) {
    this.#inner = binding3;
    Object.defineProperties(this, {
      resource: {
        enumerable: true,
        get() {
          return binding3.resource;
        },
        set(val) {
          binding3.resource = val;
        }
      },
      context: {
        enumerable: true,
        get() {
          return binding3.context;
        },
        set(val) {
          binding3.context = val;
        }
      },
      request: {
        enumerable: true,
        get() {
          return binding3.request;
        },
        set(val) {
          binding3.request = val;
        }
      },
      regExp: {
        enumerable: true,
        get() {
          if (!binding3.regExp) {
            return void 0;
          }
          const { source, flags } = binding3.regExp;
          return new RegExp(source, flags);
        },
        set(val) {
          if (!val) {
            binding3.regExp = void 0;
            return;
          }
          binding3.regExp = {
            source: val.source,
            flags: val.flags
          };
        }
      },
      recursive: {
        enumerable: true,
        get() {
          return binding3.recursive;
        },
        set(val) {
          binding3.recursive = val;
        }
      },
      dependencies: {
        enumerable: true,
        get() {
          return binding3.dependencies.map(
            (dep) => Dependency.__from_binding(dep)
          );
        }
      }
    });
  }
};
var Module = class _Module {
  #inner;
  #originalSource;
  static __from_binding(module2, compilation) {
    return new _Module(module2, compilation);
  }
  constructor(module2, compilation) {
    this.#inner = module2;
    this.type = module2.type;
    this.layer = module2.layer ?? null;
    this.context = module2.context;
    this.resource = module2.resource;
    this.request = module2.request;
    this.userRequest = module2.userRequest;
    this.rawRequest = module2.rawRequest;
    this.factoryMeta = module2.factoryMeta;
    const customModule = compilation == null ? void 0 : compilation.__internal__getCustomModule(
      module2.moduleIdentifier
    );
    this.buildInfo = (customModule == null ? void 0 : customModule.buildInfo) || {};
    this.buildMeta = (customModule == null ? void 0 : customModule.buildMeta) || {};
  }
  originalSource() {
    if (this.#originalSource) return this.#originalSource;
    if (this.#inner.originalSource) {
      this.#originalSource = JsSource.__from_binding(
        this.#inner.originalSource
      );
      return this.#originalSource;
    }
    return null;
  }
  identifier() {
    return this.#inner.moduleIdentifier;
  }
  nameForCondition() {
    if (typeof this.#inner.nameForCondition === "string") {
      return this.#inner.nameForCondition;
    }
    return null;
  }
  get blocks() {
    if ("blocks" in this.#inner) {
      return this.#inner.blocks.map((b) => new DependenciesBlock(b));
    }
    return [];
  }
  size(type) {
    if ("size" in this.#inner) {
      return this.#inner.size(type);
    }
    return 0;
  }
};
var CodeGenerationResult = class {
  #inner;
  constructor(result2) {
    this.#inner = result2;
  }
  get(sourceType) {
    return this.#inner.sources[sourceType];
  }
};

// src/ChunkGraph.ts
var ChunkGraph = class {
  constructor(compilation) {
    this.compilation = compilation;
  }
  getChunkModules(chunk) {
    return (0, import_binding4.__chunk_graph_inner_get_chunk_modules)(
      chunk.__internal__innerUkey(),
      this.compilation.__internal_getInner()
    ).map((m) => Module.__from_binding(m, this.compilation));
  }
  getChunkModulesIterable(chunk) {
    return new Set(
      (0, import_binding4.__chunk_graph_inner_get_chunk_modules)(
        chunk.__internal__innerUkey(),
        this.compilation.__internal_getInner()
      ).map((m) => Module.__from_binding(m, this.compilation))
    );
  }
  getChunkEntryModulesIterable(chunk) {
    return new Set(
      (0, import_binding4.__chunk_graph_inner_get_chunk_entry_modules)(
        chunk.__internal__innerUkey(),
        this.compilation.__internal_getInner()
      ).map((m) => Module.__from_binding(m, this.compilation))
    );
  }
  getChunkEntryDependentChunksIterable(chunk) {
    return new Set(
      (0, import_binding4.__chunk_graph_inner_get_chunk_entry_dependent_chunks_iterable)(
        chunk.__internal__innerUkey(),
        this.compilation.__internal_getInner()
      ).map(
        (c) => Chunk.__from_binding(c, this.compilation.__internal_getInner())
      )
    );
  }
  getChunkModulesIterableBySourceType(chunk, sourceType) {
    return new Set(
      (0, import_binding4.__chunk_graph_inner_get_chunk_modules_iterable_by_source_type)(
        chunk.__internal__innerUkey(),
        sourceType,
        this.compilation.__internal_getInner()
      ).map((m) => Module.__from_binding(m, this.compilation))
    );
  }
};

// src/Entrypoint.ts
var import_binding5 = require("@rspack/binding");
var Entrypoint = class _Entrypoint extends ChunkGroup {
  static __from_binding(chunk, compilation) {
    return new _Entrypoint(chunk, compilation);
  }
  constructor(inner, compilation) {
    super(inner, compilation);
  }
  getRuntimeChunk() {
    const c = (0, import_binding5.__entrypoint_inner_get_runtime_chunk)(
      this.__internal__innerUkey(),
      this.__internal__innerCompilation()
    );
    if (c) return Chunk.__from_binding(c, this.__internal__innerCompilation());
    return null;
  }
};

// src/ErrorHelpers.ts
var loaderFlag = "LOADER_EXECUTION";
var cutOffByFlag = (stack, flag) => {
  const stacks = stack.split("\n");
  for (let i = 0; i < stacks.length; i++) {
    if (stacks[i].includes(flag)) {
      stacks.length = i;
    }
  }
  return stacks.join("\n");
};
var cutOffLoaderExecution = (stack) => cutOffByFlag(stack, loaderFlag);

// src/util/index.ts
function isNil(value) {
  return value === null || value === void 0;
}
var toBuffer = (bufLike) => {
  if (Buffer.isBuffer(bufLike)) {
    return bufLike;
  }
  if (typeof bufLike === "string") {
    return Buffer.from(bufLike);
  }
  throw new Error("Buffer or string expected");
};
var toObject = (input) => {
  let s;
  if (Buffer.isBuffer(input)) {
    s = input.toString("utf8");
  } else if (input && typeof input === "object") {
    return input;
  } else if (typeof input === "string") {
    s = input;
  } else {
    throw new Error("Buffer or string or object expected");
  }
  return JSON.parse(s);
};
function serializeObject(map) {
  if (isNil(map)) {
    return void 0;
  }
  if (typeof map === "string") {
    if (map) {
      return toBuffer(map);
    }
    return void 0;
  }
  return toBuffer(JSON.stringify(map));
}
function concatErrorMsgAndStack(err) {
  if (typeof err === "string") {
    return new Error(err);
  }
  const hideStack = "hideStack" in err && err.hideStack;
  if (!hideStack && "stack" in err) {
    err.message = err.stack || err.toString();
  } else {
    err.message = err.toString();
  }
  err.stack = err.stack || void 0;
  return err;
}
function indent(str, prefix) {
  const rem = str.replace(/\n([^\n])/g, `
${prefix}$1`);
  return prefix + rem;
}
function stringifyLoaderObject(o) {
  return o.path + o.query + o.fragment;
}
function asArray(item) {
  return Array.isArray(item) ? item : [item];
}
var unsupported = (name2, issue) => {
  let s = `${name2} is not supported by rspack.`;
  if (issue) {
    s += ` Please refer to issue ${issue} for more information.`;
  }
  throw new Error(s);
};

// src/RspackError.ts
var JsRspackDiagnostic = class {
  static __to_binding(error, severity) {
    return {
      error: concatErrorMsgAndStack(error),
      severity
    };
  }
};
var NonErrorEmittedError = class extends Error {
  constructor(error) {
    super();
    this.name = "NonErrorEmittedError";
    this.message = `(Emitted value instead of an instance of Error) ${error}`;
  }
};

// src/RuntimeModule.ts
var RuntimeModule = class {
  constructor(name2, stage = 0 /* NORMAL */) {
    this.fullHash = false;
    this.dependentHash = false;
    this.chunk = null;
    this.compilation = null;
    this.chunkGraph = null;
    this._name = name2;
    this._stage = stage;
  }
  static __to_binding(compilation, module2) {
    return {
      name: module2.name,
      stage: module2.stage,
      generator: module2.generate.bind(module2),
      cacheable: !(module2.fullHash || module2.dependentHash),
      isolate: module2.shouldIsolate()
    };
  }
  attach(compilation, chunk, chunkGraph) {
    this.compilation = compilation;
    this.chunk = chunk;
    this.chunkGraph = chunkGraph;
  }
  get name() {
    return this._name;
  }
  get stage() {
    return this._stage;
  }
  identifier() {
    return `webpack/runtime/${this._name}`;
  }
  readableIdentifier() {
    return `webpack/runtime/${this._name}`;
  }
  shouldIsolate() {
    return true;
  }
  generate() {
    throw new Error(
      `Should implement "generate" method of runtime module "${this.name}"`
    );
  }
};
RuntimeModule.STAGE_NORMAL = 0 /* NORMAL */;
RuntimeModule.STAGE_BASIC = 5 /* BASIC */;
RuntimeModule.STAGE_ATTACH = 10 /* ATTACH */;
RuntimeModule.STAGE_TRIGGER = 20 /* TRIGGER */;

// src/Stats.ts
var Stats = class {
  #inner;
  #innerMap;
  constructor(compilation) {
    this.#inner = compilation.__internal_getInner().getStats();
    this.compilation = compilation;
    this.#innerMap = new WeakMap([[this.compilation, this.#inner]]);
  }
  // use correct JsStats for child compilation
  #getInnerByCompilation(compilation) {
    if (this.#innerMap.has(compilation)) {
      return this.#innerMap.get(compilation);
    }
    const inner = compilation.__internal_getInner().getStats();
    this.#innerMap.set(compilation, inner);
    return inner;
  }
  get hash() {
    return this.compilation.hash;
  }
  get startTime() {
    return this.compilation.startTime;
  }
  get endTime() {
    return this.compilation.endTime;
  }
  hasErrors() {
    return this.#inner.hasErrors();
  }
  hasWarnings() {
    return this.#inner.hasWarnings();
  }
  toJson(opts, forToString) {
    const options = this.compilation.createStatsOptions(opts, {
      forToString
    });
    const statsFactory = this.compilation.createStatsFactory(options);
    const statsCompilationMap = /* @__PURE__ */ new Map();
    let stats = null;
    try {
      stats = statsFactory.create("compilation", this.compilation, {
        compilation: this.compilation,
        getStatsCompilation: (compilation) => {
          if (statsCompilationMap.has(compilation)) {
            return statsCompilationMap.get(compilation);
          }
          const innerStats = this.#getInnerByCompilation(compilation);
          const innerStatsCompilation = innerStats.toJson(options);
          statsCompilationMap.set(compilation, innerStatsCompilation);
          return innerStatsCompilation;
        },
        getInner: this.#getInnerByCompilation.bind(this)
      });
    } catch (e) {
      console.warn(
        "Failed to get stats. Are you trying to access the stats from the previous compilation?"
      );
    }
    return stats;
  }
  toString(opts) {
    const options = this.compilation.createStatsOptions(opts, {
      forToString: true
    });
    const statsFactory = this.compilation.createStatsFactory(options);
    const statsPrinter = this.compilation.createStatsPrinter(options);
    const statsCompilationMap = /* @__PURE__ */ new Map();
    let stats = null;
    try {
      stats = statsFactory.create("compilation", this.compilation, {
        compilation: this.compilation,
        getStatsCompilation: (compilation) => {
          if (statsCompilationMap.has(compilation)) {
            return statsCompilationMap.get(compilation);
          }
          const innerStats = this.#getInnerByCompilation(compilation);
          const innerStatsCompilation = innerStats.toJson(options);
          statsCompilationMap.set(compilation, innerStatsCompilation);
          return innerStatsCompilation;
        },
        getInner: this.#getInnerByCompilation.bind(this)
      });
    } catch (e) {
      console.warn(
        "Failed to get stats. Are you trying to access the stats from the previous compilation?"
      );
    }
    if (!stats) {
      return "";
    }
    const result2 = statsPrinter.print("compilation", stats);
    return result2 === void 0 ? "" : result2;
  }
};
function normalizeStatsPreset(options) {
  if (typeof options === "boolean" || typeof options === "string")
    return presetToOptions(options);
  if (!options) return {};
  const obj = { ...presetToOptions(options.preset), ...options };
  delete obj.preset;
  return obj;
}
function presetToOptions(name2) {
  const preset = typeof name2 === "string" && name2.toLowerCase() || name2;
  switch (preset) {
    case "none":
      return {
        all: false
      };
    case "verbose":
      return {
        all: true,
        modulesSpace: Number.POSITIVE_INFINITY
      };
    case "errors-only":
      return {
        all: false,
        errors: true,
        errorsCount: true,
        logging: "error",
        moduleTrace: true
      };
    case "errors-warnings":
      return {
        all: false,
        errors: true,
        errorsCount: true,
        warnings: true,
        warningsCount: true,
        logging: "warn"
      };
    default:
      return {};
  }
}

// src/logging/Logger.ts
var LogType = Object.freeze({
  error: (
    /** @type {"error"} */
    "error"
  ),
  // message, c style arguments
  warn: (
    /** @type {"warn"} */
    "warn"
  ),
  // message, c style arguments
  info: (
    /** @type {"info"} */
    "info"
  ),
  // message, c style arguments
  log: (
    /** @type {"log"} */
    "log"
  ),
  // message, c style arguments
  debug: (
    /** @type {"debug"} */
    "debug"
  ),
  // message, c style arguments
  trace: (
    /** @type {"trace"} */
    "trace"
  ),
  // no arguments
  group: (
    /** @type {"group"} */
    "group"
  ),
  // [label]
  groupCollapsed: (
    /** @type {"groupCollapsed"} */
    "groupCollapsed"
  ),
  // [label]
  groupEnd: (
    /** @type {"groupEnd"} */
    "groupEnd"
  ),
  // [label]
  profile: (
    /** @type {"profile"} */
    "profile"
  ),
  // [profileName]
  profileEnd: (
    /** @type {"profileEnd"} */
    "profileEnd"
  ),
  // [profileName]
  time: (
    /** @type {"time"} */
    "time"
  ),
  // name, time as [seconds, nanoseconds]
  clear: (
    /** @type {"clear"} */
    "clear"
  ),
  // no arguments
  status: (
    /** @type {"status"} */
    "status"
  ),
  // message, arguments
  cache: (
    /** @type {"cache"} */
    "cache"
  )
  // [hit, total]
});
function getLogTypeBitFlag(type) {
  return 1 << Object.values(LogType).findIndex((i) => i === type);
}
function getLogTypesBitFlag(types) {
  return types.reduce((acc, cur) => acc | getLogTypeBitFlag(cur), 0);
}
var LOG_SYMBOL = Symbol("webpack logger raw log method");
var TIMERS_SYMBOL = Symbol("webpack logger times");
var TIMERS_AGGREGATES_SYMBOL = Symbol("webpack logger aggregated times");
LOG_SYMBOL, TIMERS_SYMBOL, TIMERS_AGGREGATES_SYMBOL;
var Logger = class {
  constructor(log, getChildLogger) {
    this[LOG_SYMBOL] = log;
    this.getChildLogger = getChildLogger;
  }
  error(...args) {
    this[LOG_SYMBOL](LogType.error, args);
  }
  warn(...args) {
    this[LOG_SYMBOL](LogType.warn, args);
  }
  info(...args) {
    this[LOG_SYMBOL](LogType.info, args);
  }
  log(...args) {
    this[LOG_SYMBOL](LogType.log, args);
  }
  debug(...args) {
    this[LOG_SYMBOL](LogType.debug, args);
  }
  assert(assertion, ...args) {
    if (!assertion) {
      this[LOG_SYMBOL](LogType.error, args);
    }
  }
  trace() {
    this[LOG_SYMBOL](LogType.trace, ["Trace"]);
  }
  clear() {
    this[LOG_SYMBOL](LogType.clear);
  }
  status(...args) {
    this[LOG_SYMBOL](LogType.status, args);
  }
  group(...args) {
    this[LOG_SYMBOL](LogType.group, args);
  }
  groupCollapsed(...args) {
    this[LOG_SYMBOL](LogType.groupCollapsed, args);
  }
  groupEnd(...args) {
    this[LOG_SYMBOL](LogType.groupEnd, args);
  }
  profile(label) {
    this[LOG_SYMBOL](LogType.profile, [label]);
  }
  profileEnd(label) {
    this[LOG_SYMBOL](LogType.profileEnd, [label]);
  }
  time(label) {
    this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || /* @__PURE__ */ new Map();
    this[TIMERS_SYMBOL].set(label, process.hrtime());
  }
  timeLog(label) {
    var _a;
    const prev = (_a = this[TIMERS_SYMBOL]) == null ? void 0 : _a.get(label);
    if (!prev) {
      throw new Error(`No such label '${label}' for WebpackLogger.timeLog()`);
    }
    const time = process.hrtime(prev);
    this[LOG_SYMBOL](LogType.time, [label, ...time]);
  }
  timeEnd(label) {
    var _a;
    const prev = (_a = this[TIMERS_SYMBOL]) == null ? void 0 : _a.get(label);
    if (!prev) {
      throw new Error(`No such label '${label}' for WebpackLogger.timeEnd()`);
    }
    const time = process.hrtime(prev);
    this[TIMERS_SYMBOL].delete(label);
    this[LOG_SYMBOL](LogType.time, [label, ...time]);
  }
  timeAggregate(label) {
    var _a;
    const prev = (_a = this[TIMERS_SYMBOL]) == null ? void 0 : _a.get(label);
    if (!prev) {
      throw new Error(
        `No such label '${label}' for WebpackLogger.timeAggregate()`
      );
    }
    const time = process.hrtime(prev);
    this[TIMERS_SYMBOL].delete(label);
    this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || /* @__PURE__ */ new Map();
    const current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
    if (current !== void 0) {
      if (time[1] + current[1] > 1e9) {
        time[0] += current[0] + 1;
        time[1] = time[1] - 1e9 + current[1];
      } else {
        time[0] += current[0];
        time[1] += current[1];
      }
    }
    this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
  }
  timeAggregateEnd(label) {
    if (this[TIMERS_AGGREGATES_SYMBOL] === void 0) return;
    const time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
    if (time === void 0) return;
    this[TIMERS_AGGREGATES_SYMBOL].delete(label);
    this[LOG_SYMBOL](LogType.time, [label, ...time]);
  }
};

// src/stats/StatsFactory.ts
var import_lite_tapable = require("@rspack/lite-tapable");

// src/util/smartGrouping.ts
var smartGrouping = (items, groupConfigs) => {
  const itemsWithGroups = /* @__PURE__ */ new Set();
  const allGroups = /* @__PURE__ */ new Map();
  for (const item of items) {
    const groups = /* @__PURE__ */ new Set();
    for (let i = 0; i < groupConfigs.length; i++) {
      const groupConfig = groupConfigs[i];
      const keys = groupConfig.getKeys(item);
      if (keys) {
        for (const name2 of keys) {
          const key = `${i}:${name2}`;
          let group = allGroups.get(key);
          if (group === void 0) {
            allGroups.set(
              key,
              group = {
                config: groupConfig,
                name: name2,
                alreadyGrouped: false,
                items: void 0
              }
            );
          }
          groups.add(group);
        }
      }
    }
    itemsWithGroups.add({
      item,
      groups
    });
  }
  const runGrouping = (itemsWithGroups2) => {
    var _a;
    const totalSize = itemsWithGroups2.size;
    for (const entry2 of itemsWithGroups2) {
      for (const group of entry2.groups) {
        if (group.alreadyGrouped) continue;
        const items2 = group.items;
        if (items2 === void 0) {
          group.items = /* @__PURE__ */ new Set([entry2]);
        } else {
          items2.add(entry2);
        }
      }
    }
    const groupMap = /* @__PURE__ */ new Map();
    for (const group of allGroups.values()) {
      if (group.items) {
        const items2 = group.items;
        group.items = void 0;
        groupMap.set(group, {
          items: items2,
          options: void 0,
          used: false
        });
      }
    }
    const results = [];
    for (; ; ) {
      let bestGroup = void 0;
      let bestGroupSize = -1;
      let bestGroupItems = void 0;
      let bestGroupOptions = void 0;
      for (const [group, state2] of groupMap) {
        const { items: items3, used } = state2;
        let options2 = state2.options;
        if (options2 === void 0) {
          const groupConfig2 = group.config;
          state2.options = options2 = ((_a = groupConfig2.getOptions) == null ? void 0 : _a.call(
            groupConfig2,
            group.name,
            Array.from(items3, ({ item }) => item)
          )) || false;
        }
        const force = options2 !== false && options2.force;
        if (!force) {
          if (bestGroupOptions !== false && (bestGroupOptions == null ? void 0 : bestGroupOptions.force)) continue;
          if (used) continue;
          if (items3.size <= 1 || totalSize - items3.size <= 1) {
            continue;
          }
        }
        const targetGroupCount = options2 !== false && options2.targetGroupCount || 4;
        const sizeValue = force ? items3.size : Math.min(
          items3.size,
          totalSize * 2 / targetGroupCount + itemsWithGroups2.size - items3.size
        );
        if (sizeValue > bestGroupSize || force && (!bestGroupOptions || !bestGroupOptions.force)) {
          bestGroup = group;
          bestGroupSize = sizeValue;
          bestGroupItems = items3;
          bestGroupOptions = options2;
        }
      }
      if (bestGroup === void 0) {
        break;
      }
      const items2 = new Set(bestGroupItems);
      const options = bestGroupOptions;
      const groupChildren = !options || options.groupChildren !== false;
      for (const item of items2) {
        itemsWithGroups2.delete(item);
        for (const group of item.groups) {
          const state2 = groupMap.get(group);
          if (state2 !== void 0) {
            state2.items.delete(item);
            if (state2.items.size === 0) {
              groupMap.delete(group);
            } else {
              state2.options = void 0;
              if (groupChildren) {
                state2.used = true;
              }
            }
          }
        }
      }
      groupMap.delete(bestGroup);
      const key = bestGroup.name;
      const groupConfig = bestGroup.config;
      const allItems = Array.from(items2, ({ item }) => item);
      bestGroup.alreadyGrouped = true;
      const children = groupChildren ? runGrouping(items2) : allItems;
      bestGroup.alreadyGrouped = false;
      results.push(groupConfig.createGroup(key, children, allItems));
    }
    for (const { item } of itemsWithGroups2) {
      results.push(item);
    }
    return results;
  };
  return runGrouping(itemsWithGroups);
};

// src/stats/StatsFactory.ts
var StatsFactory = class {
  constructor() {
    this.hooks = Object.freeze({
      extract: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook([
          "object",
          "data",
          "context"
        ])
      ),
      filter: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["item", "context", "index", "unfilteredIndex"])
      ),
      sort: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["comparators", "context"])
      ),
      filterSorted: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["item", "context", "index", "unfilteredIndex"])
      ),
      groupResults: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["groupConfigs", "context"])
      ),
      sortResults: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["comparators", "context"])
      ),
      filterResults: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook(["item", "context", "index", "unfilteredIndex"])
      ),
      merge: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook([
          "items",
          "context"
        ])
      ),
      result: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncWaterfallHook([
          "result",
          "context"
        ])
      ),
      getItemName: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook([
          "item",
          "context"
        ])
      ),
      getItemFactory: new import_lite_tapable.HookMap(
        () => new import_lite_tapable.SyncBailHook([
          "item",
          "context"
        ])
      )
    });
    const hooks = this.hooks;
    const caches = {};
    for (const key of Object.keys(hooks)) {
      caches[key] = /* @__PURE__ */ new Map();
    }
    this._caches = caches;
    this._inCreate = false;
  }
  _getAllLevelHooks(hookMap, cache, type) {
    const cacheEntry = cache.get(type);
    if (cacheEntry !== void 0) {
      return cacheEntry;
    }
    const hooks = [];
    const typeParts = type.split(".");
    for (let i = 0; i < typeParts.length; i++) {
      const hook = hookMap.get(typeParts.slice(i).join("."));
      if (hook) {
        hooks.push(hook);
      }
    }
    cache.set(type, hooks);
    return hooks;
  }
  _forEachLevel(hookMap, cache, type, fn2) {
    for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {
      const result2 = fn2(hook);
      if (result2 !== void 0) return result2;
    }
  }
  _forEachLevelWaterfall(hookMap, cache, type, data, fn2) {
    return this._getAllLevelHooks(hookMap, cache, type).reduce((data2, hook) => {
      return fn2(hook, data2);
    }, data);
  }
  _forEachLevelFilter(hookMap, cache, type, items, fn2, forceClone) {
    const hooks = this._getAllLevelHooks(hookMap, cache, type);
    if (hooks.length === 0) return forceClone ? items.slice() : items;
    let i = 0;
    return items.filter((item, idx) => {
      for (const hook of hooks) {
        const r = fn2(hook, item, idx, i);
        if (r !== void 0) {
          if (r) i++;
          return r;
        }
      }
      i++;
      return true;
    });
  }
  create(type, data, baseContext) {
    if (this._inCreate) {
      return this._create(type, data, baseContext);
    }
    try {
      this._inCreate = true;
      return this._create(type, data, baseContext);
    } finally {
      for (const key of Object.keys(this._caches))
        this._caches[key].clear();
      this._inCreate = false;
    }
  }
  _create(type, data, baseContext) {
    const context2 = {
      ...baseContext,
      type,
      [type]: data
    };
    if (Array.isArray(data)) {
      const items = this._forEachLevelFilter(
        this.hooks.filter,
        this._caches.filter,
        type,
        data,
        (h, r, idx, i) => h.call(r, context2, idx, i),
        true
      );
      const comparators = [];
      this._forEachLevel(
        this.hooks.sort,
        this._caches.sort,
        type,
        (h) => h.call(comparators, context2)
      );
      if (comparators.length > 0) {
        items.sort(concatComparators(...comparators));
      }
      const items2 = this._forEachLevelFilter(
        this.hooks.filterSorted,
        this._caches.filterSorted,
        type,
        items,
        (h, r, idx, i) => h.call(r, context2, idx, i),
        false
      );
      let resultItems = items2.map((item, i) => {
        const itemContext = {
          ...context2,
          _index: i
        };
        const itemName = this._forEachLevel(
          this.hooks.getItemName,
          this._caches.getItemName,
          `${type}[]`,
          (h) => h.call(item, itemContext)
        );
        if (itemName) itemContext[itemName] = item;
        const innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;
        const itemFactory = this._forEachLevel(
          this.hooks.getItemFactory,
          this._caches.getItemFactory,
          innerType,
          (h) => h.call(item, itemContext)
        ) || this;
        return itemFactory.create(innerType, item, itemContext);
      });
      const comparators2 = [];
      this._forEachLevel(
        this.hooks.sortResults,
        this._caches.sortResults,
        type,
        (h) => h.call(comparators2, context2)
      );
      if (comparators2.length > 0) {
        resultItems.sort(concatComparators(...comparators2));
      }
      const groupConfigs = [];
      this._forEachLevel(
        this.hooks.groupResults,
        this._caches.groupResults,
        type,
        (h) => h.call(groupConfigs, context2)
      );
      if (groupConfigs.length > 0) {
        resultItems = smartGrouping(resultItems, groupConfigs);
      }
      const finalResultItems = this._forEachLevelFilter(
        this.hooks.filterResults,
        this._caches.filterResults,
        type,
        resultItems,
        (h, r, idx, i) => h.call(r, context2, idx, i),
        false
      );
      let result2 = this._forEachLevel(
        this.hooks.merge,
        this._caches.merge,
        type,
        (h) => h.call(finalResultItems, context2)
      );
      if (result2 === void 0) result2 = finalResultItems;
      return this._forEachLevelWaterfall(
        this.hooks.result,
        this._caches.result,
        type,
        result2,
        (h, r) => h.call(r, context2)
      );
    }
    const object = {};
    this._forEachLevel(
      this.hooks.extract,
      this._caches.extract,
      type,
      (h) => h.call(object, data, context2)
    );
    return this._forEachLevelWaterfall(
      this.hooks.result,
      this._caches.result,
      type,
      object,
      (h, r) => h.call(r, context2)
    );
  }
};

// src/stats/StatsPrinter.ts
var import_lite_tapable2 = require("@rspack/lite-tapable");
var StatsPrinter = class {
  constructor() {
    this.hooks = Object.freeze({
      sortElements: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "elements",
          "context"
        ])
      ),
      printElements: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "printedElements",
          "context"
        ])
      ),
      sortItems: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "items",
          "context"
        ])
      ),
      getItemName: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "item",
          "context"
        ])
      ),
      printItems: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "printedItems",
          "context"
        ])
      ),
      print: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncBailHook([
          "object",
          "context"
        ])
      ),
      result: new import_lite_tapable2.HookMap(
        () => new import_lite_tapable2.SyncWaterfallHook([
          "result",
          "context"
        ])
      )
    });
    this._levelHookCache = /* @__PURE__ */ new Map();
    this._inPrint = false;
  }
  /**
   * get all level hooks
   */
  _getAllLevelHooks(hookMap, type) {
    let cache = this._levelHookCache.get(hookMap);
    if (cache === void 0) {
      cache = /* @__PURE__ */ new Map();
      this._levelHookCache.set(hookMap, cache);
    }
    const cacheEntry = cache.get(type);
    if (cacheEntry !== void 0) {
      return cacheEntry;
    }
    const hooks = [];
    const typeParts = type.split(".");
    for (let i = 0; i < typeParts.length; i++) {
      const hook = hookMap.get(typeParts.slice(i).join("."));
      if (hook) {
        hooks.push(hook);
      }
    }
    cache.set(type, hooks);
    return hooks;
  }
  _forEachLevel(hookMap, type, fn2) {
    for (const hook of this._getAllLevelHooks(hookMap, type)) {
      const result2 = fn2(hook);
      if (result2 !== void 0) return result2;
    }
  }
  _forEachLevelWaterfall(hookMap, type, data, fn2) {
    return this._getAllLevelHooks(hookMap, type).reduce((data2, hook) => {
      return fn2(hook, data2);
    }, data);
  }
  print(type, object, baseContext) {
    if (this._inPrint) {
      return this._print(type, object, baseContext);
    }
    try {
      this._inPrint = true;
      return this._print(type, object, baseContext);
    } finally {
      this._levelHookCache.clear();
      this._inPrint = false;
    }
  }
  _print(type, object, baseContext) {
    const context2 = {
      ...baseContext,
      type,
      [type]: object
    };
    let printResult = this._forEachLevel(
      this.hooks.print,
      type,
      (hook) => hook.call(object, context2)
    );
    if (printResult === void 0) {
      if (Array.isArray(object)) {
        const sortedItems = object.slice();
        this._forEachLevel(
          this.hooks.sortItems,
          type,
          (h) => h.call(sortedItems, context2)
        );
        const printedItems = sortedItems.map((item, i) => {
          const itemContext = {
            ...context2,
            _index: i
          };
          const itemName = this._forEachLevel(
            this.hooks.getItemName,
            `${type}[]`,
            (h) => h.call(item, itemContext)
          );
          if (itemName) itemContext[itemName] = item;
          return this.print(
            itemName ? `${type}[].${itemName}` : `${type}[]`,
            item,
            itemContext
          );
        });
        printResult = this._forEachLevel(
          this.hooks.printItems,
          type,
          (h) => h.call(printedItems, context2)
        );
        if (printResult === void 0) {
          const result2 = printedItems.filter(Boolean);
          if (result2.length > 0) printResult = result2.join("\n");
        }
      } else if (object !== null && typeof object === "object") {
        const elements = Object.keys(object).filter(
          (key) => object[key] !== void 0
        );
        this._forEachLevel(
          this.hooks.sortElements,
          type,
          (h) => h.call(elements, context2)
        );
        const printedElements = elements.map((element) => {
          const content = this.print(`${type}.${element}`, object[element], {
            ...context2,
            _parent: object,
            _element: element,
            [element]: object[element]
          });
          return { element, content };
        });
        printResult = this._forEachLevel(
          this.hooks.printElements,
          type,
          (h) => h.call(printedElements, context2)
        );
        if (printResult === void 0) {
          const result2 = printedElements.map((e) => e.content).filter(Boolean);
          if (result2.length > 0) printResult = result2.join("\n");
        }
      }
    }
    return this._forEachLevelWaterfall(
      this.hooks.result,
      type,
      printResult,
      (h, r) => h.call(r, context2)
    );
  }
};

// src/util/AssetInfo.ts
var JsAssetInfo = class {
  static __from_binding(jsAssetInfo) {
    const {
      immutable,
      minimized,
      development,
      hotModuleReplacement,
      related,
      chunkhash,
      fullhash,
      contenthash,
      javascriptModule,
      sourceFilename,
      copied,
      extras
    } = jsAssetInfo;
    return {
      ...extras,
      // extras should not overwrite any KnownAssetFields
      immutable,
      minimized,
      development,
      hotModuleReplacement,
      related,
      fullhash,
      chunkhash,
      contenthash,
      javascriptModule,
      sourceFilename,
      copied
    };
  }
  static __to_binding(assetInfo = {}) {
    let {
      immutable = false,
      minimized = false,
      development = false,
      hotModuleReplacement = false,
      related = {},
      fullhash = [],
      chunkhash = [],
      contenthash = [],
      javascriptModule,
      sourceFilename,
      copied,
      ...extras
    } = assetInfo;
    extras = extras ?? {};
    return {
      immutable,
      minimized,
      development,
      hotModuleReplacement,
      related,
      fullhash,
      chunkhash,
      contenthash,
      extras,
      javascriptModule,
      sourceFilename,
      copied
    };
  }
};

// src/util/MergeCaller.ts
var MergeCaller = class {
  constructor(fn2, debounceTime) {
    this.timer = null;
    this.callArgs = [];
    this.finalCall = () => {
      this.timer = null;
      const args = this.callArgs;
      this.callArgs = [];
      this.callFn(args);
    };
    this.debounceTime = debounceTime;
    this.callFn = fn2;
  }
  push(...data) {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.callArgs.push(...data);
    this.timer = setTimeout(this.finalCall, this.debounceTime);
  }
};

// src/util/createReadonlyMap.ts
function createReadonlyMap(obj) {
  return {
    ...obj,
    *values() {
      const keys = this.keys();
      for (const key of keys) {
        yield this.get(key);
      }
    },
    *entries() {
      const keys = this.keys();
      for (const key of keys) {
        yield [key, this.get(key)];
      }
    },
    forEach(callback, thisArg) {
      for (const [key, value] of this) {
        callback.call(thisArg, value, key, this);
      }
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  };
}

// src/util/fake.ts
function createFakeCompilationDependencies(getDeps, addDeps) {
  const addDepsCaller = new MergeCaller(addDeps, 10);
  return {
    *[Symbol.iterator]() {
      const deps = getDeps();
      for (const dep of deps) {
        yield dep;
      }
    },
    has(dep) {
      return getDeps().includes(dep);
    },
    add: (dep) => {
      addDepsCaller.push(dep);
    },
    addAll: (deps) => {
      addDepsCaller.push(...deps);
    }
  };
}

// src/util/memoize.ts
var memoize = (fn2) => {
  let cache = false;
  let result2;
  let callback = fn2;
  return () => {
    if (cache) {
      return result2;
    }
    result2 = callback();
    cache = true;
    callback = void 0;
    return result2;
  };
};
var memoizeFn = (fn2) => {
  let cache = null;
  return (...args) => {
    if (!cache) {
      cache = fn2();
    }
    return cache(...args);
  };
};
function memoizeValue(fn2) {
  const getValue = memoize(fn2);
  return new Proxy({}, {
    get(_, property) {
      let res = getValue()[property];
      if (typeof res === "function") {
        res = res.bind(getValue());
      }
      return res;
    },
    set(_, property, newValue) {
      getValue()[property] = newValue;
      return true;
    },
    deleteProperty(_, property) {
      const value = getValue();
      return delete value[property];
    },
    has: (_, property) => {
      return property in getValue();
    },
    ownKeys: (_) => {
      return Object.keys(getValue());
    },
    getOwnPropertyDescriptor(_, property) {
      return Object.getOwnPropertyDescriptor(getValue(), property);
    }
  });
}

// src/Compilation.ts
var _inner, _customModules, _Compilation_instances, createCachedAssets_fn, _rebuildModuleCaller;
var _Compilation = class _Compilation {
  constructor(compiler, inner) {
    __privateAdd(this, _Compilation_instances);
    __privateAdd(this, _inner);
    this.fileSystemInfo = {
      createSnapshot() {
        return null;
      }
    };
    /**
     * Records the dynamically added fields for Module on the JavaScript side, using the Module identifier for association.
     * These fields are generally used within a plugin, so they do not need to be passed back to the Rust side.
     */
    __privateAdd(this, _customModules);
    this.fileDependencies = createFakeCompilationDependencies(
      () => __privateGet(this, _inner).dependencies().fileDependencies,
      (d) => __privateGet(this, _inner).addFileDependencies(d)
    );
    this.contextDependencies = createFakeCompilationDependencies(
      () => __privateGet(this, _inner).dependencies().contextDependencies,
      (d) => __privateGet(this, _inner).addContextDependencies(d)
    );
    this.missingDependencies = createFakeCompilationDependencies(
      () => __privateGet(this, _inner).dependencies().missingDependencies,
      (d) => __privateGet(this, _inner).addMissingDependencies(d)
    );
    this.buildDependencies = createFakeCompilationDependencies(
      () => __privateGet(this, _inner).dependencies().buildDependencies,
      (d) => __privateGet(this, _inner).addBuildDependencies(d)
    );
    __privateAdd(this, _rebuildModuleCaller, ((compilation) => new MergeCaller(
      (args) => {
        __privateGet(compilation, _inner).rebuildModule(
          args.map((item) => item[0]),
          (err, modules) => {
            for (const [id, callback] of args) {
              const m = modules.find((item) => item.moduleIdentifier === id);
              if (m) {
                callback(err, Module.__from_binding(m, compilation));
              } else {
                callback(err || new Error("module no found"), null);
              }
            }
          }
        );
      },
      10
    ))(this));
    __privateSet(this, _inner, inner);
    __privateSet(this, _customModules, {});
    const processAssetsHook = new liteTapable.AsyncSeriesHook([
      "assets"
    ]);
    const createProcessAssetsHook = (name2, stage, getArgs, code) => {
      const errorMessage = (reason) => `Can't automatically convert plugin using Compilation.hooks.${name2} to Compilation.hooks.processAssets because ${reason}.
BREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`;
      const getOptions = (options) => {
        const isString2 = typeof options === "string";
        if (!isString2 && options.stage) {
          throw new Error(errorMessage("it's using the 'stage' option"));
        }
        return {
          ...isString2 ? { name: options } : options,
          stage
        };
      };
      return Object.freeze({
        name: name2,
        intercept() {
          throw new Error(errorMessage("it's using 'intercept'"));
        },
        tap: (options, fn2) => {
          processAssetsHook.tap(getOptions(options), () => fn2(...getArgs()));
        },
        tapAsync: (options, fn2) => {
          processAssetsHook.tapAsync(
            getOptions(options),
            (assets, callback) => fn2(...getArgs(), callback)
          );
        },
        tapPromise: (options, fn2) => {
          processAssetsHook.tapPromise(
            getOptions(options),
            () => fn2(...getArgs())
          );
        },
        _fakeHook: true
      });
    };
    this.hooks = {
      processAssets: processAssetsHook,
      afterProcessAssets: new liteTapable.SyncHook(["assets"]),
      /** @deprecated */
      additionalAssets: createProcessAssetsHook(
        "additionalAssets",
        _Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
        () => []
      ),
      childCompiler: new liteTapable.SyncHook([
        "childCompiler",
        "compilerName",
        "compilerIndex"
      ]),
      log: new liteTapable.SyncBailHook(["origin", "logEntry"]),
      optimizeModules: new liteTapable.SyncBailHook(["modules"]),
      afterOptimizeModules: new liteTapable.SyncBailHook(["modules"]),
      optimizeTree: new liteTapable.AsyncSeriesHook(["chunks", "modules"]),
      optimizeChunkModules: new liteTapable.AsyncSeriesBailHook([
        "chunks",
        "modules"
      ]),
      finishModules: new liteTapable.AsyncSeriesHook(["modules"]),
      chunkHash: new liteTapable.SyncHook(["chunk", "hash"]),
      chunkAsset: new liteTapable.SyncHook(["chunk", "filename"]),
      processWarnings: new liteTapable.SyncWaterfallHook(["warnings"]),
      succeedModule: new liteTapable.SyncHook(["module"]),
      stillValidModule: new liteTapable.SyncHook(["module"]),
      statsPreset: new liteTapable.HookMap(
        () => new liteTapable.SyncHook(["options", "context"])
      ),
      statsNormalize: new liteTapable.SyncHook(["options", "context"]),
      statsFactory: new liteTapable.SyncHook(["statsFactory", "options"]),
      statsPrinter: new liteTapable.SyncHook(["statsPrinter", "options"]),
      buildModule: new liteTapable.SyncHook(["module"]),
      executeModule: new liteTapable.SyncHook(["options", "context"]),
      additionalTreeRuntimeRequirements: new liteTapable.SyncHook([
        "chunk",
        "runtimeRequirements"
      ]),
      runtimeRequirementInTree: new liteTapable.HookMap(
        () => new liteTapable.SyncBailHook(["chunk", "runtimeRequirements"])
      ),
      runtimeModule: new liteTapable.SyncHook(["module", "chunk"]),
      seal: new liteTapable.SyncHook([]),
      afterSeal: new liteTapable.AsyncSeriesHook([])
    };
    this.compiler = compiler;
    this.resolverFactory = compiler.resolverFactory;
    this.inputFileSystem = compiler.inputFileSystem;
    this.options = compiler.options;
    this.outputOptions = compiler.options.output;
    this.logging = /* @__PURE__ */ new Map();
    this.childrenCounters = {};
    this.children = [];
    this.chunkGraph = new ChunkGraph(this);
  }
  get hash() {
    return __privateGet(this, _inner).hash;
  }
  get fullHash() {
    return __privateGet(this, _inner).hash;
  }
  /**
   * Get a map of all assets.
   */
  get assets() {
    return memoizeValue(() => __privateMethod(this, _Compilation_instances, createCachedAssets_fn).call(this));
  }
  /**
   * Get a map of all entrypoints.
   */
  get entrypoints() {
    return memoizeValue(
      () => new Map(
        Object.entries(__privateGet(this, _inner).entrypoints).map(([n, e]) => [
          n,
          Entrypoint.__from_binding(e, __privateGet(this, _inner))
        ])
      )
    );
  }
  get chunkGroups() {
    return memoizeValue(
      () => __privateGet(this, _inner).chunkGroups.map(
        (cg) => ChunkGroup.__from_binding(cg, __privateGet(this, _inner))
      )
    );
  }
  /**
   * Get the named chunk groups.
   *
   * Note: This is a proxy for webpack internal API, only method `get`, `keys`, `values` and `entries` are supported now.
   */
  get namedChunkGroups() {
    return createReadonlyMap({
      keys: () => {
        const names = __privateGet(this, _inner).getNamedChunkGroupKeys();
        return names[Symbol.iterator]();
      },
      get: (property) => {
        if (typeof property === "string") {
          const chunk = __privateGet(this, _inner).getNamedChunkGroup(property) || void 0;
          return chunk && ChunkGroup.__from_binding(chunk, __privateGet(this, _inner));
        }
      }
    });
  }
  get modules() {
    return new Set(
      __privateGet(this, _inner).modules.map((module2) => Module.__from_binding(module2, this))
    );
  }
  get builtModules() {
    return new Set(
      __privateGet(this, _inner).builtModules.map(
        (module2) => Module.__from_binding(module2, this)
      )
    );
  }
  get chunks() {
    return memoizeValue(() => new Set(this.__internal__getChunks()));
  }
  /**
   * Get the named chunks.
   *
   * Note: This is a proxy for webpack internal API, only method `get`, `keys`, `values` and `entries` are supported now.
   */
  get namedChunks() {
    return createReadonlyMap({
      keys: () => {
        const names = __privateGet(this, _inner).getNamedChunkKeys();
        return names[Symbol.iterator]();
      },
      get: (property) => {
        if (typeof property === "string") {
          const chunk = __privateGet(this, _inner).getNamedChunk(property) || void 0;
          return chunk && Chunk.__from_binding(chunk, __privateGet(this, _inner));
        }
      }
    });
  }
  get entries() {
    return new Entries(__privateGet(this, _inner).entries);
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__getCustomModule(moduleIdentifier) {
    let module2 = __privateGet(this, _customModules)[moduleIdentifier];
    if (!module2) {
      module2 = __privateGet(this, _customModules)[moduleIdentifier] = {
        buildInfo: {},
        buildMeta: {}
      };
    }
    return module2;
  }
  getCache(name2) {
    return this.compiler.getCache(name2);
  }
  createStatsOptions(statsValue2, context2 = {}) {
    let optionsOrPreset = statsValue2;
    if (typeof optionsOrPreset === "boolean" || typeof optionsOrPreset === "string") {
      optionsOrPreset = { preset: optionsOrPreset };
    }
    if (typeof optionsOrPreset === "object" && optionsOrPreset !== null) {
      const options2 = {};
      for (const key in optionsOrPreset) {
        options2[key] = optionsOrPreset[key];
      }
      if (options2.preset !== void 0) {
        this.hooks.statsPreset.for(options2.preset).call(options2, context2);
      }
      this.hooks.statsNormalize.call(options2, context2);
      return options2;
    }
    const options = {};
    this.hooks.statsNormalize.call(options, context2);
    return options;
  }
  createStatsFactory(options) {
    const statsFactory = new StatsFactory();
    this.hooks.statsFactory.call(statsFactory, options);
    return statsFactory;
  }
  createStatsPrinter(options) {
    const statsPrinter = new StatsPrinter();
    this.hooks.statsPrinter.call(statsPrinter, options);
    return statsPrinter;
  }
  /**
   * Update an existing asset. Trying to update an asset that doesn't exist will throw an error.
   */
  updateAsset(filename2, newSourceOrFunction, assetInfoUpdateOrFunction) {
    let compatNewSourceOrFunction;
    if (typeof newSourceOrFunction === "function") {
      compatNewSourceOrFunction = function newSourceFunction(source) {
        return JsSource.__to_binding(
          newSourceOrFunction(JsSource.__from_binding(source))
        );
      };
    } else {
      compatNewSourceOrFunction = JsSource.__to_binding(newSourceOrFunction);
    }
    __privateGet(this, _inner).updateAsset(
      filename2,
      compatNewSourceOrFunction,
      assetInfoUpdateOrFunction === void 0 ? assetInfoUpdateOrFunction : typeof assetInfoUpdateOrFunction === "function" ? (jsAssetInfo) => JsAssetInfo.__to_binding(assetInfoUpdateOrFunction(jsAssetInfo)) : JsAssetInfo.__to_binding(assetInfoUpdateOrFunction)
    );
  }
  /**
   * Emit an not existing asset. Trying to emit an asset that already exists will throw an error.
   *
   * @param file - file name
   * @param source - asset source
   * @param assetInfo - extra asset information
   */
  emitAsset(filename2, source, assetInfo) {
    __privateGet(this, _inner).emitAsset(
      filename2,
      JsSource.__to_binding(source),
      JsAssetInfo.__to_binding(assetInfo)
    );
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__emit_asset_from_loader(filename2, source, assetInfo, module2) {
    __privateGet(this, _inner).emitAssetFromLoader(
      filename2,
      JsSource.__to_binding(source),
      JsAssetInfo.__to_binding(assetInfo),
      module2
    );
  }
  deleteAsset(filename2) {
    __privateGet(this, _inner).deleteAsset(filename2);
  }
  renameAsset(filename2, newFilename) {
    __privateGet(this, _inner).renameAsset(filename2, newFilename);
  }
  /**
   * Get an array of Asset
   */
  getAssets() {
    const assets = __privateGet(this, _inner).getAssets();
    return assets.map((asset) => {
      return Object.defineProperties(asset, {
        info: {
          value: JsAssetInfo.__from_binding(asset.info)
        },
        source: {
          get: () => this.__internal__getAssetSource(asset.name)
        }
      });
    });
  }
  getAsset(name2) {
    const asset = __privateGet(this, _inner).getAsset(name2);
    if (!asset) {
      return;
    }
    return Object.defineProperties(asset, {
      info: {
        value: JsAssetInfo.__from_binding(asset.info)
      },
      source: {
        get: () => this.__internal__getAssetSource(asset.name)
      }
    });
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__pushRspackDiagnostic(diagnostic) {
    __privateGet(this, _inner).pushDiagnostic(diagnostic);
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__pushDiagnostic(diagnostic) {
    __privateGet(this, _inner).pushNativeDiagnostic(diagnostic);
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__pushDiagnostics(diagnostics) {
    __privateGet(this, _inner).pushNativeDiagnostics(diagnostics);
  }
  get errors() {
    const inner = __privateGet(this, _inner);
    const errors = inner.getErrors();
    const proxyMethod = [
      {
        method: "push",
        handler(target2, thisArg, errs) {
          for (let i = 0; i < errs.length; i++) {
            const error = errs[i];
            inner.pushDiagnostic(
              JsRspackDiagnostic.__to_binding(error, import_binding6.JsRspackSeverity.Error)
            );
          }
          return Reflect.apply(target2, thisArg, errs);
        }
      },
      {
        method: "pop",
        handler(target2, thisArg) {
          inner.spliceDiagnostic(errors.length - 1, errors.length, []);
          return Reflect.apply(target2, thisArg, []);
        }
      },
      {
        method: "shift",
        handler(target2, thisArg) {
          inner.spliceDiagnostic(0, 1, []);
          return Reflect.apply(target2, thisArg, []);
        }
      },
      {
        method: "unshift",
        handler(target2, thisArg, errs) {
          const errList = errs.map((error) => {
            return JsRspackDiagnostic.__to_binding(
              error,
              import_binding6.JsRspackSeverity.Error
            );
          });
          inner.spliceDiagnostic(0, 0, errList);
          return Reflect.apply(target2, thisArg, errs);
        }
      },
      {
        method: "splice",
        handler(target2, thisArg, [startIdx, delCount, ...errors2]) {
          const errList = errors2.map((error) => {
            return JsRspackDiagnostic.__to_binding(
              error,
              import_binding6.JsRspackSeverity.Error
            );
          });
          inner.spliceDiagnostic(startIdx, startIdx + delCount, errList);
          return Reflect.apply(target2, thisArg, [
            startIdx,
            delCount,
            ...errors2
          ]);
        }
      }
    ];
    for (const item of proxyMethod) {
      const proxiedMethod = new Proxy(errors[item.method], {
        apply: item.handler
      });
      errors[item.method] = proxiedMethod;
    }
    return errors;
  }
  get warnings() {
    const inner = __privateGet(this, _inner);
    const processWarningsHook = this.hooks.processWarnings;
    const warnings = inner.getWarnings();
    const proxyMethod = [
      {
        method: "push",
        handler(target2, thisArg, warns) {
          return Reflect.apply(
            target2,
            thisArg,
            processWarningsHook.call(warns).map((warn) => {
              inner.pushDiagnostic(
                JsRspackDiagnostic.__to_binding(warn, import_binding6.JsRspackSeverity.Warn)
              );
              return warn;
            })
          );
        }
      },
      {
        method: "pop",
        handler(target2, thisArg) {
          inner.spliceDiagnostic(warnings.length - 1, warnings.length, []);
          return Reflect.apply(target2, thisArg, []);
        }
      },
      {
        method: "shift",
        handler(target2, thisArg) {
          inner.spliceDiagnostic(0, 1, []);
          return Reflect.apply(target2, thisArg, []);
        }
      },
      {
        method: "unshift",
        handler(target2, thisArg, warns) {
          const warnings2 = processWarningsHook.call(warns);
          inner.spliceDiagnostic(
            0,
            0,
            warnings2.map((warn) => {
              return JsRspackDiagnostic.__to_binding(
                warn,
                import_binding6.JsRspackSeverity.Warn
              );
            })
          );
          return Reflect.apply(target2, thisArg, warnings2);
        }
      },
      {
        method: "splice",
        handler(target2, thisArg, [startIdx, delCount, ...warns]) {
          warns = processWarningsHook.call(warns);
          const warnList = warns.map((warn) => {
            return JsRspackDiagnostic.__to_binding(warn, import_binding6.JsRspackSeverity.Warn);
          });
          inner.spliceDiagnostic(startIdx, startIdx + delCount, warnList);
          return Reflect.apply(target2, thisArg, [
            startIdx,
            delCount,
            ...warnList
          ]);
        }
      }
    ];
    for (const item of proxyMethod) {
      const proxiedMethod = new Proxy(warnings[item.method], {
        apply: item.handler
      });
      warnings[item.method] = proxiedMethod;
    }
    return warnings;
  }
  getPath(filename2, data = {}) {
    return __privateGet(this, _inner).getPath(filename2, {
      ...data,
      chunk: data.chunk instanceof Chunk ? data.chunk.__internal_to_path_data_chunk() : data.chunk
    });
  }
  getPathWithInfo(filename2, data = {}) {
    return __privateGet(this, _inner).getPathWithInfo(filename2, {
      ...data,
      chunk: data.chunk instanceof Chunk ? data.chunk.__internal_to_path_data_chunk() : data.chunk
    });
  }
  getAssetPath(filename2, data = {}) {
    return __privateGet(this, _inner).getAssetPath(filename2, {
      ...data,
      chunk: data.chunk instanceof Chunk ? data.chunk.__internal_to_path_data_chunk() : data.chunk
    });
  }
  getAssetPathWithInfo(filename2, data = {}) {
    return __privateGet(this, _inner).getAssetPathWithInfo(filename2, {
      ...data,
      chunk: data.chunk instanceof Chunk ? data.chunk.__internal_to_path_data_chunk() : data.chunk
    });
  }
  getLogger(name2) {
    if (!name2) {
      throw new TypeError("Compilation.getLogger(name) called without a name");
    }
    let logName = name2;
    let logEntries;
    return new Logger(
      (type, args) => {
        if (typeof logName === "function") {
          logName = logName();
          if (!logName) {
            throw new TypeError(
              "Compilation.getLogger(name) called with a function not returning a name"
            );
          }
        }
        let trace;
        switch (type) {
          case LogType.warn:
          case LogType.error:
          case LogType.trace:
            trace = cutOffLoaderExecution(new Error("Trace").stack).split("\n").slice(3);
            break;
        }
        const logEntry = {
          time: Date.now(),
          type,
          args,
          trace
        };
        if (this.hooks.log.call(logName, logEntry) === void 0) {
          if (logEntry.type === LogType.profileEnd) {
            if (typeof console.profileEnd === "function") {
              console.profileEnd(`[${logName}] ${logEntry.args[0]}`);
            }
          }
          if (logEntries === void 0) {
            logEntries = this.logging.get(logName);
            if (logEntries === void 0) {
              logEntries = [];
              this.logging.set(logName, logEntries);
            }
          }
          logEntries.push(logEntry);
          if (logEntry.type === LogType.profile) {
            if (typeof console.profile === "function") {
              console.profile(`[${logName}] ${logEntry.args[0]}`);
            }
          }
        }
      },
      (childName) => {
        let normalizedChildName = childName;
        if (typeof logName === "function") {
          if (typeof normalizedChildName === "function") {
            return this.getLogger(() => {
              if (typeof logName === "function") {
                logName = logName();
                if (!logName) {
                  throw new TypeError(
                    "Compilation.getLogger(name) called with a function not returning a name"
                  );
                }
              }
              if (typeof normalizedChildName === "function") {
                normalizedChildName = normalizedChildName();
                if (!normalizedChildName) {
                  throw new TypeError(
                    "Logger.getChildLogger(name) called with a function not returning a name"
                  );
                }
              }
              return `${logName}/${normalizedChildName}`;
            });
          }
          return this.getLogger(() => {
            if (typeof logName === "function") {
              logName = logName();
              if (!logName) {
                throw new TypeError(
                  "Compilation.getLogger(name) called with a function not returning a name"
                );
              }
            }
            return `${logName}/${normalizedChildName}`;
          });
        }
        if (typeof normalizedChildName === "function") {
          return this.getLogger(() => {
            if (typeof normalizedChildName === "function") {
              normalizedChildName = normalizedChildName();
              if (!normalizedChildName) {
                throw new TypeError(
                  "Logger.getChildLogger(name) called with a function not returning a name"
                );
              }
            }
            return `${logName}/${normalizedChildName}`;
          });
        }
        return this.getLogger(`${logName}/${normalizedChildName}`);
      }
    );
  }
  getStats() {
    return new Stats(this);
  }
  createChildCompiler(name2, outputOptions, plugins2) {
    const idx = this.childrenCounters[name2] || 0;
    this.childrenCounters[name2] = idx + 1;
    return this.compiler.createChildCompiler(
      this,
      name2,
      idx,
      outputOptions,
      plugins2
    );
  }
  rebuildModule(m, f) {
    __privateGet(this, _rebuildModuleCaller).push([m.identifier(), f]);
  }
  addRuntimeModule(chunk, runtimeModule) {
    runtimeModule.attach(this, chunk, this.chunkGraph);
    __privateGet(this, _inner).addRuntimeModule(
      chunk.__internal__innerUkey(),
      RuntimeModule.__to_binding(this, runtimeModule)
    );
  }
  /**
   * Get the `Source` of a given asset filename.
   *
   * Note: This is not a webpack public API, maybe removed in the future.
   *
   * @internal
   */
  __internal__getAssetSource(filename2) {
    const rawSource = __privateGet(this, _inner).getAssetSource(filename2);
    if (!rawSource) {
      return;
    }
    return JsSource.__from_binding(rawSource);
  }
  /**
   * Set the `Source` of an given asset filename.
   *
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__setAssetSource(filename2, source) {
    __privateGet(this, _inner).setAssetSource(filename2, JsSource.__to_binding(source));
  }
  /**
   * Delete the `Source` of an given asset filename.
   *
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__deleteAssetSource(filename2) {
    __privateGet(this, _inner).deleteAssetSource(filename2);
  }
  /**
   * Get a list of asset filenames.
   *
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__getAssetFilenames() {
    return __privateGet(this, _inner).getAssetFilenames();
  }
  /**
   * Test if an asset exists.
   *
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__hasAsset(name2) {
    return __privateGet(this, _inner).hasAsset(name2);
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal__getChunks() {
    return __privateGet(this, _inner).getChunks().map((c) => Chunk.__from_binding(c, __privateGet(this, _inner)));
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   *
   * @internal
   */
  __internal_getInner() {
    return __privateGet(this, _inner);
  }
  seal() {
  }
  unseal() {
  }
};
_inner = new WeakMap();
_customModules = new WeakMap();
_Compilation_instances = new WeakSet();
createCachedAssets_fn = function() {
  return new Proxy(
    {},
    {
      get: (_, property) => {
        if (typeof property === "string") {
          return this.__internal__getAssetSource(property);
        }
      },
      set: (_, p, newValue) => {
        if (typeof p === "string") {
          this.__internal__setAssetSource(p, newValue);
          return true;
        }
        return false;
      },
      deleteProperty: (_, p) => {
        if (typeof p === "string") {
          this.__internal__deleteAssetSource(p);
          return true;
        }
        return false;
      },
      has: (_, property) => {
        if (typeof property === "string") {
          return this.__internal__hasAsset(property);
        }
        return false;
      },
      ownKeys: (_) => {
        return this.__internal__getAssetFilenames();
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    }
  );
};
_rebuildModuleCaller = new WeakMap();
_Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2e3;
_Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1e3;
_Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200;
_Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100;
_Compilation.PROCESS_ASSETS_STAGE_NONE = 0;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400;
_Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700;
_Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1e3;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500;
_Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3e3;
_Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4e3;
_Compilation.PROCESS_ASSETS_STAGE_REPORT = 5e3;
var Compilation = _Compilation;
var Entries = class {
  #data;
  constructor(data) {
    this.#data = data;
  }
  clear() {
    this.#data.clear();
  }
  forEach(callback, thisArg) {
    for (const [key, value] of this) {
      callback.call(thisArg, value, key, this);
    }
  }
  get size() {
    return this.#data.size;
  }
  entries() {
    const self = this;
    const keys = this.keys();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const { done, value } = keys.next();
        return {
          done,
          value: done ? void 0 : [value, self.get(value)]
        };
      }
    };
  }
  values() {
    return this.#data.values()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "Map";
  }
  has(key) {
    return this.#data.has(key);
  }
  set(key, value) {
    this.#data.set(key, value);
    return this;
  }
  delete(key) {
    return this.#data.delete(key);
  }
  get(key) {
    return this.#data.get(key);
  }
  keys() {
    return this.#data.keys()[Symbol.iterator]();
  }
};

// src/Compiler.ts
var binding2 = __toESM(require("@rspack/binding"));
var liteTapable7 = __toESM(require("@rspack/lite-tapable"));

// src/ExecuteModulePlugin.ts
var import_node_vm = __toESM(require("vm"));
var ExecuteModulePlugin = class {
  apply(compiler) {
    compiler.hooks.compilation.tap("executeModule", (compilation) => {
      compilation.hooks.executeModule.tap(
        "executeModule",
        (options, context2) => {
          const moduleObject = options.moduleObject;
          const source = options.codeGenerationResult.get("javascript");
          try {
            const fn2 = import_node_vm.default.runInThisContext(
              `(function(module, __webpack_module__, __webpack_exports__, exports, ${RuntimeGlobals.require}) {
${source}
})`,
              {
                filename: moduleObject.id
              }
            );
            fn2.call(
              moduleObject.exports,
              moduleObject,
              moduleObject,
              moduleObject.exports,
              moduleObject.exports,
              context2.__webpack_require__
            );
          } catch (e) {
            const err = e instanceof Error ? e : new Error(e);
            err.stack += printGeneratedCodeForStack(moduleObject.id, source);
            throw err;
          }
        }
      );
    });
  }
};
var printGeneratedCodeForStack = (moduleId, code) => {
  const lines = code.split("\n");
  const n = `${lines.length}`.length;
  return `

Generated code for ${moduleId}
${lines.map(
    /**
     * @param {string} line the line
     * @param {number} i the index
     * @param {string[]} lines the lines
     * @returns {string} the line with line number
     */
    (line, i, lines2) => {
      const iStr = `${i + 1}`;
      return `${" ".repeat(n - iStr.length)}${iStr} | ${line}`;
    }
  ).join("\n")}`;
};

// src/error/ConcurrentCompilationError.ts
var ConcurrentCompilationError = class extends Error {
  constructor() {
    super();
    this.name = "ConcurrentCompilationError";
    this.message = "You ran rspack twice. Each instance only supports a single concurrent compilation at a time.";
  }
};

// src/lib/Cache.ts
var import_lite_tapable3 = require("@rspack/lite-tapable");

// src/lib/WebpackError.ts
var import_node_util = require("util");
var WebpackError = class extends Error {
  [import_node_util.inspect.custom]() {
    return this.stack + (this.details ? `
${this.details}` : "");
  }
};
var WebpackError_default = WebpackError;

// src/lib/HookWebpackError.ts
var HookWebpackError = class extends WebpackError_default {
  /**
   * Creates an instance of HookWebpackError.
   * @param error inner error
   * @param hook name of hook
   */
  constructor(error, hook) {
    super(error.message);
    this.name = "HookWebpackError";
    this.hook = hook;
    this.error = error;
    this.hideStack = true;
    this.details = `caused by plugins in ${hook}
${error.stack}`;
    this.stack += `
-- inner error --
${error.stack}`;
  }
};
var makeWebpackError = (error, hook) => {
  if (error instanceof WebpackError_default) return error;
  return new HookWebpackError(error, hook);
};
var makeWebpackErrorCallback = (callback, hook) => {
  return (err, result2) => {
    if (err) {
      if (err instanceof WebpackError_default) {
        callback(err);
        return;
      }
      callback(new HookWebpackError(err, hook));
      return;
    }
    callback(null, result2);
  };
};
var tryRunOrWebpackError = (fn2, hook) => {
  let r;
  try {
    r = fn2();
  } catch (err) {
    if (err instanceof WebpackError_default) {
      throw err;
    }
    throw new HookWebpackError(err, hook);
  }
  return r;
};

// src/lib/Cache.ts
var needCalls = (times, callback) => {
  let leftTimes = times;
  return (err) => {
    if (--leftTimes === 0) {
      return callback();
    }
    if (err && leftTimes > 0) {
      leftTimes = 0;
      return callback();
    }
  };
};
var Cache = class {
  constructor() {
    this.hooks = {
      get: new import_lite_tapable3.AsyncSeriesBailHook(["identifier", "etag", "gotHandlers"]),
      store: new import_lite_tapable3.AsyncParallelHook(["identifier", "etag", "data"]),
      storeBuildDependencies: new import_lite_tapable3.AsyncParallelHook(["dependencies"]),
      beginIdle: new import_lite_tapable3.SyncHook([]),
      endIdle: new import_lite_tapable3.AsyncParallelHook([]),
      shutdown: new import_lite_tapable3.AsyncParallelHook([])
    };
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param callback signals when the value is retrieved
   * @returns
   */
  get(identifier, etag, callback) {
    const gotHandlers = [];
    this.hooks.get.callAsync(identifier, etag, gotHandlers, (err, res) => {
      if (err) {
        callback(makeWebpackError(err, "Cache.hooks.get"));
        return;
      }
      let result2 = res;
      if (result2 === null) {
        result2 = void 0;
      }
      if (gotHandlers.length > 1) {
        const innerCallback = needCalls(
          gotHandlers.length,
          () => callback(null, result2)
        );
        for (const gotHandler of gotHandlers) {
          gotHandler(result2, innerCallback);
        }
      } else if (gotHandlers.length === 1) {
        gotHandlers[0](result2, () => callback(null, result2));
      } else {
        callback(null, result2);
      }
    });
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param data the value to store
   * @param callback signals when the value is stored
   * @returns
   */
  store(identifier, etag, data, callback) {
    this.hooks.store.callAsync(
      identifier,
      etag,
      data,
      makeWebpackErrorCallback(callback, "Cache.hooks.store")
    );
  }
  /**
   * After this method has succeeded the cache can only be restored when build dependencies are
   * @param dependencies list of all build dependencies
   * @param callback signals when the dependencies are stored
   * @returns
   */
  storeBuildDependencies(dependencies2, callback) {
    this.hooks.storeBuildDependencies.callAsync(
      dependencies2,
      makeWebpackErrorCallback(callback, "Cache.hooks.storeBuildDependencies")
    );
  }
  beginIdle() {
    this.hooks.beginIdle.call();
  }
  /**
   * @param callback signals when the call finishes
   * @returns
   */
  endIdle(callback) {
    this.hooks.endIdle.callAsync(
      makeWebpackErrorCallback(callback, "Cache.hooks.endIdle")
    );
  }
  /**
   * @param callback signals when the call finishes
   * @returns
   */
  shutdown(callback) {
    this.hooks.shutdown.callAsync(
      makeWebpackErrorCallback(callback, "Cache.hooks.shutdown")
    );
  }
};
Cache.STAGE_DISK = 10;
Cache.STAGE_MEMORY = -10;
Cache.STAGE_DEFAULT = 0;
Cache.STAGE_NETWORK = 20;
var Cache_default = Cache;

// src/lib/CacheFacade.ts
var import_neo_async = __toESM(require_async());

// src/util/createHash.ts
var import_node_crypto = __toESM(require("crypto"));

// src/lib/AbstractMethodError.ts
var CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;
function createMessage(method) {
  return `Abstract method${method ? ` ${method}` : ""}. Must be overridden.`;
}
var Message = class extends Error {
  constructor() {
    super();
    this.stack = void 0;
    Error.captureStackTrace(this);
    const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);
    this.message = (match == null ? void 0 : match[1]) ? createMessage(match[1]) : createMessage();
  }
};
var AbstractMethodError = class extends WebpackError_default {
  constructor() {
    super(new Message().message);
    this.name = "AbstractMethodError";
  }
};
var AbstractMethodError_default = AbstractMethodError;

// src/util/hash/index.ts
var Hash = class {
  /* istanbul ignore next */
  /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
   * @abstract
   * @param data data
   * @param inputEncoding data encoding
   * @returns updated hash
   */
  update(data, inputEncoding) {
    throw new AbstractMethodError_default();
  }
  /* istanbul ignore next */
  /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
   * @abstract
   * @param encoding encoding of the return value
   * @returns  digest
   */
  digest(encoding) {
    throw new AbstractMethodError_default();
  }
};

// src/util/hash/wasm-hash.ts
var MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;
var WasmHash = class {
  /**
   * @param instance wasm instance
   * @param instancesPool pool of instances
   * @param chunkSize size of data chunks passed to wasm
   * @param digestSize size of digest returned by wasm
   */
  constructor(instance, instancesPool, chunkSize, digestSize) {
    const exports2 = instance.exports;
    exports2.init();
    this.exports = exports2;
    this.mem = Buffer.from(exports2.memory.buffer, 0, 65536);
    this.buffered = 0;
    this.instancesPool = instancesPool;
    this.chunkSize = chunkSize;
    this.digestSize = digestSize;
  }
  reset() {
    this.buffered = 0;
    this.exports.init();
  }
  /**
   * @param data data
   * @param encoding encoding
   * @returns itself
   */
  update(data, encoding) {
    if (typeof data === "string") {
      let normalizedData = data;
      while (normalizedData.length > MAX_SHORT_STRING) {
        this._updateWithShortString(
          normalizedData.slice(0, MAX_SHORT_STRING),
          encoding
        );
        normalizedData = normalizedData.slice(MAX_SHORT_STRING);
      }
      this._updateWithShortString(normalizedData, encoding);
      return this;
    }
    this._updateWithBuffer(data);
    return this;
  }
  /**
   * @param {string} data data
   * @param {BufferEncoding=} encoding encoding
   * @returns {void}
   */
  _updateWithShortString(data, encoding) {
    const { exports: exports2, buffered, mem, chunkSize } = this;
    let endPos;
    if (data.length < 70) {
      if (!encoding || encoding === "utf-8" || encoding === "utf8") {
        endPos = buffered;
        for (let i = 0; i < data.length; i++) {
          const cc = data.charCodeAt(i);
          if (cc < 128) mem[endPos++] = cc;
          else if (cc < 2048) {
            mem[endPos] = cc >> 6 | 192;
            mem[endPos + 1] = cc & 63 | 128;
            endPos += 2;
          } else {
            endPos += mem.write(data.slice(i), endPos, encoding);
            break;
          }
        }
      } else if (encoding === "latin1") {
        endPos = buffered;
        for (let i = 0; i < data.length; i++) {
          const cc = data.charCodeAt(i);
          mem[endPos++] = cc;
        }
      } else {
        endPos = buffered + mem.write(data, buffered, encoding);
      }
    } else {
      endPos = buffered + mem.write(data, buffered, encoding);
    }
    if (endPos < chunkSize) {
      this.buffered = endPos;
    } else {
      const l = endPos & ~(this.chunkSize - 1);
      exports2.update(l);
      const newBuffered = endPos - l;
      this.buffered = newBuffered;
      if (newBuffered > 0) mem.copyWithin(0, l, endPos);
    }
  }
  /**
   * @param data data
   * @returns
   */
  _updateWithBuffer(data) {
    const { exports: exports2, buffered, mem } = this;
    const length = data.length;
    if (buffered + length < this.chunkSize) {
      data.copy(mem, buffered, 0, length);
      this.buffered += length;
    } else {
      const l = buffered + length & ~(this.chunkSize - 1);
      if (l > 65536) {
        let i = 65536 - buffered;
        data.copy(mem, buffered, 0, i);
        exports2.update(65536);
        const stop = l - buffered - 65536;
        while (i < stop) {
          data.copy(mem, 0, i, i + 65536);
          exports2.update(65536);
          i += 65536;
        }
        data.copy(mem, 0, i, l - buffered);
        exports2.update(l - buffered - i);
      } else {
        data.copy(mem, buffered, 0, l - buffered);
        exports2.update(l);
      }
      const newBuffered = length + buffered - l;
      this.buffered = newBuffered;
      if (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);
    }
  }
  digest(type) {
    const { exports: exports2, buffered, mem, digestSize } = this;
    exports2.final(buffered);
    this.instancesPool.push(this);
    const hex = mem.toString("latin1", 0, digestSize);
    if (type === "hex") return hex;
    if (type === "binary" || !type) return Buffer.from(hex, "hex");
    return Buffer.from(hex, "hex").toString(type);
  }
};
var create = (wasmModule, instancesPool, chunkSize, digestSize) => {
  if (instancesPool.length > 0) {
    const old = instancesPool.pop();
    old.reset();
    return old;
  }
  return new WasmHash(
    new WebAssembly.Instance(wasmModule),
    instancesPool,
    chunkSize,
    digestSize
  );
};
var wasm_hash_default = create;

// src/util/hash/BatchedHash.ts
var BatchedHash = class extends Hash {
  constructor(hash) {
    super();
    this.string = void 0;
    this.encoding = void 0;
    this.hash = hash;
  }
  /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
   * @param data data
   * @param inputEncoding data encoding
   * @returns updated hash
   */
  update(data, inputEncoding) {
    if (this.string !== void 0) {
      if (typeof data === "string" && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) {
        this.string += data;
        return this;
      }
      this.hash.update(this.string, this.encoding);
      this.string = void 0;
    }
    if (typeof data === "string") {
      if (data.length < MAX_SHORT_STRING && // base64 encoding is not valid since it may contain padding chars
      (!inputEncoding || !inputEncoding.startsWith("ba"))) {
        this.string = data;
        this.encoding = inputEncoding;
      } else {
        this.hash.update(data, inputEncoding);
      }
    } else {
      this.hash.update(data);
    }
    return this;
  }
  /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
   * @param encoding encoding of the return value
   * @returns digest
   */
  digest(encoding) {
    if (this.string !== void 0) {
      this.hash.update(this.string, this.encoding);
    }
    return this.hash.digest(encoding);
  }
};

// src/util/hash/md4.ts
var createMd4;
var md4_default = () => {
  if (!createMd4) {
    const md4 = new WebAssembly.Module(
      Buffer.from(
        // 2156 bytes
        "AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqLEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvSCgEZfyMBIQUjAiECIwMhAyMEIQQDQCAAIAFLBEAgASgCJCISIAEoAiAiEyABKAIcIgkgASgCGCIIIAEoAhQiByABKAIQIg4gASgCDCIGIAEoAggiDyABKAIEIhAgASgCACIRIAMgBHMgAnEgBHMgBWpqQQN3IgogAiADc3EgA3MgBGpqQQd3IgsgAiAKc3EgAnMgA2pqQQt3IgwgCiALc3EgCnMgAmpqQRN3Ig0gCyAMc3EgC3MgCmpqQQN3IgogDCANc3EgDHMgC2pqQQd3IgsgCiANc3EgDXMgDGpqQQt3IgwgCiALc3EgCnMgDWpqQRN3Ig0gCyAMc3EgC3MgCmpqQQN3IhQgDCANc3EgDHMgC2pqQQd3IRUgASgCLCILIAEoAigiCiAMIA0gDSAUcyAVcXNqakELdyIWIBQgFXNxIBRzIA1qakETdyEXIAEoAjQiGCABKAIwIhkgFSAWcyAXcSAVcyAUampBA3ciFCAWIBdzcSAWcyAVampBB3chFSABKAI8Ig0gASgCOCIMIBQgF3MgFXEgF3MgFmpqQQt3IhYgFCAVc3EgFHMgF2pqQRN3IRcgEyAOIBEgFCAVIBZyIBdxIBUgFnFyampBmfOJ1AVqQQN3IhQgFiAXcnEgFiAXcXIgFWpqQZnzidQFakEFdyIVIBQgF3JxIBQgF3FyIBZqakGZ84nUBWpBCXchFiAPIBggEiAWIAcgFSAQIBQgGSAUIBVyIBZxIBQgFXFyIBdqakGZ84nUBWpBDXciFCAVIBZycSAVIBZxcmpqQZnzidQFakEDdyIVIBQgFnJxIBQgFnFyampBmfOJ1AVqQQV3IhcgFCAVcnEgFCAVcXJqakGZ84nUBWpBCXciFiAVIBdycSAVIBdxciAUampBmfOJ1AVqQQ13IhQgFiAXcnEgFiAXcXIgFWpqQZnzidQFakEDdyEVIBEgBiAVIAwgFCAKIBYgCCAUIBZyIBVxIBQgFnFyIBdqakGZ84nUBWpBBXciFyAUIBVycSAUIBVxcmpqQZnzidQFakEJdyIWIBUgF3JxIBUgF3FyampBmfOJ1AVqQQ13IhQgFiAXcnEgFiAXcXJqakGZ84nUBWpBA3ciFSALIBYgCSAUIBZyIBVxIBQgFnFyIBdqakGZ84nUBWpBBXciFiAUIBVycSAUIBVxcmpqQZnzidQFakEJdyIXIA0gFSAWciAXcSAVIBZxciAUampBmfOJ1AVqQQ13IhRzIBZzampBodfn9gZqQQN3IREgByAIIA4gFCARIBcgESAUc3MgFmogE2pBodfn9gZqQQl3IhNzcyAXampBodfn9gZqQQt3Ig4gDyARIBMgDiARIA4gE3NzIBRqIBlqQaHX5/YGakEPdyIRc3NqakGh1+f2BmpBA3ciDyAOIA8gEXNzIBNqIApqQaHX5/YGakEJdyIKcyARc2pqQaHX5/YGakELdyIIIBAgDyAKIAggDCAPIAggCnNzIBFqakGh1+f2BmpBD3ciDHNzampBodfn9gZqQQN3Ig4gEiAIIAwgDnNzIApqakGh1+f2BmpBCXciCHMgDHNqakGh1+f2BmpBC3chByAFIAYgCCAHIBggDiAHIAhzcyAMampBodfn9gZqQQ93IgpzcyAOampBodfn9gZqQQN3IgZqIQUgDSAGIAkgByAGIAsgByAGIApzcyAIampBodfn9gZqQQl3IgdzIApzampBodfn9gZqQQt3IgYgB3NzIApqakGh1+f2BmpBD3cgAmohAiADIAZqIQMgBCAHaiEEIAFBQGshAQwBCwsgBSQBIAIkAiADJAMgBCQECw0AIAAQASAAIwBqJAAL/wQCA38BfiAAIwBqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=",
        "base64"
      )
    );
    createMd4 = wasm_hash_default.bind(null, md4, [], 64, 32);
  }
  return createMd4();
};

// src/util/hash/xxhash64.ts
var createXxhash64;
var xxhash64_default = () => {
  if (!createXxhash64) {
    const xxhash64 = new WebAssembly.Module(
      Buffer.from(
        // 1170 bytes
        "AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrIIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqAYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEAgAiABNQIAQoeVr6+Ytt6bnn9+hUIXiULP1tO+0ser2UJ+Qvnz3fGZ9pmrFnwhAiABQQRqIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAkIdiCAChUL5893xmfaZqxZ+IgJCIIggAoUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL",
        "base64"
      )
    );
    createXxhash64 = wasm_hash_default.bind(null, xxhash64, [], 32, 16);
  }
  return createXxhash64();
};

// src/util/createHash.ts
var BULK_SIZE = 2e3;
var digestCaches = {};
var BulkUpdateDecorator = class extends Hash {
  /**
   * @param hashOrFactory function to create a hash
   * @param hashKey key for caching
   */
  constructor(hashOrFactory, hashKey) {
    super();
    this.hashKey = hashKey;
    if (typeof hashOrFactory === "function") {
      this.hashFactory = hashOrFactory;
      this.hash = void 0;
    } else {
      this.hashFactory = void 0;
      this.hash = hashOrFactory;
    }
    this.buffer = "";
  }
  /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
   * @param data data
   * @param inputEncoding data encoding
   * @returns updated hash
   */
  update(data, inputEncoding) {
    if (inputEncoding !== void 0 || typeof data !== "string" || data.length > BULK_SIZE) {
      if (this.hash === void 0) this.hash = this.hashFactory();
      if (this.buffer.length > 0) {
        this.hash.update(this.buffer);
        this.buffer = "";
      }
      this.hash.update(data, inputEncoding);
    } else {
      this.buffer += data;
      if (this.buffer.length > BULK_SIZE) {
        if (this.hash === void 0) this.hash = this.hashFactory();
        this.hash.update(this.buffer);
        this.buffer = "";
      }
    }
    return this;
  }
  /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
   * @param encoding encoding of the return value
   * @returns digest
   */
  digest(encoding) {
    let digestCache;
    const buffer = this.buffer;
    if (this.hash === void 0) {
      const cacheKey = `${this.hashKey}-${encoding}`;
      digestCache = digestCaches[cacheKey];
      if (digestCache === void 0) {
        digestCache = digestCaches[cacheKey] = /* @__PURE__ */ new Map();
      }
      const cacheEntry = digestCache.get(buffer);
      if (cacheEntry !== void 0) return cacheEntry;
      this.hash = this.hashFactory();
    }
    if (buffer.length > 0) {
      this.hash.update(buffer);
    }
    const digestResult = this.hash.digest(encoding);
    const result2 = typeof digestResult === "string" ? digestResult : digestResult.toString();
    if (digestCache !== void 0) {
      digestCache.set(buffer, result2);
    }
    return result2;
  }
};
var DebugHash = class extends Hash {
  constructor() {
    super();
    this.string = "";
  }
  /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
   * @param data data
   * @param _inputEncoding data encoding
   * @returns updated hash
   */
  update(data, _inputEncoding) {
    var _a;
    let normalizedData;
    if (typeof data !== "string") {
      normalizedData = data.toString("utf-8");
    } else {
      normalizedData = data;
    }
    if (normalizedData.startsWith("debug-digest-")) {
      normalizedData = Buffer.from(
        normalizedData.slice("debug-digest-".length),
        "hex"
      ).toString();
    }
    this.string += `[${normalizedData}](${(_a = new Error().stack) == null ? void 0 : _a.split("\n", 3)[2]})
`;
    return this;
  }
  /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
   * @param encoding encoding of the return value
   * @returns digest
   */
  digest(encoding) {
    return `debug-digest-${Buffer.from(this.string).toString(encoding || "hex")}`;
  }
};
var createHash = (algorithm) => {
  if (typeof algorithm === "function") {
    return new BulkUpdateDecorator(() => new algorithm());
  }
  switch (algorithm) {
    // TODO add non-cryptographic algorithm here
    case "debug":
      return new DebugHash();
    case "xxhash64":
      return new BatchedHash(xxhash64_default());
    case "md4":
      return new BatchedHash(md4_default());
    case "native-md4":
      return new BulkUpdateDecorator(() => import_node_crypto.default.createHash("md4"), "md4");
    default:
      return new BulkUpdateDecorator(
        () => import_node_crypto.default.createHash(algorithm),
        algorithm
      );
  }
};

// src/lib/cache/getLazyHashedEtag.ts
var LazyHashedEtag = class {
  /**
   * @param obj object with updateHash method
   * @param hashFunction the hash function to use
   */
  constructor(obj, hashFunction2 = "md4") {
    this._obj = obj;
    this._hash = void 0;
    this._hashFunction = hashFunction2;
  }
  /**
   * @returns hash of object
   */
  toString() {
    if (this._hash === void 0) {
      const hash = createHash(this._hashFunction);
      this._obj.updateHash(hash);
      this._hash = hash.digest("base64");
    }
    return this._hash;
  }
};
var mapStrings = /* @__PURE__ */ new Map();
var mapObjects = /* @__PURE__ */ new WeakMap();
var getter = (obj, hashFunction2 = "md4") => {
  let innerMap;
  if (typeof hashFunction2 === "string") {
    innerMap = mapStrings.get(hashFunction2);
    if (innerMap === void 0) {
      const newHash2 = new LazyHashedEtag(obj, hashFunction2);
      innerMap = /* @__PURE__ */ new WeakMap();
      innerMap.set(obj, newHash2);
      mapStrings.set(hashFunction2, innerMap);
      return newHash2;
    }
  } else {
    innerMap = mapObjects.get(hashFunction2);
    if (innerMap === void 0) {
      const newHash2 = new LazyHashedEtag(obj, hashFunction2);
      innerMap = /* @__PURE__ */ new WeakMap();
      innerMap.set(obj, newHash2);
      mapObjects.set(hashFunction2, innerMap);
      return newHash2;
    }
  }
  const hash = innerMap.get(obj);
  if (hash !== void 0) return hash;
  const newHash = new LazyHashedEtag(obj, hashFunction2);
  innerMap.set(obj, newHash);
  return newHash;
};

// src/lib/cache/mergeEtags.ts
var MergedEtag = class {
  /**
   * @param a first
   * @param b second
   */
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
  toString() {
    return `${this.a.toString()}|${this.b.toString()}`;
  }
};
var dualObjectMap = /* @__PURE__ */ new WeakMap();
var objectStringMap = /* @__PURE__ */ new WeakMap();
var mergeEtags = (first, second) => {
  let a = first;
  let b = second;
  if (typeof a === "string") {
    if (typeof b === "string") {
      return `${a}|${b}`;
    }
    const temp = b;
    b = a;
    a = temp;
  } else {
    if (typeof b !== "string") {
      let map2 = dualObjectMap.get(a);
      if (map2 === void 0) {
        dualObjectMap.set(a, map2 = /* @__PURE__ */ new WeakMap());
      }
      const mergedEtag2 = map2.get(b);
      if (mergedEtag2 === void 0) {
        const newMergedEtag = new MergedEtag(a, b);
        map2.set(b, newMergedEtag);
        return newMergedEtag;
      }
      return mergedEtag2;
    }
  }
  let map = objectStringMap.get(a);
  if (map === void 0) {
    objectStringMap.set(a, map = /* @__PURE__ */ new Map());
  }
  const mergedEtag = map.get(b);
  if (mergedEtag === void 0) {
    const newMergedEtag = new MergedEtag(a, b);
    map.set(b, newMergedEtag);
    return newMergedEtag;
  }
  return mergedEtag;
};

// src/lib/CacheFacade.ts
var ItemCacheFacade = class {
  /**
   * @param cache the root cache
   * @param name the child cache item name
   * @param etag the etag
   * @returns
   */
  constructor(cache, name2, etag) {
    this._cache = cache;
    this._name = name2;
    this._etag = etag;
  }
  /**
   * @param callback signals when the value is retrieved
   * @returns
   */
  get(callback) {
    this._cache.get(this._name, this._etag, callback);
  }
  /**
   * @returns promise with the data
   */
  getPromise() {
    return new Promise((resolve2, reject) => {
      this._cache.get(this._name, this._etag, (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve2(data);
        }
      });
    });
  }
  /**
   * @param data the value to store
   * @param callback signals when the value is stored
   * @returns
   */
  store(data, callback) {
    this._cache.store(this._name, this._etag, data, callback);
  }
  /**
   * @param data the value to store
   * @returns promise signals when the value is stored
   */
  storePromise(data) {
    return new Promise((resolve2, reject) => {
      this._cache.store(this._name, this._etag, data, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve2();
        }
      });
    });
  }
  /**
   * @param computer function to compute the value if not cached
   * @param callback signals when the value is retrieved
   * @returns
   */
  provide(computer, callback) {
    this.get((err, cacheEntry) => {
      if (err) return callback(err);
      if (cacheEntry !== void 0) return cacheEntry;
      computer((err2, result2) => {
        if (err2) return callback(err2);
        this.store(result2, (err3) => {
          if (err3) return callback(err3);
          callback(null, result2);
        });
      });
    });
  }
  /**
   * @param computer function to compute the value if not cached
   * @returns promise with the data
   */
  async providePromise(computer) {
    const cacheEntry = await this.getPromise();
    if (cacheEntry !== void 0) return cacheEntry;
    const result2 = await computer();
    await this.storePromise(result2);
    return result2;
  }
};
var CacheFacade = class _CacheFacade {
  /**
   * @param cache the root cache
   * @param name the child cache name
   * @param hashFunction the hash function to use
   */
  constructor(cache, name2, hashFunction2) {
    this._cache = cache;
    this._name = name2;
    this._hashFunction = hashFunction2;
  }
  /**
   * @param name the child cache name#
   * @returns child cache
   */
  getChildCache(name2) {
    return new _CacheFacade(
      this._cache,
      `${this._name}|${name2}`,
      this._hashFunction
    );
  }
  /**
   * @param identifier the cache identifier
   * @param  etag the etag
   * @returns item cache
   */
  getItemCache(identifier, etag) {
    return new ItemCacheFacade(
      this._cache,
      `${this._name}|${identifier}`,
      etag
    );
  }
  /**
   * @param obj an hashable object
   * @returns an etag that is lazy hashed
   */
  getLazyHashedEtag(obj) {
    return getter(obj, this._hashFunction);
  }
  /**
   * @param a an etag
   * @param b another etag
   * @returns an etag that represents both
   */
  mergeEtags(a, b) {
    return mergeEtags(a, b);
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param callback signals when the value is retrieved
   * @returns
   */
  get(identifier, etag, callback) {
    this._cache.get(`${this._name}|${identifier}`, etag, callback);
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @returns promise with the data
   */
  getPromise(identifier, etag) {
    return new Promise((resolve2, reject) => {
      this._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve2(data);
        }
      });
    });
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param data the value to store
   * @param callback signals when the value is stored
   * @returns
   */
  store(identifier, etag, data, callback) {
    this._cache.store(`${this._name}|${identifier}`, etag, data, callback);
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param data the value to store
   * @returns promise signals when the value is stored
   */
  storePromise(identifier, etag, data) {
    return new Promise((resolve2, reject) => {
      this._cache.store(`${this._name}|${identifier}`, etag, data, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve2();
        }
      });
    });
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param computer function to compute the value if not cached
   * @param callback signals when the value is retrieved
   * @returns
   */
  provide(identifier, etag, computer, callback) {
    this.get(identifier, etag, (err, cacheEntry) => {
      if (err) return callback(err);
      if (cacheEntry !== void 0) return cacheEntry;
      computer((err2, result2) => {
        if (err2) return callback(err2);
        this.store(identifier, etag, result2, (err3) => {
          if (err3) return callback(err3);
          callback(null, result2);
        });
      });
    });
  }
  /**
   * @param identifier the cache identifier
   * @param etag the etag
   * @param computer function to compute the value if not cached
   * @returns promise with the data
   */
  async providePromise(identifier, etag, computer) {
    const cacheEntry = await this.getPromise(identifier, etag);
    if (cacheEntry !== void 0) return cacheEntry;
    const result2 = await computer();
    await this.storePromise(identifier, etag, result2);
    return result2;
  }
};
var CacheFacade_default = CacheFacade;

// src/RuntimeGlobals.ts
var REVERSE_RUNTIME_GLOBALS = /* @__PURE__ */ new Map();
function __from_binding_runtime_globals(runtimeRequirements) {
  const res = /* @__PURE__ */ new Set();
  for (const flag of runtimeRequirements.value) {
    if (flag in RuntimeGlobals) {
      res.add(RuntimeGlobals[flag]);
    } else {
      res.add(flag);
    }
  }
  return res;
}
function __to_binding_runtime_globals(runtimeRequirements) {
  const res = {
    value: []
  };
  for (const flag of Array.from(runtimeRequirements)) {
    const item = REVERSE_RUNTIME_GLOBALS.get(flag);
    if (typeof item === "string") {
      res.value.push(item);
    } else {
      res.value.push(flag);
    }
  }
  return res;
}
var RuntimeGlobals = {
  /**
   * the internal require function
   */
  require: "__webpack_require__",
  /**
   * access to properties of the internal require function/object
   */
  requireScope: "__webpack_require__.*",
  /**
   * the internal exports object
   */
  exports: "__webpack_exports__",
  /**
   * top-level this need to be the exports object
   */
  thisAsExports: "top-level-this-exports",
  /**
   * runtime need to return the exports of the last entry module
   */
  returnExportsFromRuntime: "return-exports-from-runtime",
  /**
   * the internal module object
   */
  module: "module",
  /**
   * the internal module object
   */
  moduleId: "module.id",
  /**
   * the internal module object
   */
  moduleLoaded: "module.loaded",
  /**
   * the bundle public path
   */
  publicPath: "__webpack_require__.p",
  /**
   * the module id of the entry point
   */
  entryModuleId: "__webpack_require__.s",
  /**
   * the module cache
   */
  moduleCache: "__webpack_require__.c",
  /**
   * the module functions
   */
  moduleFactories: "__webpack_require__.m",
  /**
   * the module functions, with only write access
   */
  moduleFactoriesAddOnly: "__webpack_require__.m (add only)",
  /**
   * the chunk ensure function
   */
  ensureChunk: "__webpack_require__.e",
  /**
   * an object with handlers to ensure a chunk
   */
  ensureChunkHandlers: "__webpack_require__.f",
  /**
   * a runtime requirement if ensureChunkHandlers should include loading of chunk needed for entries
   */
  ensureChunkIncludeEntries: "__webpack_require__.f (include entries)",
  /**
   * the chunk prefetch function
   */
  prefetchChunk: "__webpack_require__.E",
  /**
   * an object with handlers to prefetch a chunk
   */
  prefetchChunkHandlers: "__webpack_require__.F",
  /**
   * the chunk preload function
   */
  preloadChunk: "__webpack_require__.G",
  /**
   * an object with handlers to preload a chunk
   */
  preloadChunkHandlers: "__webpack_require__.H",
  /**
   * the exported property define getters function
   */
  definePropertyGetters: "__webpack_require__.d",
  /**
   * define compatibility on export
   */
  makeNamespaceObject: "__webpack_require__.r",
  /**
   * create a fake namespace object
   */
  createFakeNamespaceObject: "__webpack_require__.t",
  /**
   * compatibility get default export
   */
  compatGetDefaultExport: "__webpack_require__.n",
  /**
   * harmony module decorator
   */
  harmonyModuleDecorator: "__webpack_require__.hmd",
  /**
   * node.js module decorator
   */
  nodeModuleDecorator: "__webpack_require__.nmd",
  /**
   * the webpack hash
   */
  getFullHash: "__webpack_require__.h",
  /**
   * an object containing all installed WebAssembly.Instance export objects keyed by module id
   */
  wasmInstances: "__webpack_require__.w",
  /**
   * instantiate a wasm instance from module exports object, id, hash and importsObject
   */
  instantiateWasm: "__webpack_require__.v",
  /**
   * the uncaught error handler for the webpack runtime
   */
  uncaughtErrorHandler: "__webpack_require__.oe",
  /**
   * the script nonce
   */
  scriptNonce: "__webpack_require__.nc",
  /**
   * function to load a script tag.
   * Arguments: (url: string, done: (event) =\> void), key?: string | number, chunkId?: string | number) =\> void
   * done function is called when loading has finished or timeout occurred.
   * It will attach to existing script tags with data-webpack == uniqueName + ":" + key or src == url.
   */
  loadScript: "__webpack_require__.l",
  /**
   * function to promote a string to a TrustedScript using webpack's Trusted
   * Types policy
   * Arguments: (script: string) =\> TrustedScript
   */
  createScript: "__webpack_require__.ts",
  /**
   * function to promote a string to a TrustedScriptURL using webpack's Trusted
   * Types policy
   * Arguments: (url: string) =\> TrustedScriptURL
   */
  createScriptUrl: "__webpack_require__.tu",
  /**
   * function to return webpack's Trusted Types policy
   * Arguments: () =\> TrustedTypePolicy
   */
  getTrustedTypesPolicy: "__webpack_require__.tt",
  /**
   * a flag when a chunk has a fetch priority
   */
  hasFetchPriority: "has fetch priority",
  /**
   * the chunk name of the chunk with the runtime
   */
  chunkName: "__webpack_require__.cn",
  /**
   * the runtime id of the current runtime
   */
  runtimeId: "__webpack_require__.j",
  /**
   * the filename of the script part of the chunk
   */
  getChunkScriptFilename: "__webpack_require__.u",
  /**
   * the filename of the css part of the chunk
   */
  getChunkCssFilename: "__webpack_require__.k",
  /**
   * a flag when a module/chunk/tree has css modules
   */
  hasCssModules: "has css modules",
  /**
   * the filename of the script part of the hot update chunk
   */
  getChunkUpdateScriptFilename: "__webpack_require__.hu",
  /**
   * the filename of the css part of the hot update chunk
   */
  getChunkUpdateCssFilename: "__webpack_require__.hk",
  /**
   * startup signal from runtime
   * This will be called when the runtime chunk has been loaded.
   */
  startup: "__webpack_require__.x",
  /**
   * @deprecated
   * creating a default startup function with the entry modules
   */
  startupNoDefault: "__webpack_require__.x (no default handler)",
  /**
   * startup signal from runtime but only used to add logic after the startup
   */
  startupOnlyAfter: "__webpack_require__.x (only after)",
  /**
   * startup signal from runtime but only used to add sync logic before the startup
   */
  startupOnlyBefore: "__webpack_require__.x (only before)",
  /**
   * global callback functions for installing chunks
   */
  chunkCallback: "webpackChunk",
  /**
   * method to startup an entrypoint with needed chunks.
   * Signature: (moduleId: Id, chunkIds: Id[]) =\> any.
   * Returns the exports of the module or a Promise
   */
  startupEntrypoint: "__webpack_require__.X",
  /**
   * register deferred code, which will run when certain
   * chunks are loaded.
   * Signature: (chunkIds: Id[], fn: () =\> any, priority: int \>= 0 = 0) =\> any
   * Returned value will be returned directly when all chunks are already loaded
   * When (priority & 1) it will wait for all other handlers with lower priority to
   * be executed before itself is executed
   */
  onChunksLoaded: "__webpack_require__.O",
  /**
   * method to install a chunk that was loaded somehow
   * Signature: (\{ id, ids, modules, runtime \}) =\> void
   */
  externalInstallChunk: "__webpack_require__.C",
  /**
   * interceptor for module executions
   */
  interceptModuleExecution: "__webpack_require__.i",
  /**
   * the global object
   */
  global: "__webpack_require__.g",
  /**
   * an object with all share scopes
   */
  shareScopeMap: "__webpack_require__.S",
  /**
   * The sharing init sequence function (only runs once per share scope).
   * Has one argument, the name of the share scope.
   * Creates a share scope if not existing
   */
  initializeSharing: "__webpack_require__.I",
  /**
   * The current scope when getting a module from a remote
   */
  currentRemoteGetScope: "__webpack_require__.R",
  /**
   * the filename of the HMR manifest
   */
  getUpdateManifestFilename: "__webpack_require__.hmrF",
  /**
   * function downloading the update manifest
   */
  hmrDownloadManifest: "__webpack_require__.hmrM",
  /**
   * array with handler functions to download chunk updates
   */
  hmrDownloadUpdateHandlers: "__webpack_require__.hmrC",
  /**
   * object with all hmr module data for all modules
   */
  hmrModuleData: "__webpack_require__.hmrD",
  /**
   * array with handler functions when a module should be invalidated
   */
  hmrInvalidateModuleHandlers: "__webpack_require__.hmrI",
  /**
   * the prefix for storing state of runtime modules when hmr is enabled
   */
  hmrRuntimeStatePrefix: "__webpack_require__.hmrS",
  /**
   * the AMD define function
   */
  amdDefine: "__webpack_require__.amdD",
  /**
   * the AMD options
   */
  amdOptions: "__webpack_require__.amdO",
  /**
   * the System polyfill object
   */
  system: "__webpack_require__.System",
  /**
   * the shorthand for Object.prototype.hasOwnProperty
   * using of it decreases the compiled bundle size
   */
  hasOwnProperty: "__webpack_require__.o",
  /**
   * the System.register context object
   */
  systemContext: "__webpack_require__.y",
  /**
   * the baseURI of current document
   */
  baseURI: "__webpack_require__.b",
  /**
   * a RelativeURL class when relative URLs are used
   */
  relativeUrl: "__webpack_require__.U",
  /**
   * Creates an async module. The body function must be a async function.
   * "module.exports" will be decorated with an AsyncModulePromise.
   * The body function will be called.
   * To handle async dependencies correctly do this: "([a, b, c] = await handleDependencies([a, b, c]));".
   * If "hasAwaitAfterDependencies" is truthy, "handleDependencies()" must be called at the end of the body function.
   * Signature: function(
   * module: Module,
   * body: (handleDependencies: (deps: AsyncModulePromise[]) =\> Promise\<any[]\> & () =\> void,
   * hasAwaitAfterDependencies?: boolean
   * ) =\> void
   */
  asyncModule: "__webpack_require__.a"
};
for (const entry2 of Object.entries(RuntimeGlobals)) {
  REVERSE_RUNTIME_GLOBALS.set(entry2[1], entry2[0]);
}

// src/builtin-plugin/base.ts
var HOOKS_CAN_NOT_INHERENT_FROM_PARENT = [
  "make",
  "compile",
  "emit",
  "afterEmit",
  "invalid",
  "done",
  "thisCompilation"
];
function canInherentFromParent(affectedHooks) {
  if (typeof affectedHooks === "undefined") {
    return false;
  }
  return !HOOKS_CAN_NOT_INHERENT_FROM_PARENT.includes(affectedHooks);
}
var RspackBuiltinPlugin = class {
  apply(compiler) {
    const raw = this.raw(compiler);
    if (raw) {
      raw.canInherentFromParent = canInherentFromParent(this.affectedHooks);
      compiler.__internal__registerBuiltinPlugin(raw);
    }
  }
};
function createBuiltinPlugin(name2, options) {
  return {
    name: name2,
    options: options ?? false
    // undefined or null will cause napi error, so false for fallback
  };
}
function create2(name2, resolve2, affectedHooks) {
  class Plugin extends RspackBuiltinPlugin {
    constructor(...args) {
      super();
      this.name = name2;
      this.affectedHooks = affectedHooks;
      this._args = args;
    }
    raw(compiler) {
      return createBuiltinPlugin(name2, resolve2.apply(compiler, this._args));
    }
  }
  Object.defineProperty(Plugin, "name", { value: name2 });
  return Plugin;
}

// src/builtin-plugin/APIPlugin.ts
var import_binding7 = require("@rspack/binding");
var APIPlugin = create2(import_binding7.BuiltinPluginName.APIPlugin, () => {
});

// src/builtin-plugin/ArrayPushCallbackChunkFormatPlugin.ts
var import_binding8 = require("@rspack/binding");
var ArrayPushCallbackChunkFormatPlugin = create2(
  import_binding8.BuiltinPluginName.ArrayPushCallbackChunkFormatPlugin,
  () => {
  }
);

// src/builtin-plugin/AssetModulesPlugin.ts
var import_binding9 = require("@rspack/binding");
var AssetModulesPlugin = create2(
  import_binding9.BuiltinPluginName.AssetModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/AsyncWebAssemblyModulesPlugin.ts
var import_binding10 = require("@rspack/binding");
var AsyncWebAssemblyModulesPlugin = create2(
  import_binding10.BuiltinPluginName.AsyncWebAssemblyModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/BannerPlugin.ts
var import_binding11 = require("@rspack/binding");
var BannerPlugin = create2(
  import_binding11.BuiltinPluginName.BannerPlugin,
  (args) => {
    if (typeof args === "string" || typeof args === "function") {
      return {
        banner: args
      };
    }
    return {
      banner: args.banner,
      entryOnly: args.entryOnly,
      footer: args.footer,
      raw: args.raw,
      test: args.test,
      stage: args.stage,
      include: args.include,
      exclude: args.exclude
    };
  }
);

// src/builtin-plugin/BundlerInfoRspackPlugin.ts
var import_binding12 = require("@rspack/binding");
var BundlerInfoRspackPlugin = create2(
  import_binding12.BuiltinPluginName.BundlerInfoRspackPlugin,
  (options) => {
    return {
      version: options.version || "unknown",
      bundler: options.bundler || "rspack",
      force: options.force ?? true
    };
  }
);

// src/builtin-plugin/ChunkPrefetchPreloadPlugin.ts
var import_binding13 = require("@rspack/binding");
var ChunkPrefetchPreloadPlugin = create2(
  import_binding13.BuiltinPluginName.ChunkPrefetchPreloadPlugin,
  () => {
  }
);

// src/builtin-plugin/CommonJsChunkFormatPlugin.ts
var import_binding14 = require("@rspack/binding");
var CommonJsChunkFormatPlugin = create2(
  import_binding14.BuiltinPluginName.CommonJsChunkFormatPlugin,
  () => {
  }
);

// src/builtin-plugin/CopyRspackPlugin.ts
var import_binding15 = require("@rspack/binding");
var CopyRspackPlugin = create2(
  import_binding15.BuiltinPluginName.CopyRspackPlugin,
  (copy) => {
    const ret = {
      patterns: []
    };
    ret.patterns = (copy.patterns || []).map((pattern) => {
      if (typeof pattern === "string") {
        pattern = { from: pattern };
      }
      pattern.force ??= false;
      pattern.noErrorOnMissing ??= false;
      pattern.priority ??= 0;
      pattern.globOptions ??= {};
      return pattern;
    });
    return ret;
  }
);

// src/builtin-plugin/css-extract/index.ts
var import_binding16 = require("@rspack/binding");
var import_node_path3 = require("path");

// src/builtin-plugin/css-extract/loader.ts
var import_node_path2 = __toESM(require("path"));

// src/builtin-plugin/css-extract/utils.ts
var import_node_path = __toESM(require("path"));
var PLUGIN_NAME = "css-extract-rspack-plugin";

// src/builtin-plugin/css-extract/loader.ts
var BASE_URI = "webpack://";
var MODULE_TYPE = "css/mini-extract";
var ABSOLUTE_PUBLIC_PATH = `${BASE_URI}/mini-css-extract-plugin/`;

// src/builtin-plugin/css-extract/index.ts
var DEFAULT_FILENAME = "[name].css";
var LOADER_PATH = (0, import_node_path3.join)(__dirname, "cssExtractLoader.js");
var CssExtractRspackPlugin = class {
  constructor(options) {
    this.options = options || {};
  }
  apply(compiler) {
    const { splitChunks } = compiler.options.optimization;
    if (splitChunks) {
      if (
        /** @type {string[]} */
        splitChunks.defaultSizeTypes.includes("...")
      ) {
        splitChunks.defaultSizeTypes.push(MODULE_TYPE);
      }
    }
    if (compiler.options.output.pathinfo && this.options.pathinfo === void 0) {
      this.options.pathinfo = true;
    }
    compiler.__internal__registerBuiltinPlugin({
      name: import_binding16.BuiltinPluginName.CssExtractRspackPlugin,
      options: this.normalizeOptions(this.options)
    });
  }
  normalizeOptions(options) {
    let chunkFilename2 = options.chunkFilename;
    if (!chunkFilename2) {
      const filename2 = options.filename || DEFAULT_FILENAME;
      if (typeof filename2 !== "function") {
        const hasName = (
          /** @type {string} */
          filename2.includes("[name]")
        );
        const hasId = (
          /** @type {string} */
          filename2.includes("[id]")
        );
        const hasChunkHash = (
          /** @type {string} */
          filename2.includes("[chunkhash]")
        );
        const hasContentHash = (
          /** @type {string} */
          filename2.includes("[contenthash]")
        );
        if (hasChunkHash || hasContentHash || hasName || hasId) {
          chunkFilename2 = filename2;
        } else {
          chunkFilename2 = /** @type {string} */
          filename2.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
        }
      } else {
        chunkFilename2 = "[id].css";
      }
    }
    const normalzedOptions = {
      filename: options.filename || DEFAULT_FILENAME,
      chunkFilename: chunkFilename2,
      ignoreOrder: options.ignoreOrder ?? false,
      runtime: options.runtime ?? true,
      insert: typeof options.insert === "function" ? options.insert.toString() : JSON.stringify(options.insert),
      linkType: typeof options.linkType === "undefined" ? JSON.stringify("text/css") : options.linkType === false ? void 0 : JSON.stringify(options.linkType),
      attributes: options.attributes ? Reflect.ownKeys(options.attributes).map((k) => [
        JSON.stringify(k),
        JSON.stringify(options.attributes[k])
      ]).reduce((obj, [k, v]) => {
        obj[k] = v;
        return obj;
      }, {}) : {},
      pathinfo: options.pathinfo ?? false
    };
    return normalzedOptions;
  }
};
CssExtractRspackPlugin.pluginName = PLUGIN_NAME;
CssExtractRspackPlugin.loader = LOADER_PATH;

// src/builtin-plugin/CssModulesPlugin.ts
var import_binding17 = require("@rspack/binding");
var CssModulesPlugin = create2(
  import_binding17.BuiltinPluginName.CssModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/DataUriPlugin.ts
var import_binding18 = require("@rspack/binding");
var DataUriPlugin = create2(
  import_binding18.BuiltinPluginName.DataUriPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/DefinePlugin.ts
var import_binding19 = require("@rspack/binding");
var DefinePlugin = create2(
  import_binding19.BuiltinPluginName.DefinePlugin,
  function(define2) {
    var _a;
    const supportsBigIntLiteral = ((_a = this.options.output.environment) == null ? void 0 : _a.bigIntLiteral) ?? false;
    return normalizeValue(define2, supportsBigIntLiteral);
  },
  "compilation"
);
var normalizeValue = (define2, supportsBigIntLiteral) => {
  const normalizePrimitive = (p) => {
    if (p === void 0) {
      return "undefined";
    }
    if (Object.is(p, -0)) {
      return "-0";
    }
    if (p instanceof RegExp) {
      return p.toString();
    }
    if (typeof p === "function") {
      return `(${p.toString()})`;
    }
    if (typeof p === "bigint") {
      return supportsBigIntLiteral ? `${p}n` : `BigInt("${p}")`;
    }
    return p;
  };
  const normalizeObject = (define3) => {
    if (Array.isArray(define3)) {
      return define3.map(normalizeObject);
    }
    if (define3 instanceof RegExp) {
      return normalizePrimitive(define3);
    }
    if (define3 && typeof define3 === "object") {
      const keys = Object.keys(define3);
      return Object.fromEntries(keys.map((k) => [k, normalizeObject(define3[k])]));
    }
    return normalizePrimitive(define3);
  };
  return normalizeObject(define2);
};

// src/builtin-plugin/DeterministicChunkIdsPlugin.ts
var import_binding20 = require("@rspack/binding");
var DeterministicChunkIdsPlugin = create2(
  import_binding20.BuiltinPluginName.DeterministicChunkIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/DeterministicModuleIdsPlugin.ts
var import_binding21 = require("@rspack/binding");
var DeterministicModuleIdsPlugin = create2(
  import_binding21.BuiltinPluginName.DeterministicModuleIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/DynamicEntryPlugin.ts
var import_binding25 = require("@rspack/binding");

// src/lib/EntryOptionPlugin.ts
var import_node_assert = __toESM(require("assert"));
var EntryOptionPlugin = class _EntryOptionPlugin {
  /**
   * @param compiler the compiler instance one is tapping into
   * @returns
   */
  apply(compiler) {
    compiler.hooks.entryOption.tap("EntryOptionPlugin", (context2, entry2) => {
      _EntryOptionPlugin.applyEntryOption(compiler, context2, entry2);
      return true;
    });
  }
  /**
   * @param compiler the compiler
   * @param context context directory
   * @param entry request
   * @returns
   */
  static applyEntryOption(compiler, context2, entry2) {
    if (typeof entry2 === "function") {
      new DynamicEntryPlugin(context2, entry2).apply(compiler);
    } else {
      for (const name2 of Object.keys(entry2)) {
        const desc = entry2[name2];
        const options = _EntryOptionPlugin.entryDescriptionToOptions(
          compiler,
          name2,
          desc
        );
        (0, import_node_assert.default)(
          desc.import !== void 0,
          "desc.import should not be `undefined` once `EntryOptionPlugin.applyEntryOption` is called"
        );
        for (const entry3 of desc.import) {
          new EntryPlugin(context2, entry3, options).apply(compiler);
        }
      }
    }
  }
  /**
   * @param compiler the compiler
   * @param name entry name
   * @param desc entry description
   * @returns options for the entry
   */
  static entryDescriptionToOptions(compiler, name2, desc) {
    const options = {
      name: name2,
      filename: desc.filename,
      runtime: desc.runtime,
      layer: desc.layer,
      dependOn: desc.dependOn,
      baseUri: desc.baseUri,
      publicPath: desc.publicPath,
      chunkLoading: desc.chunkLoading,
      asyncChunks: desc.asyncChunks,
      // wasmLoading: desc.wasmLoading,
      library: desc.library
    };
    if (desc.layer !== void 0 && !compiler.options.experiments.layers) {
      throw new Error(
        "'entryOptions.layer' is only allowed when 'experiments.layers' is enabled"
      );
    }
    return options;
  }
};
var EntryOptionPlugin_default = EntryOptionPlugin;

// src/builtin-plugin/EntryPlugin.ts
var import_binding24 = require("@rspack/binding");

// src/config/adapter.ts
var import_node_assert3 = __toESM(require("assert"));
var import_binding23 = require("@rspack/binding");

// src/util/identifier.ts
var import_node_path4 = __toESM(require("path"));
var WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\/]/;
var SEGMENTS_SPLIT_REGEXP = /([|!])/;
var WINDOWS_PATH_SEPARATOR_REGEXP = /\\/g;
var relativePathToRequest = (relativePath) => {
  if (relativePath === "") return "./.";
  if (relativePath === "..") return "../.";
  if (relativePath.startsWith("../")) return relativePath;
  return `./${relativePath}`;
};
var absoluteToRequest = (context2, maybeAbsolutePath) => {
  if (maybeAbsolutePath[0] === "/") {
    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === "/") {
      return maybeAbsolutePath;
    }
    const querySplitPos = maybeAbsolutePath.indexOf("?");
    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
    resource = relativePathToRequest(import_node_path4.default.posix.relative(context2, resource));
    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
  }
  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {
    const querySplitPos = maybeAbsolutePath.indexOf("?");
    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
    resource = import_node_path4.default.win32.relative(context2, resource);
    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {
      resource = relativePathToRequest(
        resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, "/")
      );
    }
    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
  }
  return maybeAbsolutePath;
};
var requestToAbsolute = (context2, relativePath) => {
  if (relativePath.startsWith("./") || relativePath.startsWith("../"))
    return import_node_path4.default.join(context2, relativePath);
  return relativePath;
};
var makeCacheable = (realFn) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const getCache = (associatedObjectForCache) => {
    const entry2 = cache.get(associatedObjectForCache);
    if (entry2 !== void 0) return entry2;
    const map = /* @__PURE__ */ new Map();
    cache.set(associatedObjectForCache, map);
    return map;
  };
  const fn2 = (str, associatedObjectForCache) => {
    if (!associatedObjectForCache) return realFn(str);
    const cache2 = getCache(associatedObjectForCache);
    const entry2 = cache2.get(str);
    if (entry2 !== void 0) return entry2;
    const result2 = realFn(str);
    cache2.set(str, result2);
    return result2;
  };
  fn2.bindCache = (associatedObjectForCache) => {
    const cache2 = getCache(associatedObjectForCache);
    return (str) => {
      const entry2 = cache2.get(str);
      if (entry2 !== void 0) return entry2;
      const result2 = realFn(str);
      cache2.set(str, result2);
      return result2;
    };
  };
  return fn2;
};
var makeCacheableWithContext = (fn2) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const cachedFn = (context2, identifier, associatedObjectForCache) => {
    if (!associatedObjectForCache) return fn2(context2, identifier);
    let innerCache = cache.get(
      associatedObjectForCache
    );
    if (innerCache === void 0) {
      innerCache = /* @__PURE__ */ new Map();
      cache.set(associatedObjectForCache, innerCache);
    }
    let cachedResult;
    let innerSubCache = innerCache.get(context2);
    if (innerSubCache === void 0) {
      innerCache.set(context2, innerSubCache = /* @__PURE__ */ new Map());
    } else {
      cachedResult = innerSubCache.get(identifier);
    }
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    const result2 = fn2(context2, identifier);
    innerSubCache.set(identifier, result2);
    return result2;
  };
  cachedFn.bindCache = (associatedObjectForCache) => {
    let innerCache;
    if (associatedObjectForCache) {
      innerCache = cache.get(associatedObjectForCache);
      if (innerCache === void 0) {
        innerCache = /* @__PURE__ */ new Map();
        cache.set(associatedObjectForCache, innerCache);
      }
    } else {
      innerCache = /* @__PURE__ */ new Map();
    }
    const boundFn = (context2, identifier) => {
      let cachedResult;
      let innerSubCache = innerCache == null ? void 0 : innerCache.get(context2);
      if (innerSubCache === void 0) {
        innerSubCache = /* @__PURE__ */ new Map();
        innerCache == null ? void 0 : innerCache.set(context2, innerSubCache);
      } else {
        cachedResult = innerSubCache.get(identifier);
      }
      if (cachedResult !== void 0) {
        return cachedResult;
      }
      const result2 = fn2(context2, identifier);
      innerSubCache.set(identifier, result2);
      return result2;
    };
    return boundFn;
  };
  cachedFn.bindContextCache = (context2, associatedObjectForCache) => {
    let innerSubCache;
    if (associatedObjectForCache) {
      let innerCache = cache.get(associatedObjectForCache);
      if (innerCache === void 0) {
        innerCache = /* @__PURE__ */ new Map();
        cache.set(associatedObjectForCache, innerCache);
      }
      innerSubCache = innerCache.get(context2);
      if (innerSubCache === void 0) {
        innerCache.set(context2, innerSubCache = /* @__PURE__ */ new Map());
      }
    } else {
      innerSubCache = /* @__PURE__ */ new Map();
    }
    const boundFn = (identifier) => {
      const cachedResult = innerSubCache == null ? void 0 : innerSubCache.get(identifier);
      if (cachedResult !== void 0) {
        return cachedResult;
      }
      const result2 = fn2(context2, identifier);
      innerSubCache == null ? void 0 : innerSubCache.set(identifier, result2);
      return result2;
    };
    return boundFn;
  };
  return cachedFn;
};
var _makePathsRelative = (context2, identifier) => {
  return identifier.split(SEGMENTS_SPLIT_REGEXP).map((str) => absoluteToRequest(context2, str)).join("");
};
var makePathsRelative = makeCacheableWithContext(_makePathsRelative);
var _makePathsAbsolute = (context2, identifier) => {
  return identifier.split(SEGMENTS_SPLIT_REGEXP).map((str) => requestToAbsolute(context2, str)).join("");
};
var makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);
var _contextify = (context2, request) => {
  return request.split("!").map((r) => absoluteToRequest(context2, r)).join("!");
};
var contextify = makeCacheableWithContext(_contextify);
var _absolutify = (context2, request) => {
  return request.split("!").map((r) => requestToAbsolute(context2, r)).join("!");
};
var absolutify = makeCacheableWithContext(_absolutify);
var PATH_QUERY_FRAGMENT_REGEXP = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
var PATH_QUERY_REGEXP = /^((?:\u200b.|[^?\u200b])*)(\?.*)?$/;
var _parseResource = (str) => {
  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
  return {
    resource: str,
    path: match[1].replace(/\u200b(.)/g, "$1"),
    query: match[2] ? match[2].replace(/\u200b(.)/g, "$1") : "",
    fragment: match[3] || ""
  };
};
var parseResource = makeCacheable(_parseResource);
var _parseResourceWithoutFragment = (str) => {
  const match = PATH_QUERY_REGEXP.exec(str);
  return {
    resource: str,
    path: match[1].replace(/\u200b(.)/g, "$1"),
    query: match[2] ? match[2].replace(/\u200b(.)/g, "$1") : ""
  };
};
var parseResourceWithoutFragment = makeCacheable(
  _parseResourceWithoutFragment
);

// src/builtin-loader/swc/pluginImport.ts
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function resolvePluginImport(pluginImport) {
  if (!pluginImport) {
    return void 0;
  }
  return pluginImport.map((config2) => {
    const rawConfig = {
      ...config2,
      style: {}
      // As babel-plugin-import style config is very flexible, we convert it to a more specific structure
    };
    if (typeof config2.style === "boolean") {
      rawConfig.style.bool = config2.style;
    } else if (typeof config2.style === "string") {
      const isTpl = config2.style.includes("{{");
      rawConfig.style[isTpl ? "custom" : "css"] = config2.style;
    } else if (isObject(config2.style)) {
      rawConfig.style = config2.style;
    }
    if (config2.styleLibraryDirectory) {
      rawConfig.style = { styleLibraryDirectory: config2.styleLibraryDirectory };
    }
    return rawConfig;
  });
}

// src/builtin-loader/lightningcss/index.ts
function toFeatures(featureOptions) {
  let feature = 0;
  for (const key of Reflect.ownKeys(featureOptions)) {
    if (featureOptions[key] !== true) {
      continue;
    }
    switch (key) {
      case "nesting":
        feature |= 1 /* Nesting */;
        break;
      case "notSelectorList":
        feature |= 2 /* NotSelectorList */;
        break;
      case "dirSelector":
        feature |= 4 /* DirSelector */;
        break;
      case "langSelectorList":
        feature |= 8 /* LangSelectorList */;
        break;
      case "isSelector":
        feature |= 16 /* IsSelector */;
        break;
      case "textDecorationThicknessPercent":
        feature |= 32 /* TextDecorationThicknessPercent */;
        break;
      case "mediaIntervalSyntax":
        feature |= 64 /* MediaIntervalSyntax */;
        break;
      case "mediaRangeSyntax":
        feature |= 128 /* MediaRangeSyntax */;
        break;
      case "customMediaQueries":
        feature |= 256 /* CustomMediaQueries */;
        break;
      case "clampFunction":
        feature |= 512 /* ClampFunction */;
        break;
      case "colorFunction":
        feature |= 1024 /* ColorFunction */;
        break;
      case "oklabColors":
        feature |= 2048 /* OklabColors */;
        break;
      case "labColors":
        feature |= 4096 /* LabColors */;
        break;
      case "p3Colors":
        feature |= 8192 /* P3Colors */;
        break;
      case "hexAlphaColors":
        feature |= 16384 /* HexAlphaColors */;
        break;
      case "spaceSeparatedColorNotation":
        feature |= 32768 /* SpaceSeparatedColorNotation */;
        break;
      case "fontFamilySystemUi":
        feature |= 65536 /* FontFamilySystemUi */;
        break;
      case "doublePositionGradients":
        feature |= 131072 /* DoublePositionGradients */;
        break;
      case "vendorPrefixes":
        feature |= 262144 /* VendorPrefixes */;
        break;
      case "logicalProperties":
        feature |= 524288 /* LogicalProperties */;
        break;
      case "selectors":
        feature |= 31 /* Selectors */;
        break;
      case "mediaQueries":
        feature |= 448 /* MediaQueries */;
        break;
      case "color":
        feature |= 64512 /* Color */;
        break;
    }
  }
  return feature;
}

// src/loader-runner/index.ts
var import_node_querystring = __toESM(require("querystring"));
var import_node_assert2 = __toESM(require("assert"));
var import_node_util3 = require("util");
var import_binding22 = require("@rspack/binding");
var import_webpack_sources2 = require("../compiled/webpack-sources/index.js");

// src/NormalModule.ts
var import_node_util2 = __toESM(require("util"));
var liteTapable2 = __toESM(require("@rspack/lite-tapable"));
var compilationHooksMap = /* @__PURE__ */ new WeakMap();
var createFakeHook = (fakeHook, message, code) => {
  return Object.freeze(
    Object.assign(
      message && code ? deprecateAllProperties(fakeHook, message, code) : fakeHook,
      { _fakeHook: true }
    )
  );
};
var deprecateAllProperties = (obj, message, code) => {
  const newObj = {};
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  for (const name2 of Object.keys(descriptors)) {
    const descriptor = descriptors[name2];
    if (typeof descriptor.value === "function") {
      Object.defineProperty(newObj, name2, {
        ...descriptor,
        value: import_node_util2.default.deprecate(descriptor.value, message, code)
      });
    } else if (descriptor.get || descriptor.set) {
      Object.defineProperty(newObj, name2, {
        ...descriptor,
        get: descriptor.get && import_node_util2.default.deprecate(descriptor.get, message, code),
        set: descriptor.set && import_node_util2.default.deprecate(descriptor.set, message, code)
      });
    } else {
      let value = descriptor.value;
      Object.defineProperty(newObj, name2, {
        configurable: descriptor.configurable,
        enumerable: descriptor.enumerable,
        get: import_node_util2.default.deprecate(() => value, message, code),
        set: descriptor.writable ? import_node_util2.default.deprecate((v) => value = v, message, code) : void 0
      });
    }
  }
  return newObj;
};
var NormalModule = class {
  static getCompilationHooks(compilation) {
    if (!(compilation instanceof Compilation)) {
      throw new TypeError(
        "The 'compilation' argument must be an instance of Compilation"
      );
    }
    let hooks = compilationHooksMap.get(compilation);
    if (hooks === void 0) {
      hooks = {
        loader: new liteTapable2.SyncHook(["loaderContext", "module"]),
        // TODO webpack 6 deprecate
        readResourceForScheme: new liteTapable2.HookMap((scheme) => {
          const hook = hooks.readResource.for(scheme);
          return createFakeHook({
            tap: (options, fn2) => hook.tap(
              options,
              (loaderContext) => fn2(loaderContext.resource)
            ),
            tapAsync: (options, fn2) => hook.tapAsync(
              options,
              (loaderContext, callback) => fn2(loaderContext.resource, callback)
            ),
            tapPromise: (options, fn2) => hook.tapPromise(
              options,
              (loaderContext) => fn2(loaderContext.resource)
            )
          });
        }),
        readResource: new liteTapable2.HookMap(
          () => new liteTapable2.AsyncSeriesBailHook(["loaderContext"])
        )
      };
      compilationHooksMap.set(compilation, hooks);
    }
    return hooks;
  }
};
var NormalModule_default = NormalModule;

// src/loader-runner/LoaderLoadingError.ts
var LoadingLoaderError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LoaderRunnerError";
    Error.captureStackTrace(this, this.constructor);
  }
};
var LoaderLoadingError_default = LoadingLoaderError;

// src/loader-runner/loadLoader.ts
var url = void 0;
function loadLoader(loader2, callback) {
  if (loader2.type === "module") {
    try {
      if (url === void 0) url = require("url");
      const loaderUrl = url.pathToFileURL(loader2.path);
      const modulePromise = import(loaderUrl.toString());
      modulePromise.then((module2) => {
        handleResult(loader2, module2, callback);
      }, callback);
      return;
    } catch (e) {
      callback(e);
    }
  } else {
    let module2;
    try {
      module2 = require(loader2.path);
    } catch (e) {
      if (e instanceof Error && e.code === "EMFILE") {
        const retry = loadLoader.bind(null, loader2, callback);
        return void setImmediate(retry);
      }
      return callback(e);
    }
    return handleResult(loader2, module2, callback);
  }
}
function handleResult(loader2, module2, callback) {
  if (typeof module2 !== "function" && typeof module2 !== "object") {
    return callback(
      new LoaderLoadingError_default(
        `Module '${loader2.path}' is not a loader (export function or es6 module)`
      )
    );
  }
  loader2.normal = typeof module2 === "function" ? module2 : module2.default;
  loader2.pitch = module2.pitch;
  loader2.raw = module2.raw;
  if (typeof loader2.normal !== "function" && typeof loader2.pitch !== "function") {
    return callback(
      new LoaderLoadingError_default(
        `Module '${loader2.path}' is not a loader (must have normal or pitch function)`
      )
    );
  }
  callback();
}

// src/loader-runner/index.ts
function createLoaderObject(loader2, compiler) {
  const obj = {
    path: null,
    query: null,
    fragment: null,
    options: null,
    ident: null,
    normal: null,
    pitch: null,
    raw: null,
    data: null,
    pitchExecuted: false,
    normalExecuted: false
  };
  Object.defineProperty(obj, "request", {
    enumerable: true,
    get: () => obj.path.replace(/#/g, "\u200B#") + obj.query.replace(/#/g, "\u200B#") + obj.fragment,
    set: (value) => {
      const splittedRequest = parseResourceWithoutFragment(value.request);
      obj.path = splittedRequest.path;
      obj.query = splittedRequest.query;
      obj.fragment = "";
      obj.options = obj.options === null ? splittedRequest.query ? splittedRequest.query.slice(1) : void 0 : obj.options;
      if (typeof obj.options === "string" && obj.options[0] === "?") {
        const ident = obj.options.slice(1);
        if (ident === "[[missing ident]]") {
          throw new Error(
            "No ident is provided by referenced loader. When using a function for Rule.use in config you need to provide an 'ident' property for referenced loader options."
          );
        }
        obj.options = compiler.__internal__ruleSet.references.get(ident);
        if (obj.options === void 0) {
          throw new Error("Invalid ident is provided by referenced loader");
        }
        obj.ident = ident;
      }
      obj.type = value.type === "" ? void 0 : value.type;
      if (obj.options === null) obj.query = "";
      else if (obj.options === void 0) obj.query = "";
      else if (typeof obj.options === "string") obj.query = `?${obj.options}`;
      else if (obj.ident) obj.query = `??${obj.ident}`;
      else if (typeof obj.options === "object" && obj.options.ident)
        obj.query = `??${obj.options.ident}`;
      else obj.query = `?${JSON.stringify(obj.options)}`;
    }
  });
  obj.request = loader2;
  if (Object.preventExtensions) {
    Object.preventExtensions(obj);
  }
  return obj;
}
var LoaderObject = class {
  #loaderItem;
  constructor(loaderItem, compiler) {
    const {
      request,
      path: path10,
      query,
      fragment,
      options,
      ident,
      normal,
      pitch,
      raw,
      type
    } = createLoaderObject(loaderItem, compiler);
    this.request = request;
    this.path = path10;
    this.query = query;
    this.fragment = fragment;
    this.options = options;
    this.ident = ident;
    this.normal = normal;
    this.pitch = pitch;
    this.raw = raw;
    this.type = type;
    this.#loaderItem = loaderItem;
  }
  get pitchExecuted() {
    return this.#loaderItem.pitchExecuted;
  }
  set pitchExecuted(value) {
    (0, import_node_assert2.default)(value);
    this.#loaderItem.pitchExecuted = true;
  }
  get normalExecuted() {
    return this.#loaderItem.normalExecuted;
  }
  set normalExecuted(value) {
    (0, import_node_assert2.default)(value);
    this.#loaderItem.normalExecuted = true;
  }
  // A data object shared between the pitch and the normal phase
  get data() {
    return new Proxy(this.#loaderItem.data = this.#loaderItem.data ?? {}, {
      set: (_, property, value) => {
        if (typeof property === "string") {
          this.#loaderItem.data[property] = value;
        }
        return true;
      },
      get: (_, property) => {
        if (typeof property === "string") {
          return this.#loaderItem.data[property];
        }
      }
    });
  }
  // A data object shared between the pitch and the normal phase
  set data(data) {
    this.#loaderItem.data = data;
  }
  shouldYield() {
    return this.request.startsWith(BUILTIN_LOADER_PREFIX);
  }
  static __from_binding(loaderItem, compiler) {
    return new this(loaderItem, compiler);
  }
  static __to_binding(loader2) {
    return loader2.#loaderItem;
  }
};
var JsSourceMap = class {
  static __from_binding(map) {
    return isNil(map) ? void 0 : toObject(map);
  }
  static __to_binding(map) {
    return serializeObject(map);
  }
};
var loadLoaderAsync = (0, import_node_util3.promisify)(loadLoader);
var runSyncOrAsync = (0, import_node_util3.promisify)(function runSyncOrAsync2(fn2, context2, args, callback) {
  let isSync = true;
  let isDone = false;
  let isError = false;
  let reportedError = false;
  context2.async = function async() {
    if (isDone) {
      if (reportedError) return void 0;
      throw new Error("async(): The callback was already called.");
    }
    isSync = false;
    return innerCallback;
  };
  const innerCallback = (err, ...args2) => {
    if (isDone) {
      if (reportedError) return;
      throw new Error("callback(): The callback was already called.");
    }
    isDone = true;
    isSync = false;
    try {
      callback(err, args2);
    } catch (e) {
      isError = true;
      throw e;
    }
  };
  context2.callback = innerCallback;
  try {
    const result2 = function LOADER_EXECUTION() {
      return fn2.apply(context2, args);
    }();
    if (isSync) {
      isDone = true;
      if (result2 === void 0) {
        callback(null, []);
        return;
      }
      if (result2 && typeof result2 === "object" && typeof result2.then === "function") {
        result2.then((r) => {
          callback(null, [r]);
        }, callback);
        return;
      }
      callback(null, [result2]);
      return;
    }
  } catch (e) {
    const err = e;
    if ("hideStack" in err && err.hideStack) {
      err.hideStack = "true";
    }
    if (isError) throw e;
    if (isDone) {
      if (e instanceof Error) console.error(e.stack);
      else console.error(e);
      return;
    }
    isDone = true;
    reportedError = true;
    callback(e, []);
  }
});
function dirname(path10) {
  if (path10 === "/") return "/";
  const i = path10.lastIndexOf("/");
  const j = path10.lastIndexOf("\\");
  const i2 = path10.indexOf("/");
  const j2 = path10.indexOf("\\");
  const idx = i > j ? i : j;
  const idx2 = i > j ? i2 : j2;
  if (idx < 0) return path10;
  if (idx === idx2) return path10.slice(0, idx + 1);
  return path10.slice(0, idx);
}
function getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
  var _a;
  if (((_a = loaderContext.loaders) == null ? void 0 : _a.length) && index < loaderContext.loaders.length && index >= 0 && loaderContext.loaders[index]) {
    return loaderContext.loaders[index];
  }
  return null;
}
async function runLoaders(compiler, context2) {
  const loaderState = context2.loaderState;
  const { resource } = context2.resourceData;
  const splittedResource = resource && parsePathQueryFragment(resource);
  const resourcePath = splittedResource ? splittedResource.path : void 0;
  const resourceQuery = splittedResource ? splittedResource.query : void 0;
  const resourceFragment = splittedResource ? splittedResource.fragment : void 0;
  const contextDirectory = resourcePath ? dirname(resourcePath) : null;
  const fileDependencies = context2.fileDependencies;
  const contextDependencies = context2.contextDependencies;
  const missingDependencies = context2.missingDependencies;
  const buildDependencies = context2.buildDependencies;
  const loaderContext = {};
  loaderContext.loaders = context2.loaderItems.map((item) => {
    return LoaderObject.__from_binding(item, compiler);
  });
  loaderContext.hot = context2.hot;
  loaderContext.context = contextDirectory;
  loaderContext.resourcePath = resourcePath;
  loaderContext.resourceQuery = resourceQuery;
  loaderContext.resourceFragment = resourceFragment;
  loaderContext.dependency = loaderContext.addDependency = function addDependency(file) {
    fileDependencies.push(file);
  };
  loaderContext.addContextDependency = function addContextDependency(context3) {
    contextDependencies.push(context3);
  };
  loaderContext.addMissingDependency = function addMissingDependency(context3) {
    missingDependencies.push(context3);
  };
  loaderContext.addBuildDependency = function addBuildDependency(file) {
    buildDependencies.push(file);
  };
  loaderContext.getDependencies = function getDependencies() {
    return fileDependencies.slice();
  };
  loaderContext.getContextDependencies = function getContextDependencies() {
    return contextDependencies.slice();
  };
  loaderContext.getMissingDependencies = function getMissingDependencies() {
    return missingDependencies.slice();
  };
  loaderContext.clearDependencies = function clearDependencies() {
    fileDependencies.length = 0;
    contextDependencies.length = 0;
    missingDependencies.length = 0;
    context2.cacheable = true;
  };
  loaderContext.importModule = function importModule(request, userOptions, callback) {
    const options = userOptions ? userOptions : {};
    if (!callback) {
      return new Promise((resolve2, reject) => {
        compiler._lastCompilation.__internal_getInner().importModule(
          request,
          options.layer,
          options.publicPath,
          options.baseUri,
          context2._module.moduleIdentifier,
          loaderContext.context,
          (err, res) => {
            if (err) reject(err);
            else {
              for (const dep of res.buildDependencies) {
                this.addBuildDependency(dep);
              }
              for (const dep of res.contextDependencies) {
                this.addContextDependency(dep);
              }
              for (const dep of res.missingDependencies) {
                this.addMissingDependency(dep);
              }
              for (const dep of res.fileDependencies) {
                this.addDependency(dep);
              }
              if (res.cacheable === false) {
                this.cacheable(false);
              }
              resolve2(compiler.__internal__getModuleExecutionResult(res.id));
            }
          }
        );
      });
    }
    return compiler._lastCompilation.__internal_getInner().importModule(
      request,
      options.layer,
      options.publicPath,
      options.baseUri,
      context2._module.moduleIdentifier,
      loaderContext.context,
      (err, res) => {
        if (err) {
          callback(err, void 0);
        } else {
          for (const dep of res.buildDependencies) {
            this.addBuildDependency(dep);
          }
          for (const dep of res.contextDependencies) {
            this.addContextDependency(dep);
          }
          for (const dep of res.missingDependencies) {
            this.addMissingDependency(dep);
          }
          for (const dep of res.fileDependencies) {
            this.addDependency(dep);
          }
          if (res.cacheable === false) {
            this.cacheable(false);
          }
          callback(
            void 0,
            compiler.__internal__getModuleExecutionResult(res.id)
          );
        }
      }
    );
  };
  Object.defineProperty(loaderContext, "resource", {
    enumerable: true,
    get: () => {
      if (loaderContext.resourcePath === void 0) return void 0;
      return loaderContext.resourcePath.replace(/#/g, "\u200B#") + loaderContext.resourceQuery.replace(/#/g, "\u200B#") + loaderContext.resourceFragment;
    },
    set: (value) => {
      const splittedResource2 = value && parsePathQueryFragment(value);
      loaderContext.resourcePath = splittedResource2 ? splittedResource2.path : void 0;
      loaderContext.resourceQuery = splittedResource2 ? splittedResource2.query : void 0;
      loaderContext.resourceFragment = splittedResource2 ? splittedResource2.fragment : void 0;
    }
  });
  Object.defineProperty(loaderContext, "request", {
    enumerable: true,
    get: () => loaderContext.loaders.map((o) => o.request).concat(loaderContext.resource || "").join("!")
  });
  Object.defineProperty(loaderContext, "remainingRequest", {
    enumerable: true,
    get: () => {
      if (loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource)
        return "";
      return loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((o) => o.request).concat(loaderContext.resource || "").join("!");
    }
  });
  Object.defineProperty(loaderContext, "currentRequest", {
    enumerable: true,
    get: () => loaderContext.loaders.slice(loaderContext.loaderIndex).map((o) => o.request).concat(loaderContext.resource || "").join("!")
  });
  Object.defineProperty(loaderContext, "previousRequest", {
    enumerable: true,
    get: () => loaderContext.loaders.slice(0, loaderContext.loaderIndex).map((o) => o.request).join("!")
  });
  Object.defineProperty(loaderContext, "query", {
    enumerable: true,
    get: () => {
      const entry2 = loaderContext.loaders[loaderContext.loaderIndex];
      return entry2.options && typeof entry2.options === "object" ? entry2.options : entry2.query;
    }
  });
  loaderContext.version = 2;
  loaderContext.sourceMap = compiler.options.devtool ? isUseSourceMap(compiler.options.devtool) : context2._module.useSourceMap ?? false;
  loaderContext.mode = compiler.options.mode;
  Object.assign(loaderContext, compiler.options.loader);
  const getResolveContext = () => {
    return {
      fileDependencies: {
        // @ts-expect-error: Mocking insert-only `Set<T>`
        add: (d) => {
          loaderContext.addDependency(d);
        }
      },
      contextDependencies: {
        // @ts-expect-error: Mocking insert-only `Set<T>`
        add: (d) => {
          loaderContext.addContextDependency(d);
        }
      },
      missingDependencies: {
        // @ts-expect-error: Mocking insert-only `Set<T>`
        add: (d) => {
          loaderContext.addMissingDependency(d);
        }
      }
    };
  };
  const resolver = compiler._lastCompilation.resolverFactory.get("normal");
  loaderContext.resolve = function resolve2(context3, request, callback) {
    resolver.resolve({}, context3, request, getResolveContext(), callback);
  };
  loaderContext.getResolve = function getResolve(options) {
    const child = options ? resolver.withOptions(options) : resolver;
    return (context3, request, callback) => {
      if (callback) {
        child.resolve({}, context3, request, getResolveContext(), callback);
        return;
      }
      return new Promise((resolve2, reject) => {
        child.resolve(
          {},
          context3,
          request,
          getResolveContext(),
          (err, result2) => {
            if (err) reject(err);
            else resolve2(result2);
          }
        );
      });
    };
  };
  loaderContext.getLogger = function getLogger(name2) {
    return compiler._lastCompilation.getLogger(
      [name2, resource].filter(Boolean).join("|")
    );
  };
  loaderContext.rootContext = compiler.context;
  loaderContext.emitError = function emitError(err) {
    let error = err;
    if (!(error instanceof Error)) {
      error = new NonErrorEmittedError(error);
    }
    error.name = "ModuleError";
    error.message = `${error.message} (from: ${stringifyLoaderObject(
      loaderContext.loaders[loaderContext.loaderIndex]
    )})`;
    error = concatErrorMsgAndStack(error);
    error.moduleIdentifier = this._module.identifier();
    compiler._lastCompilation.__internal__pushRspackDiagnostic({
      error,
      severity: import_binding22.JsRspackSeverity.Error
    });
  };
  loaderContext.emitWarning = function emitWarning(warn) {
    let warning = warn;
    if (!(warning instanceof Error)) {
      warning = new NonErrorEmittedError(warning);
    }
    warning.name = "ModuleWarning";
    warning.message = `${warning.message} (from: ${stringifyLoaderObject(
      loaderContext.loaders[loaderContext.loaderIndex]
    )})`;
    warning = concatErrorMsgAndStack(warning);
    warning.moduleIdentifier = this._module.identifier();
    compiler._lastCompilation.__internal__pushRspackDiagnostic({
      error: warning,
      severity: import_binding22.JsRspackSeverity.Warn
    });
  };
  loaderContext.emitFile = function emitFile(name2, content, sourceMap, assetInfo) {
    let source = void 0;
    if (sourceMap) {
      if (typeof sourceMap === "string" && (loaderContext.sourceMap || compiler.options.devtool && isUseSimpleSourceMap(compiler.options.devtool))) {
        source = new import_webpack_sources2.OriginalSource(
          content,
          makePathsRelative(contextDirectory, sourceMap, compiler)
        );
      }
      if (this.sourceMap) {
        source = new import_webpack_sources2.SourceMapSource(
          // @ts-expect-error webpack-sources type declaration is wrong
          content,
          name2,
          makePathsRelative(contextDirectory, sourceMap, compiler)
        );
      }
    } else {
      source = new import_webpack_sources2.RawSource(
        // @ts-expect-error webpack-sources type declaration is wrong
        content
      );
    }
    compiler._lastCompilation.__internal__emit_asset_from_loader(
      name2,
      source,
      assetInfo,
      context2._moduleIdentifier
    );
  };
  loaderContext.fs = compiler.inputFileSystem;
  loaderContext.experiments = {
    emitDiagnostic: (diagnostic) => {
      const d = Object.assign({}, diagnostic, {
        message: diagnostic.severity === "warning" ? `ModuleWarning: ${diagnostic.message}` : `ModuleError: ${diagnostic.message}`,
        moduleIdentifier: context2._module.moduleIdentifier
      });
      compiler._lastCompilation.__internal__pushDiagnostic(
        (0, import_binding22.formatDiagnostic)(d)
      );
    }
  };
  const getAbsolutify = memoize(() => absolutify.bindCache(compiler.root));
  const getAbsolutifyInContext = memoize(
    () => absolutify.bindContextCache(contextDirectory, compiler.root)
  );
  const getContextify = memoize(() => contextify.bindCache(compiler.root));
  const getContextifyInContext = memoize(
    () => contextify.bindContextCache(contextDirectory, compiler.root)
  );
  loaderContext.utils = {
    absolutify: (context3, request) => {
      return context3 === contextDirectory ? getAbsolutifyInContext()(request) : getAbsolutify()(context3, request);
    },
    contextify: (context3, request) => {
      return context3 === contextDirectory ? getContextifyInContext()(request) : getContextify()(context3, request);
    },
    createHash: (type) => {
      return createHash(
        type || compiler._lastCompilation.outputOptions.hashFunction
      );
    }
  };
  loaderContext._compiler = compiler;
  loaderContext._compilation = compiler._lastCompilation;
  loaderContext._module = Module.__from_binding(
    context2._module,
    compiler._lastCompilation
  );
  loaderContext.getOptions = () => {
    const loader2 = getCurrentLoader(loaderContext);
    let options = loader2 == null ? void 0 : loader2.options;
    if (typeof options === "string") {
      if (options.startsWith("{") && options.endsWith("}")) {
        try {
          const parseJson = require_lib();
          options = parseJson(options);
        } catch (e) {
          throw new Error(`Cannot parse string options: ${e.message}`);
        }
      } else {
        options = import_node_querystring.default.parse(options);
      }
    }
    if (options === null || options === void 0) {
      options = {};
    }
    return options;
  };
  let compilation = compiler._lastCompilation;
  let step = 0;
  while (compilation) {
    NormalModule.getCompilationHooks(compilation).loader.call(
      loaderContext,
      loaderContext._module
    );
    compilation = compilation.compiler.parentCompilation;
    step++;
    if (step > 1e3) {
      throw Error(
        "Too many nested child compiler, exceeded max limitation 1000"
      );
    }
  }
  Object.defineProperty(loaderContext, "loaderIndex", {
    enumerable: true,
    get: () => context2.loaderIndex,
    set: (loaderIndex) => context2.loaderIndex = loaderIndex
  });
  Object.defineProperty(loaderContext, "cacheable", {
    enumerable: true,
    get: () => (cacheable) => {
      if (cacheable === false) {
        context2.cacheable = cacheable;
      }
    }
  });
  Object.defineProperty(loaderContext, "data", {
    enumerable: true,
    get: () => loaderContext.loaders[loaderContext.loaderIndex].data,
    set: (data) => loaderContext.loaders[loaderContext.loaderIndex].data = data
  });
  Object.defineProperty(loaderContext, "__internal__parseMeta", {
    enumerable: true,
    get: () => context2.__internal__parseMeta
  });
  switch (loaderState) {
    case import_binding22.JsLoaderState.Pitching: {
      while (loaderContext.loaderIndex < loaderContext.loaders.length) {
        const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
        if (currentLoaderObject.shouldYield()) break;
        if (currentLoaderObject.pitchExecuted) {
          loaderContext.loaderIndex += 1;
          continue;
        }
        await loadLoaderAsync(currentLoaderObject);
        const fn2 = currentLoaderObject.pitch;
        currentLoaderObject.pitchExecuted = true;
        if (!fn2) continue;
        const args = await runSyncOrAsync(fn2, loaderContext, [
          loaderContext.remainingRequest,
          loaderContext.previousRequest,
          currentLoaderObject.data
        ]) || [];
        const hasArg = args.some((value) => value !== void 0);
        if (hasArg) {
          const [content, sourceMap, additionalData] = args;
          context2.content = isNil(content) ? null : toBuffer(content);
          context2.sourceMap = serializeObject(sourceMap);
          context2.additionalData = additionalData;
          break;
        }
      }
      break;
    }
    case import_binding22.JsLoaderState.Normal: {
      let content = context2.content;
      let sourceMap = JsSourceMap.__from_binding(context2.sourceMap);
      let additionalData = context2.additionalData;
      while (loaderContext.loaderIndex >= 0) {
        const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
        if (currentLoaderObject.shouldYield()) break;
        if (currentLoaderObject.normalExecuted) {
          loaderContext.loaderIndex--;
          continue;
        }
        await loadLoaderAsync(currentLoaderObject);
        const fn2 = currentLoaderObject.normal;
        currentLoaderObject.normalExecuted = true;
        if (!fn2) continue;
        const args = [content, sourceMap, additionalData];
        convertArgs(args, !!currentLoaderObject.raw);
        [content, sourceMap, additionalData] = await runSyncOrAsync(fn2, loaderContext, args) || [];
      }
      context2.content = isNil(content) ? null : toBuffer(content);
      context2.sourceMap = JsSourceMap.__to_binding(sourceMap);
      context2.additionalData = additionalData;
      break;
    }
    default:
      throw new Error(`Unexpected loader runner state: ${loaderState}`);
  }
  context2.loaderItems = loaderContext.loaders.map(
    (item) => LoaderObject.__to_binding(item)
  );
  return context2;
}
function utf8BufferToString(buf) {
  const str = buf.toString("utf-8");
  if (str.charCodeAt(0) === 65279) {
    return str.slice(1);
  }
  return str;
}
function convertArgs(args, raw) {
  if (!raw && Buffer.isBuffer(args[0])) args[0] = utf8BufferToString(args[0]);
  else if (raw && typeof args[0] === "string")
    args[0] = Buffer.from(args[0], "utf-8");
}
var PATH_QUERY_FRAGMENT_REGEXP2 = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
  const match = PATH_QUERY_FRAGMENT_REGEXP2.exec(str);
  return {
    path: (match == null ? void 0 : match[1].replace(/\u200b(.)/g, "$1")) || "",
    query: (match == null ? void 0 : match[2]) ? match[2].replace(/\u200b(.)/g, "$1") : "",
    fragment: (match == null ? void 0 : match[3]) || ""
  };
}

// src/config/adapterRuleUse.ts
var BUILTIN_LOADER_PREFIX = "builtin:";
function createRawModuleRuleUses(uses, path10, options) {
  const normalizeRuleSetUseItem = (item) => typeof item === "string" ? { loader: item } : item;
  const allUses = Array.isArray(uses) ? [...uses].map(normalizeRuleSetUseItem) : [normalizeRuleSetUseItem(uses)];
  return createRawModuleRuleUsesImpl(allUses, path10, options);
}
var getSwcLoaderOptions = (o, _) => {
  if (o && typeof o === "object" && o.rspackExperiments) {
    const expr = o.rspackExperiments;
    if (expr.import || expr.pluginImport) {
      expr.import = resolvePluginImport(expr.import || expr.pluginImport);
    }
  }
  return o;
};
var getLightningcssLoaderOptions = (o, _) => {
  if (o && typeof o === "object") {
    if (typeof o.targets === "string") {
      o.targets = [o.targets];
    }
    if (o.include && typeof o.include === "object") {
      o.include = toFeatures(o.include);
    }
    if (o.exclude && typeof o.exclude === "object") {
      o.exclude = toFeatures(o.exclude);
    }
  }
  return o;
};
function getBuiltinLoaderOptions(identifier, o, options) {
  if (identifier.startsWith(`${BUILTIN_LOADER_PREFIX}swc-loader`)) {
    return getSwcLoaderOptions(o, options);
  }
  if (identifier.startsWith(`${BUILTIN_LOADER_PREFIX}lightningcss-loader`)) {
    return getLightningcssLoaderOptions(o, options);
  }
  return o;
}
function createRawModuleRuleUsesImpl(uses, path10, options) {
  if (!uses.length) {
    return [];
  }
  return uses.map((use, index) => {
    let o;
    let isBuiltin = false;
    if (use.loader.startsWith(BUILTIN_LOADER_PREFIX)) {
      const temp = getBuiltinLoaderOptions(use.loader, use.options, options);
      o = isNil(temp) ? void 0 : typeof temp === "string" ? temp : JSON.stringify(temp, null, 2);
      isBuiltin = true;
    }
    return {
      loader: resolveStringifyLoaders(
        use,
        `${path10}[${index}]`,
        options.compiler,
        isBuiltin
      ),
      options: o
    };
  });
}
function resolveStringifyLoaders(use, path10, compiler, isBuiltin) {
  const obj = parsePathQueryFragment(use.loader);
  let ident = null;
  if (use.options === null) {
  } else if (use.options === void 0) {
  } else if (typeof use.options === "string") obj.query = `?${use.options}`;
  else if (use.ident) obj.query = `??${ident = use.ident}`;
  else if (typeof use.options === "object" && use.options.ident)
    obj.query = `??${ident = use.options.ident}`;
  else if (typeof use.options === "object") obj.query = `??${ident = path10}`;
  else obj.query = `?${JSON.stringify(use.options)}`;
  if (use.options && typeof use.options === "object") {
    if (!ident) ident = "[[missing ident]]";
    compiler.__internal__ruleSet.references.set(ident, use.options);
    if (isBuiltin) {
      compiler.__internal__ruleSet.builtinReferences.set(ident, use.options);
    }
  }
  return obj.path + obj.query + obj.fragment;
}
function isUseSourceMap(devtool) {
  return devtool.includes("source-map") && (devtool.includes("module") || !devtool.includes("cheap"));
}
function isUseSimpleSourceMap(devtool) {
  return devtool.includes("source-map") && !isUseSourceMap(devtool);
}

// src/config/adapter.ts
var getRawOptions = (options, compiler) => {
  (0, import_node_assert3.default)(
    !isNil(options.context) && !isNil(options.devtool) && !isNil(options.cache),
    "context, devtool, cache should not be nil after defaults"
  );
  const devtool = options.devtool === false ? "" : options.devtool;
  const mode2 = options.mode;
  const experiments3 = getRawExperiments(options.experiments);
  return {
    mode: mode2,
    target: getRawTarget(options.target),
    context: options.context,
    output: getRawOutput(options.output),
    resolve: getRawResolve(options.resolve),
    resolveLoader: getRawResolve(options.resolveLoader),
    module: getRawModule(options.module, {
      compiler,
      devtool,
      mode: mode2,
      context: options.context,
      experiments: experiments3
    }),
    devtool,
    optimization: getRawOptimization(options.optimization),
    stats: getRawStats(options.stats),
    snapshot: getRawSnapshotOptions(options.snapshot),
    cache: {
      type: options.cache ? "memory" : "disable",
      // TODO: implement below cache options
      maxGenerations: 0,
      maxAge: 0,
      profile: false,
      buildDependencies: [],
      cacheDirectory: "",
      cacheLocation: "",
      name: "",
      version: ""
    },
    experiments: experiments3,
    node: getRawNode(options.node),
    // SAFETY: applied default value in `applyRspackOptionsDefaults`.
    profile: options.profile,
    // SAFETY: applied default value in `applyRspackOptionsDefaults`.
    bail: options.bail,
    __references: {}
  };
};
function getRawTarget(target2) {
  if (!target2) {
    return [];
  }
  if (typeof target2 === "string") {
    return [target2];
  }
  return target2;
}
function getRawExtensionAlias(alias = {}) {
  const entries = Object.entries(alias).map(([key, value]) => {
    if (Array.isArray(value)) {
      return [key, value];
    }
    return [key, [value]];
  });
  return Object.fromEntries(entries);
}
function getRawAlias(alias = {}) {
  return Object.entries(alias).map(([key, value]) => ({
    path: key,
    redirect: Array.isArray(value) ? value : [value]
  }));
}
function getRawResolveByDependency(byDependency) {
  if (byDependency === void 0) return byDependency;
  return Object.fromEntries(
    Object.entries(byDependency).map(([k, v]) => [k, getRawResolve(v)])
  );
}
function getRawTsConfig(tsConfig) {
  (0, import_node_assert3.default)(
    typeof tsConfig !== "string",
    "should resolve string tsConfig in normalization"
  );
  if (tsConfig === void 0) return tsConfig;
  const { configFile, references } = tsConfig;
  return {
    configFile,
    referencesType: references === "auto" ? "auto" : references ? "manual" : "disabled",
    references: references === "auto" ? void 0 : references
  };
}
function getRawResolve(resolve2) {
  return {
    ...resolve2,
    alias: getRawAlias(resolve2.alias),
    fallback: getRawAlias(resolve2.fallback),
    extensionAlias: getRawExtensionAlias(resolve2.extensionAlias),
    tsconfig: getRawTsConfig(resolve2.tsConfig),
    byDependency: getRawResolveByDependency(resolve2.byDependency)
  };
}
function getRawCrossOriginLoading(crossOriginLoading2) {
  if (typeof crossOriginLoading2 === "boolean") {
    return { type: "bool", boolPayload: crossOriginLoading2 };
  }
  return { type: "string", stringPayload: crossOriginLoading2 };
}
function getRawOutput(output2) {
  const chunkLoading2 = output2.chunkLoading;
  const wasmLoading2 = output2.wasmLoading;
  const workerChunkLoading = output2.workerChunkLoading;
  const workerWasmLoading = output2.workerWasmLoading;
  return {
    path: output2.path,
    pathinfo: output2.pathinfo,
    publicPath: output2.publicPath,
    clean: output2.clean,
    assetModuleFilename: output2.assetModuleFilename,
    filename: output2.filename,
    chunkFilename: output2.chunkFilename,
    chunkLoading: getRawChunkLoading(chunkLoading2),
    crossOriginLoading: getRawCrossOriginLoading(output2.crossOriginLoading),
    cssFilename: output2.cssFilename,
    cssChunkFilename: output2.cssChunkFilename,
    cssHeadDataCompression: output2.cssHeadDataCompression,
    hotUpdateChunkFilename: output2.hotUpdateChunkFilename,
    hotUpdateMainFilename: output2.hotUpdateMainFilename,
    hotUpdateGlobal: output2.hotUpdateGlobal,
    uniqueName: output2.uniqueName,
    chunkLoadingGlobal: output2.chunkLoadingGlobal,
    enabledLibraryTypes: output2.enabledLibraryTypes,
    library: output2.library && getRawLibrary(output2.library),
    strictModuleErrorHandling: output2.strictModuleErrorHandling,
    globalObject: output2.globalObject,
    importFunctionName: output2.importFunctionName,
    importMetaName: output2.importMetaName,
    iife: output2.iife,
    module: output2.module,
    wasmLoading: wasmLoading2 === false ? "false" : wasmLoading2,
    enabledWasmLoadingTypes: output2.enabledWasmLoadingTypes,
    enabledChunkLoadingTypes: output2.enabledChunkLoadingTypes,
    webassemblyModuleFilename: output2.webassemblyModuleFilename,
    trustedTypes: output2.trustedTypes,
    sourceMapFilename: output2.sourceMapFilename,
    hashFunction: output2.hashFunction,
    hashDigest: output2.hashDigest,
    hashDigestLength: output2.hashDigestLength,
    hashSalt: output2.hashSalt,
    asyncChunks: output2.asyncChunks,
    workerChunkLoading: workerChunkLoading === false ? "false" : workerChunkLoading,
    workerWasmLoading: workerWasmLoading === false ? "false" : workerWasmLoading,
    workerPublicPath: output2.workerPublicPath,
    scriptType: output2.scriptType === false ? "false" : output2.scriptType,
    charset: output2.charset,
    chunkLoadTimeout: output2.chunkLoadTimeout,
    environment: output2.environment
  };
}
function getRawLibrary(library3) {
  const {
    type,
    name: name2,
    export: libraryExport2,
    umdNamedDefine: umdNamedDefine2,
    auxiliaryComment: auxiliaryComment2,
    amdContainer: amdContainer2
  } = library3;
  return {
    amdContainer: amdContainer2,
    auxiliaryComment: typeof auxiliaryComment2 === "string" ? {
      commonjs: auxiliaryComment2,
      commonjs2: auxiliaryComment2,
      amd: auxiliaryComment2,
      root: auxiliaryComment2
    } : auxiliaryComment2,
    libraryType: type,
    name: isNil(name2) ? name2 : getRawLibraryName(name2),
    export: Array.isArray(libraryExport2) || libraryExport2 == null ? libraryExport2 : [libraryExport2],
    umdNamedDefine: umdNamedDefine2
  };
}
function getRawLibraryName(name2) {
  if (typeof name2 === "string") {
    return {
      type: "string",
      stringPayload: name2
    };
  }
  if (Array.isArray(name2)) {
    return {
      type: "array",
      arrayPayload: name2
    };
  }
  if (typeof name2 === "object" && !Array.isArray(name2)) {
    return {
      type: "umdObject",
      umdObjectPayload: {
        commonjs: name2.commonjs,
        root: Array.isArray(name2.root) || isNil(name2.root) ? name2.root : [name2.root],
        amd: name2.amd
      }
    };
  }
  throw new Error("unreachable");
}
function getRawModule(module2, options) {
  (0, import_node_assert3.default)(
    !isNil(module2.defaultRules),
    "module.defaultRules should not be nil after defaults"
  );
  const ruleSet = [
    { rules: module2.defaultRules },
    { rules: module2.rules }
  ];
  const rules = ruleSet.map(
    (rule, index) => getRawModuleRule(rule, `ruleSet[${index}]`, options, "javascript/auto")
  );
  return {
    rules,
    parser: getRawParserOptionsMap(module2.parser),
    generator: getRawGeneratorOptionsMap(module2.generator),
    noParse: module2.noParse
  };
}
function tryMatch(payload, condition) {
  if (typeof condition === "string") {
    return payload.startsWith(condition);
  }
  if (condition instanceof RegExp) {
    return condition.test(payload);
  }
  if (typeof condition === "function") {
    return condition(payload);
  }
  if (Array.isArray(condition)) {
    return condition.some((c) => tryMatch(payload, c));
  }
  if (condition && typeof condition === "object") {
    if (condition.and) {
      return condition.and.every((c) => tryMatch(payload, c));
    }
    if (condition.or) {
      return condition.or.some((c) => tryMatch(payload, c));
    }
    if (condition.not) {
      return !tryMatch(payload, condition.not);
    }
  }
  return false;
}
var getRawModuleRule = (rule, path10, options, upperType) => {
  if (rule.loader) {
    rule.use = [
      {
        loader: rule.loader,
        options: rule.options
      }
    ];
  }
  let funcUse;
  if (typeof rule.use === "function") {
    const use = rule.use;
    funcUse = (rawContext) => {
      const context2 = {
        ...rawContext,
        compiler: options.compiler
      };
      const uses = use(context2);
      return createRawModuleRuleUses(uses ?? [], `${path10}.use`, options);
    };
  }
  const rawModuleRule = {
    test: rule.test ? getRawRuleSetCondition(rule.test) : void 0,
    include: rule.include ? getRawRuleSetCondition(rule.include) : void 0,
    exclude: rule.exclude ? getRawRuleSetCondition(rule.exclude) : void 0,
    issuer: rule.issuer ? getRawRuleSetCondition(rule.issuer) : void 0,
    issuerLayer: rule.issuerLayer ? getRawRuleSetCondition(rule.issuerLayer) : void 0,
    dependency: rule.dependency ? getRawRuleSetCondition(rule.dependency) : void 0,
    descriptionData: rule.descriptionData ? Object.fromEntries(
      Object.entries(rule.descriptionData).map(([k, v]) => [
        k,
        getRawRuleSetCondition(v)
      ])
    ) : void 0,
    with: rule.with ? Object.fromEntries(
      Object.entries(rule.with).map(([k, v]) => [
        k,
        getRawRuleSetCondition(v)
      ])
    ) : void 0,
    resource: rule.resource ? getRawRuleSetCondition(rule.resource) : void 0,
    resourceQuery: rule.resourceQuery ? getRawRuleSetCondition(rule.resourceQuery) : void 0,
    resourceFragment: rule.resourceFragment ? getRawRuleSetCondition(rule.resourceFragment) : void 0,
    scheme: rule.scheme ? getRawRuleSetCondition(rule.scheme) : void 0,
    mimetype: rule.mimetype ? getRawRuleSetCondition(rule.mimetype) : void 0,
    sideEffects: rule.sideEffects,
    use: typeof rule.use === "function" ? funcUse : createRawModuleRuleUses(rule.use ?? [], `${path10}.use`, options),
    type: rule.type,
    layer: rule.layer,
    parser: rule.parser ? getRawParserOptions(rule.parser, rule.type ?? upperType) : void 0,
    generator: rule.generator ? getRawGeneratorOptions(rule.generator, rule.type ?? upperType) : void 0,
    resolve: rule.resolve ? getRawResolve(rule.resolve) : void 0,
    oneOf: rule.oneOf ? rule.oneOf.map(
      (rule2, index) => getRawModuleRule(
        rule2,
        `${path10}.oneOf[${index}]`,
        options,
        rule2.type ?? upperType
      )
    ) : void 0,
    rules: rule.rules ? rule.rules.map(
      (rule2, index) => getRawModuleRule(
        rule2,
        `${path10}.rules[${index}]`,
        options,
        rule2.type ?? upperType
      )
    ) : void 0,
    enforce: rule.enforce
  };
  if (typeof rule.test === "function" || typeof rule.resource === "function" || typeof rule.resourceQuery === "function" || typeof rule.resourceFragment === "function") {
    delete rawModuleRule.test;
    delete rawModuleRule.resource;
    delete rawModuleRule.resourceQuery;
    delete rawModuleRule.resourceFragment;
    rawModuleRule.rspackResource = getRawRuleSetCondition(
      (resourceQueryFragment) => {
        const { path: path11, query, fragment } = parseResource(resourceQueryFragment);
        if (rule.test && !tryMatch(path11, rule.test)) {
          return false;
        }
        if (rule.resource && !tryMatch(path11, rule.resource)) {
          return false;
        }
        if (rule.resourceQuery && !tryMatch(query, rule.resourceQuery)) {
          return false;
        }
        if (rule.resourceFragment && !tryMatch(fragment, rule.resourceFragment)) {
          return false;
        }
        return true;
      }
    );
  }
  return rawModuleRule;
};
function getRawRuleSetCondition(condition) {
  if (typeof condition === "string") {
    return {
      type: import_binding23.RawRuleSetConditionType.string,
      string: condition
    };
  }
  if (condition instanceof RegExp) {
    return {
      type: import_binding23.RawRuleSetConditionType.regexp,
      regexp: {
        source: condition.source,
        flags: condition.flags
      }
    };
  }
  if (typeof condition === "function") {
    return {
      type: import_binding23.RawRuleSetConditionType.func,
      func: condition
    };
  }
  if (Array.isArray(condition)) {
    return {
      type: import_binding23.RawRuleSetConditionType.array,
      array: condition.map((i) => getRawRuleSetCondition(i))
    };
  }
  if (typeof condition === "object" && condition !== null) {
    return {
      type: import_binding23.RawRuleSetConditionType.logical,
      logical: [getRawRuleSetLogicalConditions(condition)]
    };
  }
  throw new Error(
    "unreachable: condition should be one of string, RegExp, Array, Object"
  );
}
function getRawRuleSetLogicalConditions(logical) {
  return {
    and: logical.and ? logical.and.map((i) => getRawRuleSetCondition(i)) : void 0,
    or: logical.or ? logical.or.map((i) => getRawRuleSetCondition(i)) : void 0,
    not: logical.not ? getRawRuleSetCondition(logical.not) : void 0
  };
}
function getRawParserOptionsMap(parser) {
  return Object.fromEntries(
    Object.entries(parser).map(([k, v]) => [k, getRawParserOptions(v, k)]).filter(([k, v]) => v !== void 0)
  );
}
function getRawGeneratorOptionsMap(generator) {
  return Object.fromEntries(
    Object.entries(generator).map(([k, v]) => [k, getRawGeneratorOptions(v, k)]).filter(([k, v]) => v !== void 0)
  );
}
function getRawParserOptions(parser, type) {
  if (type === "asset") {
    return {
      type: "asset",
      asset: getRawAssetParserOptions(parser)
    };
  }
  if (type === "javascript") {
    return {
      type: "javascript",
      javascript: getRawJavascriptParserOptions(parser)
    };
  }
  if (type === "javascript/auto") {
    return {
      type: "javascript/auto",
      javascript: getRawJavascriptParserOptions(parser)
    };
  }
  if (type === "javascript/dynamic") {
    return {
      type: "javascript/dynamic",
      javascript: getRawJavascriptParserOptions(parser)
    };
  }
  if (type === "javascript/esm") {
    return {
      type: "javascript/esm",
      javascript: getRawJavascriptParserOptions(parser)
    };
  }
  if (type === "css") {
    return {
      type: "css",
      css: getRawCssParserOptions(parser)
    };
  }
  if (type === "css/auto") {
    return {
      type: "css/auto",
      cssAuto: getRawCssParserOptions(parser)
    };
  }
  if (type === "css/module") {
    return {
      type: "css/module",
      cssModule: getRawCssParserOptions(parser)
    };
  }
  throw new Error(`unreachable: unknow module type: ${type}`);
}
function getRawJavascriptParserOptions(parser) {
  var _a, _b, _c;
  return {
    dynamicImportMode: parser.dynamicImportMode,
    dynamicImportPreload: (_a = parser.dynamicImportPreload) == null ? void 0 : _a.toString(),
    dynamicImportPrefetch: (_b = parser.dynamicImportPrefetch) == null ? void 0 : _b.toString(),
    dynamicImportFetchPriority: parser.dynamicImportFetchPriority,
    importMeta: parser.importMeta,
    url: (_c = parser.url) == null ? void 0 : _c.toString(),
    exprContextCritical: parser.exprContextCritical,
    wrappedContextCritical: parser.wrappedContextCritical,
    exportsPresence: parser.exportsPresence === false ? "false" : parser.exportsPresence,
    importExportsPresence: parser.importExportsPresence === false ? "false" : parser.importExportsPresence,
    reexportExportsPresence: parser.reexportExportsPresence === false ? "false" : parser.reexportExportsPresence,
    strictExportPresence: parser.strictExportPresence,
    worker: typeof parser.worker === "boolean" ? parser.worker ? ["..."] : [] : parser.worker,
    overrideStrict: parser.overrideStrict,
    requireAsExpression: parser.requireAsExpression,
    requireDynamic: parser.requireDynamic,
    requireResolve: parser.requireResolve,
    importDynamic: parser.importDynamic
  };
}
function getRawAssetParserOptions(parser) {
  return {
    dataUrlCondition: parser.dataUrlCondition ? getRawAssetParserDataUrl(parser.dataUrlCondition) : void 0
  };
}
function getRawAssetParserDataUrl(dataUrlCondition) {
  if (typeof dataUrlCondition === "object" && dataUrlCondition !== null) {
    return {
      type: "options",
      options: {
        maxSize: dataUrlCondition.maxSize
      }
    };
  }
  throw new Error(
    `unreachable: AssetParserDataUrl type should be one of "options", but got ${dataUrlCondition}`
  );
}
function getRawCssParserOptions(parser) {
  return {
    namedExports: parser.namedExports
  };
}
function getRawGeneratorOptions(generator, type) {
  if (type === "asset") {
    return {
      type: "asset",
      asset: generator ? getRawAssetGeneratorOptions(generator) : void 0
    };
  }
  if (type === "asset/inline") {
    return {
      type: "asset/inline",
      assetInline: generator ? getRawAssetInlineGeneratorOptions(generator) : void 0
    };
  }
  if (type === "asset/resource") {
    return {
      type: "asset/resource",
      assetResource: generator ? getRawAssetResourceGeneratorOptions(generator) : void 0
    };
  }
  if (type === "css") {
    return {
      type: "css",
      css: getRawCssGeneratorOptions(generator)
    };
  }
  if (type === "css/auto") {
    return {
      type: "css/auto",
      cssAuto: getRawCssAutoOrModuleGeneratorOptions(generator)
    };
  }
  if (type === "css/module") {
    return {
      type: "css/module",
      cssModule: getRawCssAutoOrModuleGeneratorOptions(generator)
    };
  }
  if ([
    "javascript",
    "javascript/auto",
    "javascript/dynamic",
    "javascript/esm"
  ].includes(type)) {
    return void 0;
  }
  throw new Error(`unreachable: unknow module type: ${type}`);
}
function getRawAssetGeneratorOptions(options) {
  return {
    ...getRawAssetInlineGeneratorOptions(options),
    ...getRawAssetResourceGeneratorOptions(options)
  };
}
function getRawAssetInlineGeneratorOptions(options) {
  return {
    dataUrl: options.dataUrl ? getRawAssetGeneratorDataUrl(options.dataUrl) : void 0
  };
}
function getRawAssetResourceGeneratorOptions(options) {
  return {
    emit: options.emit,
    filename: options.filename,
    publicPath: options.publicPath
  };
}
function getRawAssetGeneratorDataUrl(dataUrl) {
  if (typeof dataUrl === "object" && dataUrl !== null) {
    const encoding = dataUrl.encoding === false ? "false" : dataUrl.encoding;
    return {
      encoding,
      mimetype: dataUrl.mimetype
    };
  }
  if (typeof dataUrl === "function" && dataUrl !== null) {
    return dataUrl;
  }
  throw new Error(
    `unreachable: AssetGeneratorDataUrl type should be one of "options", "function", but got ${dataUrl}`
  );
}
function getRawCssGeneratorOptions(options) {
  return {
    exportsOnly: options.exportsOnly,
    esModule: options.esModule
  };
}
function getRawCssAutoOrModuleGeneratorOptions(options) {
  return {
    localIdentName: options.localIdentName,
    exportsConvention: options.exportsConvention,
    exportsOnly: options.exportsOnly,
    esModule: options.esModule
  };
}
function getRawOptimization(optimization2) {
  (0, import_node_assert3.default)(
    !isNil(optimization2.removeAvailableModules) && !isNil(optimization2.sideEffects) && !isNil(optimization2.realContentHash) && !isNil(optimization2.providedExports) && !isNil(optimization2.usedExports) && !isNil(optimization2.innerGraph) && "optimization.moduleIds, optimization.removeAvailableModules, optimization.removeEmptyChunks, optimization.sideEffects, optimization.realContentHash, optimization.providedExports, optimization.usedExports, optimization.innerGraph, optimization.concatenateModules should not be nil after defaults"
  );
  return {
    removeAvailableModules: optimization2.removeAvailableModules,
    sideEffects: String(optimization2.sideEffects),
    usedExports: String(optimization2.usedExports),
    providedExports: optimization2.providedExports,
    innerGraph: optimization2.innerGraph,
    concatenateModules: !!optimization2.concatenateModules,
    mangleExports: String(optimization2.mangleExports)
  };
}
function getRawSnapshotOptions(_snapshot) {
  return {};
}
function getRawExperiments(experiments3) {
  const { topLevelAwait, layers, incremental: incremental2, rspackFuture } = experiments3;
  (0, import_node_assert3.default)(
    !isNil(topLevelAwait) && !isNil(rspackFuture) && !isNil(layers) && !isNil(incremental2)
  );
  return {
    layers,
    topLevelAwait,
    incremental: getRawIncremental(incremental2),
    rspackFuture: getRawRspackFutureOptions(rspackFuture)
  };
}
function getRawIncremental(incremental2) {
  if (incremental2 === false) {
    return void 0;
  }
  return {
    make: incremental2.make,
    emitAssets: incremental2.emitAssets,
    inferAsyncModules: incremental2.inferAsyncModules,
    providedExports: incremental2.providedExports,
    moduleHashes: incremental2.moduleHashes,
    moduleCodegen: incremental2.moduleCodegen,
    moduleRuntimeRequirements: incremental2.moduleRuntimeRequirements
  };
}
function getRawRspackFutureOptions(future) {
  return {};
}
function getRawNode(node3) {
  if (node3 === false) {
    return void 0;
  }
  (0, import_node_assert3.default)(
    !isNil(node3.__dirname) && !isNil(node3.global) && !isNil(node3.__filename)
  );
  return {
    dirname: String(node3.__dirname),
    filename: String(node3.__filename),
    global: String(node3.global)
  };
}
function getRawStats(stats) {
  const statsOptions2 = normalizeStatsPreset(stats);
  return {
    colors: statsOptions2.colors ?? false
  };
}
function getRawChunkLoading(chunkLoading2) {
  return chunkLoading2 === false ? "false" : chunkLoading2;
}

// src/config/defaults.ts
var import_node_assert4 = __toESM(require("assert"));
var import_node_fs = __toESM(require("fs"));
var import_node_path6 = __toESM(require("path"));

// src/ModuleTypeConstants.ts
var ASSET_MODULE_TYPE = "asset";

// src/Template.ts
var START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0);
var START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0);
var DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;
var NUMBER_OF_IDENTIFIER_START_CHARS = DELTA_A_TO_Z * 2 + 2;
var NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS = NUMBER_OF_IDENTIFIER_START_CHARS + 10;
var FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g;
var INDENT_MULTILINE_REGEX = /^\t/gm;
var LINE_SEPARATOR_REGEX = /\r?\n/g;
var IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;
var IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;
var COMMENT_END_REGEX = /\*\//g;
var PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g;
var MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;
var Template = class _Template {
  /**
   *
   * @param fn a runtime function (.runtime.js) "template"
   * @returns the updated and normalized function string
   */
  static getFunctionContent(fn2) {
    return fn2.toString().replace(FUNCTION_CONTENT_REGEX, "").replace(INDENT_MULTILINE_REGEX, "").replace(LINE_SEPARATOR_REGEX, "\n");
  }
  /**
   * @param str the string converted to identifier
   * @returns created identifier
   */
  static toIdentifier(str) {
    if (typeof str !== "string") return "";
    return str.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
  }
  /**
   *
   * @param str string to be converted to commented in bundle code
   * @returns returns a commented version of string
   */
  static toComment(str) {
    if (!str) return "";
    return `/*! ${str.replace(COMMENT_END_REGEX, "* /")} */`;
  }
  /**
   *
   * @param str string to be converted to "normal comment"
   * @returns returns a commented version of string
   */
  static toNormalComment(str) {
    if (!str) return "";
    return `/* ${str.replace(COMMENT_END_REGEX, "* /")} */`;
  }
  /**
   * @param str string path to be normalized
   * @returns normalized bundle-safe path
   */
  static toPath(str) {
    if (typeof str !== "string") return "";
    return str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
  }
  // map number to a single character a-z, A-Z or multiple characters if number is too big
  /**
   * @param num number to convert to ident
   * @returns returns single character ident
   */
  static numberToIdentifier(num) {
    let n = num;
    if (n >= NUMBER_OF_IDENTIFIER_START_CHARS) {
      return _Template.numberToIdentifier(n % NUMBER_OF_IDENTIFIER_START_CHARS) + _Template.numberToIdentifierContinuation(
        Math.floor(n / NUMBER_OF_IDENTIFIER_START_CHARS)
      );
    }
    if (n < DELTA_A_TO_Z) {
      return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);
    }
    n -= DELTA_A_TO_Z;
    if (n < DELTA_A_TO_Z) {
      return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n);
    }
    if (n === DELTA_A_TO_Z) return "_";
    return "$";
  }
  /**
   * @param num number to convert to ident
   * @returns returns single character ident
   */
  static numberToIdentifierContinuation(num) {
    let n = num;
    if (n >= NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS) {
      return _Template.numberToIdentifierContinuation(
        n % NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS
      ) + _Template.numberToIdentifierContinuation(
        Math.floor(n / NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS)
      );
    }
    if (n < DELTA_A_TO_Z) {
      return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);
    }
    n -= DELTA_A_TO_Z;
    if (n < DELTA_A_TO_Z) {
      return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n);
    }
    n -= DELTA_A_TO_Z;
    if (n < 10) {
      return `${n}`;
    }
    if (n === 10) return "_";
    return "$";
  }
  /**
   *
   * @param s string to convert to identity
   * @returns converted identity
   */
  static indent(s) {
    if (Array.isArray(s)) {
      return s.map(_Template.indent).join("\n");
    }
    const str = s.trimEnd();
    if (!str) return "";
    const ind = str[0] === "\n" ? "" : "	";
    return ind + str.replace(/\n([^\n])/g, "\n	$1");
  }
  /**
   *
   * @param s string to create prefix for
   * @param prefix prefix to compose
   * @returns returns new prefix string
   */
  static prefix(s, prefix) {
    const str = _Template.asString(s).trim();
    if (!str) return "";
    const ind = str[0] === "\n" ? "" : prefix;
    return ind + str.replace(/\n([^\n])/g, `
${prefix}$1`);
  }
  /**
   *
   * @param str string or string collection
   * @returns returns a single string from array
   */
  static asString(str) {
    if (Array.isArray(str)) {
      return str.join("\n");
    }
    return str;
  }
  /**
   * @param modules a collection of modules to get array bounds for
   * @returns returns the upper and lower array bounds
   * or false if not every module has a number based id
   */
  static getModulesArrayBounds(modules) {
    let maxId = Number.NEGATIVE_INFINITY;
    let minId = Number.POSITIVE_INFINITY;
    for (const module2 of modules) {
      const moduleId = module2.id;
      if (typeof moduleId !== "number") return false;
      if (maxId < moduleId) maxId = moduleId;
      if (minId > moduleId) minId = moduleId;
    }
    if (minId < 16 + `${minId}`.length) {
      minId = 0;
    }
    let objectOverhead = -1;
    for (const module2 of modules) {
      objectOverhead += `${module2.id}`.length + 2;
    }
    const arrayOverhead = minId === 0 ? maxId : 16 + `${minId}`.length + maxId;
    return arrayOverhead < objectOverhead ? [minId, maxId] : false;
  }
};

// src/util/assertNotNil.ts
function assertNotNill(value) {
  if (value == null) {
    throw Error(`${value} should not be undefined or null`);
  }
}

// src/util/cleverMerge.ts
var DYNAMIC_INFO = Symbol("cleverMerge dynamic info");
var mergeCache = /* @__PURE__ */ new WeakMap();
var DELETE = Symbol("DELETE");
var cachedCleverMerge = (first, second) => {
  if (second === void 0) return first;
  if (first === void 0) return second;
  if (typeof second !== "object" || second === null) return second;
  if (typeof first !== "object" || first === null) return first;
  let innerCache = mergeCache.get(first);
  if (innerCache === void 0) {
    innerCache = /* @__PURE__ */ new WeakMap();
    mergeCache.set(first, innerCache);
  }
  const prevMerge = innerCache.get(second);
  if (prevMerge !== void 0) return prevMerge;
  const newMerge = _cleverMerge(first, second, true);
  innerCache.set(second, newMerge);
  return newMerge;
};
var parseCache = /* @__PURE__ */ new WeakMap();
var cachedParseObject = (obj) => {
  const entry2 = parseCache.get(obj);
  if (entry2 !== void 0) return entry2;
  const result2 = parseObject(obj);
  parseCache.set(obj, result2);
  return result2;
};
var parseObject = (obj) => {
  const info = /* @__PURE__ */ new Map();
  let dynamicInfo;
  const getInfo = (p) => {
    const entry2 = info.get(p);
    if (entry2 !== void 0) return entry2;
    const newEntry = {
      base: void 0,
      byProperty: void 0,
      byValues: /* @__PURE__ */ new Map()
    };
    info.set(p, newEntry);
    return newEntry;
  };
  for (const key of Object.keys(obj)) {
    if (key.startsWith("by")) {
      const byProperty = key;
      const byObj = obj[byProperty];
      if (typeof byObj === "object") {
        for (const byValue of Object.keys(byObj)) {
          const obj2 = byObj[byValue];
          for (const key2 of Object.keys(obj2)) {
            const entry2 = getInfo(key2);
            if (entry2.byProperty === void 0) {
              entry2.byProperty = byProperty;
            } else if (entry2.byProperty !== byProperty) {
              throw new Error(
                `${byProperty} and ${entry2.byProperty} for a single property is not supported`
              );
            }
            entry2.byValues.set(byValue, obj2[key2]);
            if (byValue === "default") {
              for (const otherByValue of Object.keys(byObj)) {
                if (!entry2.byValues.has(otherByValue))
                  entry2.byValues.set(otherByValue, void 0);
              }
            }
          }
        }
      } else if (typeof byObj === "function") {
        if (dynamicInfo === void 0) {
          dynamicInfo = {
            byProperty: key,
            fn: byObj
          };
        } else {
          throw new Error(
            `${key} and ${dynamicInfo.byProperty} when both are functions is not supported`
          );
        }
      } else {
        const entry2 = getInfo(key);
        entry2.base = obj[key];
      }
    } else {
      const entry2 = getInfo(key);
      entry2.base = obj[key];
    }
  }
  return {
    static: info,
    dynamic: dynamicInfo
  };
};
var serializeObject2 = (info, dynamicInfo) => {
  const obj = {};
  for (const entry2 of info.values()) {
    if (entry2.byProperty !== void 0) {
      const byObj = obj[entry2.byProperty] = obj[entry2.byProperty] || {};
      for (const byValue of entry2.byValues.keys()) {
        byObj[byValue] = byObj[byValue] || {};
      }
    }
  }
  for (const [key, entry2] of info) {
    if (entry2.base !== void 0) {
      obj[key] = entry2.base;
    }
    if (entry2.byProperty !== void 0) {
      const byObj = obj[entry2.byProperty] = obj[entry2.byProperty] || {};
      for (const byValue of Object.keys(byObj)) {
        const value = getFromByValues(entry2.byValues, byValue);
        if (value !== void 0) byObj[byValue][key] = value;
      }
    }
  }
  if (dynamicInfo !== void 0) {
    obj[dynamicInfo.byProperty] = dynamicInfo.fn;
  }
  return obj;
};
var VALUE_TYPE_UNDEFINED = 0;
var VALUE_TYPE_ATOM = 1;
var VALUE_TYPE_ARRAY_EXTEND = 2;
var VALUE_TYPE_OBJECT = 3;
var VALUE_TYPE_DELETE = 4;
var getValueType = (value) => {
  if (value === void 0) {
    return VALUE_TYPE_UNDEFINED;
  }
  if (value === DELETE) {
    return VALUE_TYPE_DELETE;
  }
  if (Array.isArray(value)) {
    if (value.lastIndexOf("...") !== -1) return VALUE_TYPE_ARRAY_EXTEND;
    return VALUE_TYPE_ATOM;
  }
  if (typeof value === "object" && value !== null && (!value.constructor || value.constructor === Object)) {
    return VALUE_TYPE_OBJECT;
  }
  return VALUE_TYPE_ATOM;
};
var cleverMerge = (first, second) => {
  if (second === void 0) return first;
  if (first === void 0) return second;
  if (typeof second !== "object" || second === null) return second;
  if (typeof first !== "object" || first === null) return first;
  return _cleverMerge(first, second, false);
};
var _cleverMerge = (first, second, internalCaching = false) => {
  const firstObject = internalCaching ? cachedParseObject(first) : parseObject(first);
  const { static: firstInfo, dynamic: firstDynamicInfo } = firstObject;
  let secondObj = second;
  if (firstDynamicInfo !== void 0) {
    let { byProperty, fn: fn2 } = firstDynamicInfo;
    const fnInfo = fn2[DYNAMIC_INFO];
    if (fnInfo) {
      secondObj = internalCaching ? cachedCleverMerge(fnInfo[1], second) : cleverMerge(fnInfo[1], second);
      fn2 = fnInfo[0];
    }
    const newFn = (...args) => {
      const fnResult = fn2(...args);
      return internalCaching ? cachedCleverMerge(fnResult, secondObj) : cleverMerge(fnResult, secondObj);
    };
    newFn[DYNAMIC_INFO] = [fn2, secondObj];
    return serializeObject2(firstObject.static, { byProperty, fn: newFn });
  }
  const secondObject = internalCaching ? cachedParseObject(second) : parseObject(second);
  const { static: secondInfo, dynamic: secondDynamicInfo } = secondObject;
  const resultInfo = /* @__PURE__ */ new Map();
  for (const [key, firstEntry] of firstInfo) {
    const secondEntry = secondInfo.get(key);
    const entry2 = secondEntry !== void 0 ? mergeEntries(firstEntry, secondEntry, internalCaching) : firstEntry;
    resultInfo.set(key, entry2);
  }
  for (const [key, secondEntry] of secondInfo) {
    if (!firstInfo.has(key)) {
      resultInfo.set(key, secondEntry);
    }
  }
  return serializeObject2(resultInfo, secondDynamicInfo);
};
var mergeEntries = (firstEntry, secondEntry, internalCaching) => {
  switch (getValueType(secondEntry.base)) {
    case VALUE_TYPE_ATOM:
    case VALUE_TYPE_DELETE:
      return secondEntry;
    case VALUE_TYPE_UNDEFINED: {
      if (!firstEntry.byProperty) {
        return {
          base: firstEntry.base,
          byProperty: secondEntry.byProperty,
          byValues: secondEntry.byValues
        };
      }
      if (firstEntry.byProperty !== secondEntry.byProperty) {
        throw new Error(
          `${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
        );
      }
      const newByValues = new Map(firstEntry.byValues);
      for (const [key, value] of secondEntry.byValues) {
        const firstValue = getFromByValues(firstEntry.byValues, key);
        newByValues.set(
          key,
          mergeSingleValue(firstValue, value, internalCaching)
        );
      }
      return {
        base: firstEntry.base,
        byProperty: firstEntry.byProperty,
        byValues: newByValues
      };
    }
    default: {
      if (!firstEntry.byProperty) {
        return {
          base: mergeSingleValue(
            firstEntry.base,
            secondEntry.base,
            internalCaching
          ),
          byProperty: secondEntry.byProperty,
          byValues: secondEntry.byValues
        };
      }
      let newBase;
      const intermediateByValues = new Map(firstEntry.byValues);
      for (const [key, value] of intermediateByValues) {
        intermediateByValues.set(
          key,
          mergeSingleValue(value, secondEntry.base, internalCaching)
        );
      }
      if (Array.from(firstEntry.byValues.values()).every((value) => {
        const type = getValueType(value);
        return type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;
      })) {
        newBase = mergeSingleValue(
          firstEntry.base,
          secondEntry.base,
          internalCaching
        );
      } else {
        newBase = firstEntry.base;
        if (!intermediateByValues.has("default"))
          intermediateByValues.set("default", secondEntry.base);
      }
      if (!secondEntry.byProperty) {
        return {
          base: newBase,
          byProperty: firstEntry.byProperty,
          byValues: intermediateByValues
        };
      }
      if (firstEntry.byProperty !== secondEntry.byProperty) {
        throw new Error(
          `${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
        );
      }
      const newByValues = new Map(intermediateByValues);
      for (const [key, value] of secondEntry.byValues) {
        const firstValue = getFromByValues(intermediateByValues, key);
        newByValues.set(
          key,
          mergeSingleValue(firstValue, value, internalCaching)
        );
      }
      return {
        base: newBase,
        byProperty: firstEntry.byProperty,
        byValues: newByValues
      };
    }
  }
};
var getFromByValues = (byValues, key) => {
  if (key !== "default" && byValues.has(key)) {
    return byValues.get(key);
  }
  return byValues.get("default");
};
var mergeSingleValue = (a, b, internalCaching) => {
  const bType = getValueType(b);
  const aType = getValueType(a);
  switch (bType) {
    case VALUE_TYPE_DELETE:
    case VALUE_TYPE_ATOM:
      return b;
    case VALUE_TYPE_OBJECT: {
      return aType !== VALUE_TYPE_OBJECT ? b : internalCaching ? cachedCleverMerge(a, b) : cleverMerge(a, b);
    }
    case VALUE_TYPE_UNDEFINED:
      return a;
    case VALUE_TYPE_ARRAY_EXTEND:
      switch (aType !== VALUE_TYPE_ATOM ? aType : Array.isArray(a) ? VALUE_TYPE_ARRAY_EXTEND : VALUE_TYPE_OBJECT) {
        case VALUE_TYPE_UNDEFINED:
          return b;
        case VALUE_TYPE_DELETE:
          return b.filter((item) => item !== "...");
        case VALUE_TYPE_ARRAY_EXTEND: {
          const newArray = [];
          for (const item of b) {
            if (item === "...") {
              for (const item2 of a) {
                newArray.push(item2);
              }
            } else {
              newArray.push(item);
            }
          }
          return newArray;
        }
        case VALUE_TYPE_OBJECT:
          return b.map((item) => item === "..." ? a : item);
        default:
          throw new Error("Not implemented");
      }
    default:
      throw new Error("Not implemented");
  }
};

// src/config/browserslistTargetHandler.ts
var browserslistTargetHandler_exports = {};
__export(browserslistTargetHandler_exports, {
  load: () => load,
  resolve: () => resolve
});
var import_node_path5 = __toESM(require("path"));
var inputRx = /^(?:((?:[A-Z]:)?[/\\].*?))?(?::(.+?))?$/i;
var parse = (input, context2) => {
  if (!input) {
    return {};
  }
  if (import_node_path5.default.isAbsolute(input)) {
    const [, configPath, env] = inputRx.exec(input) || [];
    return { configPath, env };
  }
  const browserslist = require("../compiled/browserslist/index.js");
  const config2 = browserslist.findConfig(context2);
  if (config2 && Object.keys(config2).includes(input)) {
    return { env: input };
  }
  return { query: input };
};
var load = (input, context2) => {
  const browserslist = require("../compiled/browserslist/index.js");
  const { configPath, env, query } = parse(input, context2);
  const config2 = query ? query : configPath ? browserslist.loadConfig({
    config: configPath,
    env
  }) : browserslist.loadConfig({ path: context2, env });
  if (!config2) return;
  return browserslist(config2);
};
var resolve = (browsers) => {
  const rawChecker = (versions) => {
    return browsers.every((v) => {
      const [name2, parsedVersion] = v.split(" ");
      if (!name2) return false;
      const requiredVersion = versions[name2];
      if (!requiredVersion) return false;
      const [parsedMajor, parserMinor] = (
        // safari TP supports all features for normal safari
        parsedVersion === "TP" ? [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY] : parsedVersion.includes("-") ? parsedVersion.split("-")[0].split(".") : parsedVersion.split(".")
      );
      if (typeof requiredVersion === "number") {
        return +parsedMajor >= requiredVersion;
      }
      return requiredVersion[0] === +parsedMajor ? +parserMinor >= requiredVersion[1] : +parsedMajor > requiredVersion[0];
    });
  };
  const anyNode = browsers.some((b) => b.startsWith("node "));
  const anyBrowser = browsers.some((b) => /^(?!node)/.test(b));
  const browserProperty = !anyBrowser ? false : anyNode ? null : true;
  const nodeProperty = !anyNode ? false : anyBrowser ? null : true;
  const es6DynamicImport = rawChecker({
    chrome: 63,
    and_chr: 63,
    edge: 79,
    firefox: 67,
    and_ff: 67,
    // ie: Not supported
    opera: 50,
    op_mob: 46,
    safari: [11, 1],
    ios_saf: [11, 3],
    samsung: [8, 2],
    android: 63,
    and_qq: [10, 4],
    baidu: [13, 18],
    and_uc: [15, 5],
    kaios: [3, 0],
    node: [12, 17]
  });
  return {
    const: rawChecker({
      chrome: 49,
      and_chr: 49,
      edge: 12,
      // Prior to Firefox 13, <code>const</code> is implemented, but re-assignment is not failing.
      // Prior to Firefox 46, a <code>TypeError</code> was thrown on redeclaration instead of a <code>SyntaxError</code>.
      firefox: 36,
      and_ff: 36,
      // Not supported in for-in and for-of loops
      // ie: Not supported
      opera: 36,
      op_mob: 36,
      safari: [10, 0],
      ios_saf: [10, 0],
      // Before 5.0 supported correctly in strict mode, otherwise supported without block scope
      samsung: [5, 0],
      android: 37,
      and_qq: [10, 4],
      // Supported correctly in strict mode, otherwise supported without block scope
      baidu: [13, 18],
      and_uc: [12, 12],
      kaios: [2, 5],
      node: [6, 0]
    }),
    arrowFunction: rawChecker({
      chrome: 45,
      and_chr: 45,
      edge: 12,
      // The initial implementation of arrow functions in Firefox made them automatically strict. This has been changed as of Firefox 24. The use of <code>'use strict';</code> is now required.
      // Prior to Firefox 39, a line terminator (<code>\\n</code>) was incorrectly allowed after arrow function arguments. This has been fixed to conform to the ES2015 specification and code like <code>() \\n => {}</code> will now throw a <code>SyntaxError</code> in this and later versions.
      firefox: 39,
      and_ff: 39,
      // ie: Not supported,
      opera: 32,
      op_mob: 32,
      safari: 10,
      ios_saf: 10,
      samsung: [5, 0],
      android: 45,
      and_qq: [10, 4],
      baidu: [7, 12],
      and_uc: [12, 12],
      kaios: [2, 5],
      node: [6, 0]
    }),
    forOf: rawChecker({
      chrome: 38,
      and_chr: 38,
      edge: 12,
      // Prior to Firefox 51, using the for...of loop construct with the const keyword threw a SyntaxError ("missing = in const declaration").
      firefox: 51,
      and_ff: 51,
      // ie: Not supported,
      opera: 25,
      op_mob: 25,
      safari: 7,
      ios_saf: 7,
      samsung: [3, 0],
      android: 38,
      // and_qq: Unknown support
      // baidu: Unknown support
      // and_uc: Unknown support
      kaios: [3, 0],
      node: [0, 12]
    }),
    destructuring: rawChecker({
      chrome: 49,
      and_chr: 49,
      edge: 14,
      firefox: 41,
      and_ff: 41,
      // ie: Not supported,
      opera: 36,
      op_mob: 36,
      safari: 8,
      ios_saf: 8,
      samsung: [5, 0],
      android: 49,
      // and_qq: Unknown support
      // baidu: Unknown support
      // and_uc: Unknown support
      kaios: [2, 5],
      node: [6, 0]
    }),
    bigIntLiteral: rawChecker({
      chrome: 67,
      and_chr: 67,
      edge: 79,
      firefox: 68,
      and_ff: 68,
      // ie: Not supported,
      opera: 54,
      op_mob: 48,
      safari: 14,
      ios_saf: 14,
      samsung: [9, 2],
      android: 67,
      and_qq: [13, 1],
      baidu: [13, 18],
      and_uc: [15, 5],
      kaios: [3, 0],
      node: [10, 4]
    }),
    // Support syntax `import` and `export` and no limitations and bugs on Node.js
    // Not include `export * as namespace`
    module: rawChecker({
      chrome: 61,
      and_chr: 61,
      edge: 16,
      firefox: 60,
      and_ff: 60,
      // ie: Not supported,
      opera: 48,
      op_mob: 45,
      safari: [10, 1],
      ios_saf: [10, 3],
      samsung: [8, 0],
      android: 61,
      and_qq: [10, 4],
      baidu: [13, 18],
      and_uc: [15, 5],
      kaios: [3, 0],
      node: [12, 17]
    }),
    dynamicImport: es6DynamicImport,
    dynamicImportInWorker: es6DynamicImport && !anyNode,
    // browserslist does not have info about globalThis
    // so this is based on mdn-browser-compat-data
    globalThis: rawChecker({
      chrome: 71,
      and_chr: 71,
      edge: 79,
      firefox: 65,
      and_ff: 65,
      // ie: Not supported,
      opera: 58,
      op_mob: 50,
      safari: [12, 1],
      ios_saf: [12, 2],
      samsung: [10, 1],
      android: 71,
      // and_qq: Unknown support
      // baidu: Unknown support
      // and_uc: Unknown support
      kaios: [3, 0],
      node: 12
    }),
    optionalChaining: rawChecker({
      chrome: 80,
      and_chr: 80,
      edge: 80,
      firefox: 74,
      and_ff: 79,
      // ie: Not supported,
      opera: 67,
      op_mob: 64,
      safari: [13, 1],
      ios_saf: [13, 4],
      samsung: 13,
      android: 80,
      // and_qq: Not supported
      // baidu: Not supported
      // and_uc: Not supported
      kaios: [3, 0],
      node: 14
    }),
    templateLiteral: rawChecker({
      chrome: 41,
      and_chr: 41,
      edge: 13,
      firefox: 34,
      and_ff: 34,
      // ie: Not supported,
      opera: 29,
      op_mob: 64,
      safari: [9, 1],
      ios_saf: 9,
      samsung: 4,
      android: 41,
      and_qq: [10, 4],
      baidu: [7, 12],
      and_uc: [12, 12],
      kaios: [2, 5],
      node: 4
    }),
    asyncFunction: rawChecker({
      chrome: 55,
      and_chr: 55,
      edge: 15,
      firefox: 52,
      and_ff: 52,
      // ie: Not supported,
      opera: 42,
      op_mob: 42,
      safari: 11,
      ios_saf: 11,
      samsung: [6, 2],
      android: 55,
      and_qq: [13, 1],
      baidu: [13, 18],
      and_uc: [15, 5],
      kaios: 3,
      node: [7, 6]
    }),
    browser: browserProperty,
    electron: false,
    node: nodeProperty,
    nwjs: false,
    web: browserProperty,
    webworker: false,
    document: browserProperty,
    fetchWasm: browserProperty,
    global: nodeProperty,
    importScripts: false,
    importScriptsInWorker: true,
    nodeBuiltins: nodeProperty,
    nodePrefixForCoreModules: nodeProperty && !browsers.some((b) => b.startsWith("node 15")) && rawChecker({
      node: [14, 18]
    }),
    require: nodeProperty
  };
};

// src/config/target.ts
var getBrowserslistTargetHandler = memoize(() => browserslistTargetHandler_exports);
var getDefaultTarget = (context2) => {
  const browsers = getBrowserslistTargetHandler().load(null, context2);
  return browsers ? "browserslist" : "web";
};
var versionDependent = (major, minor) => {
  if (!major) {
    return () => void 0;
  }
  const nMajor = +major;
  const nMinor = minor ? +minor : 0;
  return (vMajor, vMinor = 0) => {
    return nMajor > vMajor || nMajor === vMajor && nMinor >= vMinor;
  };
};
var TARGETS = [
  [
    "browserslist / browserslist:env / browserslist:query / browserslist:path-to-config / browserslist:path-to-config:env",
    "Resolve features from browserslist. Will resolve browserslist config automatically. Only browser or node queries are supported (electron is not supported). Examples: 'browserslist:modern' to use 'modern' environment from browserslist config",
    /^browserslist(?::(.+))?$/,
    (rest, context2) => {
      const browserslistTargetHandler = getBrowserslistTargetHandler();
      const browsers = browserslistTargetHandler.load(
        rest ? rest.trim() : null,
        context2
      );
      if (!browsers) {
        throw new Error(`No browserslist config found to handle the 'browserslist' target.
See https://github.com/browserslist/browserslist#queries for possible ways to provide a config.
The recommended way is to add a 'browserslist' key to your package.json and list supported browsers (resp. node.js versions).
You can also more options via the 'target' option: 'browserslist' / 'browserslist:env' / 'browserslist:query' / 'browserslist:path-to-config' / 'browserslist:path-to-config:env'`);
      }
      return browserslistTargetHandler.resolve(browsers);
    }
  ],
  [
    "web",
    "Web browser.",
    /^web$/,
    () => {
      return {
        web: true,
        browser: true,
        webworker: null,
        node: false,
        electron: false,
        nwjs: false,
        document: true,
        importScriptsInWorker: true,
        fetchWasm: true,
        nodeBuiltins: false,
        importScripts: false,
        require: false,
        global: false
      };
    }
  ],
  [
    "webworker",
    "Web Worker, SharedWorker or Service Worker.",
    /^webworker$/,
    () => {
      return {
        web: true,
        browser: true,
        webworker: true,
        node: false,
        electron: false,
        nwjs: false,
        importScripts: true,
        importScriptsInWorker: true,
        fetchWasm: true,
        nodeBuiltins: false,
        require: false,
        document: false,
        global: false
      };
    }
  ],
  [
    "[async-]node[X[.Y]]",
    "Node.js in version X.Y. The 'async-' prefix will load chunks asynchronously via 'fs' and 'vm' instead of 'require()'. Examples: node14.5, async-node10.",
    /^(async-)?node((\d+)(?:\.(\d+))?)?$/,
    (asyncFlag, _, major, minor) => {
      const v = versionDependent(major, minor);
      return {
        node: true,
        electron: false,
        nwjs: false,
        web: false,
        webworker: false,
        browser: false,
        require: !asyncFlag,
        nodeBuiltins: true,
        // v16.0.0, v14.18.0
        nodePrefixForCoreModules: +major < 15 ? v(14, 18) : v(16),
        global: true,
        document: false,
        fetchWasm: false,
        importScripts: false,
        importScriptsInWorker: false,
        globalThis: v(12),
        const: v(6),
        templateLiteral: v(4),
        optionalChaining: v(14),
        arrowFunction: v(6),
        asyncFunction: v(7, 6),
        forOf: v(5),
        destructuring: v(6),
        bigIntLiteral: v(10, 4),
        dynamicImport: v(12, 17),
        dynamicImportInWorker: major ? false : void 0,
        module: v(12, 17)
      };
    }
  ],
  [
    "electron[X[.Y]]-main/preload/renderer",
    "Electron in version X.Y. Script is running in main, preload resp. renderer context.",
    /^electron((\d+)(?:\.(\d+))?)?-(main|preload|renderer)$/,
    (_, major, minor, context2) => {
      const v = versionDependent(major, minor);
      return {
        node: true,
        electron: true,
        web: context2 !== "main",
        webworker: false,
        browser: false,
        nwjs: false,
        electronMain: context2 === "main",
        electronPreload: context2 === "preload",
        electronRenderer: context2 === "renderer",
        global: true,
        nodeBuiltins: true,
        // 15.0.0	- Node.js	v16.5
        // 14.0.0 - Mode.js v14.17, but prefixes only since v14.18
        nodePrefixForCoreModules: v(15),
        require: true,
        document: context2 === "renderer",
        fetchWasm: context2 === "renderer",
        importScripts: false,
        importScriptsInWorker: true,
        globalThis: v(5),
        const: v(1, 1),
        templateLiteral: v(1, 1),
        optionalChaining: v(8),
        arrowFunction: v(1, 1),
        asyncFunction: v(1, 7),
        forOf: v(0, 36),
        destructuring: v(1, 1),
        bigIntLiteral: v(4),
        dynamicImport: v(11),
        dynamicImportInWorker: major ? false : void 0,
        module: v(11)
      };
    }
  ],
  [
    "nwjs[X[.Y]] / node-webkit[X[.Y]]",
    "NW.js in version X.Y.",
    /^(?:nwjs|node-webkit)((\d+)(?:\.(\d+))?)?$/,
    (_, major, minor) => {
      const v = versionDependent(major, minor);
      return {
        node: true,
        web: true,
        nwjs: true,
        webworker: null,
        browser: false,
        electron: false,
        global: true,
        nodeBuiltins: true,
        document: false,
        importScriptsInWorker: false,
        fetchWasm: false,
        importScripts: false,
        require: false,
        globalThis: v(0, 43),
        const: v(0, 15),
        templateLiteral: v(0, 13),
        optionalChaining: v(0, 44),
        arrowFunction: v(0, 15),
        asyncFunction: v(0, 21),
        forOf: v(0, 13),
        destructuring: v(0, 15),
        bigIntLiteral: v(0, 32),
        dynamicImport: v(0, 43),
        dynamicImportInWorker: major ? false : void 0,
        module: v(0, 43)
      };
    }
  ],
  [
    "esX",
    "EcmaScript in this version. Examples: es2020, es5.",
    /^es(\d+)$/,
    (version2) => {
      let v = +version2;
      if (v < 1e3) v = v + 2009;
      return {
        const: v >= 2015,
        templateLiteral: v >= 2015,
        optionalChaining: v >= 2020,
        arrowFunction: v >= 2015,
        forOf: v >= 2015,
        destructuring: v >= 2015,
        module: v >= 2015,
        asyncFunction: v >= 2017,
        globalThis: v >= 2020,
        bigIntLiteral: v >= 2020,
        dynamicImport: v >= 2020,
        dynamicImportInWorker: v >= 2020
      };
    }
  ]
];
var getTargetProperties = (target2, context2) => {
  for (const [, , regExp, handler] of TARGETS) {
    const match = regExp.exec(target2);
    if (match) {
      const [, ...args] = match;
      const result2 = handler(...args, context2);
      if (result2) return result2;
    }
  }
  throw new Error(
    `Unknown target '${target2}'. The following targets are supported:
${TARGETS.map(
      ([name2, description]) => `* ${name2}: ${description}`
    ).join("\n")}`
  );
};
var mergeTargetProperties = (targetProperties) => {
  const keys = /* @__PURE__ */ new Set();
  for (const tp of targetProperties) {
    for (const key of Object.keys(tp)) {
      keys.add(key);
    }
  }
  const result2 = {};
  for (const key of keys) {
    let hasTrue = false;
    let hasFalse = false;
    for (const tp of targetProperties) {
      const value = tp[key];
      switch (value) {
        case true:
          hasTrue = true;
          break;
        case false:
          hasFalse = true;
          break;
      }
    }
    if (hasTrue || hasFalse) result2[key] = hasFalse && hasTrue ? null : hasTrue;
  }
  return result2;
};
var getTargetsProperties = (targets, context2) => {
  return mergeTargetProperties(
    targets.map((t) => getTargetProperties(t, context2))
  );
};

// src/config/defaults.ts
var applyRspackOptionsDefaults = (options) => {
  F(options, "context", () => process.cwd());
  F(options, "target", () => {
    return getDefaultTarget(options.context);
  });
  const { mode: mode2, target: target2 } = options;
  (0, import_node_assert4.default)(!isNil(target2));
  const targetProperties = target2 === false ? false : typeof target2 === "string" ? getTargetProperties(target2, options.context) : getTargetsProperties(target2, options.context);
  const development = mode2 === "development";
  const production = mode2 === "production" || !mode2;
  if (typeof options.entry !== "function") {
    for (const key of Object.keys(options.entry)) {
      F(options.entry[key], "import", () => ["./src"]);
    }
  }
  F(options, "devtool", () => development ? "eval" : false);
  D(options, "watch", false);
  D(options, "profile", false);
  D(options, "bail", false);
  F(options, "cache", () => development);
  applyExperimentsDefaults(options.experiments);
  applySnapshotDefaults(options.snapshot, { production });
  applyModuleDefaults(options.module, {
    asyncWebAssembly: options.experiments.asyncWebAssembly,
    css: options.experiments.css,
    targetProperties
  });
  applyOutputDefaults(options.output, {
    context: options.context,
    targetProperties,
    isAffectedByBrowserslist: target2 === void 0 || typeof target2 === "string" && target2.startsWith("browserslist") || Array.isArray(target2) && target2.some((target3) => target3.startsWith("browserslist")),
    outputModule: options.experiments.outputModule,
    development,
    entry: options.entry,
    futureDefaults: options.experiments.futureDefaults
  });
  applybundlerInfoDefaults(
    options.experiments.rspackFuture,
    options.output.library
  );
  applyExternalsPresetsDefaults(options.externalsPresets, {
    targetProperties
  });
  F(options, "externalsType", () => {
    return options.output.library ? (
      // loose type 'string', actual type is "commonjs" | "var" | "commonjs2"....
      options.output.library.type
    ) : options.output.module ? "module-import" : "var";
  });
  applyNodeDefaults(options.node, {
    targetProperties,
    outputModule: options.output.module
  });
  applyLoaderDefaults(options.loader, {
    targetProperties,
    environment: options.output.environment
  });
  F(
    options,
    "performance",
    () => production && targetProperties && (targetProperties.browser || targetProperties.browser === null) ? {} : false
  );
  applyPerformanceDefaults(options.performance, {
    production
  });
  applyOptimizationDefaults(options.optimization, {
    production,
    development,
    css: options.experiments.css
  });
  options.resolve = cleverMerge(
    getResolveDefaults({
      context: options.context,
      targetProperties,
      mode: options.mode,
      css: options.experiments.css
    }),
    options.resolve
  );
  options.resolveLoader = cleverMerge(
    getResolveLoaderDefaults(),
    options.resolveLoader
  );
};
var applyRspackOptionsBaseDefaults = (options) => {
  F(options, "context", () => process.cwd());
  applyInfrastructureLoggingDefaults(options.infrastructureLogging);
};
var applyInfrastructureLoggingDefaults = (infrastructureLogging2) => {
  F(infrastructureLogging2, "stream", () => process.stderr);
  const tty = infrastructureLogging2.stream.isTTY && process.env.TERM !== "dumb";
  D(infrastructureLogging2, "level", "info");
  D(infrastructureLogging2, "debug", false);
  D(infrastructureLogging2, "colors", tty);
  D(infrastructureLogging2, "appendOnly", !tty);
};
var applyExperimentsDefaults = (experiments3) => {
  D(experiments3, "futureDefaults", false);
  D(experiments3, "lazyCompilation", false);
  D(experiments3, "asyncWebAssembly", experiments3.futureDefaults);
  D(experiments3, "css", experiments3.futureDefaults ? true : void 0);
  D(experiments3, "layers", false);
  D(experiments3, "topLevelAwait", true);
  D(experiments3, "incremental", {});
  if (typeof experiments3.incremental === "object") {
    D(experiments3.incremental, "make", true);
    D(experiments3.incremental, "emitAssets", true);
    D(experiments3.incremental, "inferAsyncModules", false);
    D(experiments3.incremental, "providedExports", false);
    D(experiments3.incremental, "moduleHashes", false);
    D(experiments3.incremental, "moduleCodegen", false);
    D(experiments3.incremental, "moduleRuntimeRequirements", false);
  }
  D(experiments3, "rspackFuture", {});
};
var applybundlerInfoDefaults = (rspackFuture, library3) => {
  if (typeof rspackFuture === "object") {
    D(rspackFuture, "bundlerInfo", {});
    if (typeof rspackFuture.bundlerInfo === "object") {
      D(
        rspackFuture.bundlerInfo,
        "version",
        require_package().version
      );
      D(rspackFuture.bundlerInfo, "bundler", "rspack");
      D(rspackFuture.bundlerInfo, "force", !library3);
    }
  }
};
var applySnapshotDefaults = (_snapshot, _env) => {
};
var applyJavascriptParserOptionsDefaults = (parserOptions) => {
  D(parserOptions, "dynamicImportMode", "lazy");
  D(parserOptions, "dynamicImportPrefetch", false);
  D(parserOptions, "dynamicImportPreload", false);
  D(parserOptions, "url", true);
  D(parserOptions, "exprContextCritical", true);
  D(parserOptions, "wrappedContextCritical", false);
  D(parserOptions, "strictExportPresence", false);
  D(parserOptions, "requireAsExpression", true);
  D(parserOptions, "requireDynamic", true);
  D(parserOptions, "requireResolve", true);
  D(parserOptions, "importDynamic", true);
  D(parserOptions, "worker", ["..."]);
  D(parserOptions, "importMeta", true);
};
var applyModuleDefaults = (module2, {
  asyncWebAssembly,
  css,
  targetProperties
}) => {
  assertNotNill(module2.parser);
  assertNotNill(module2.generator);
  F(module2.parser, ASSET_MODULE_TYPE, () => ({}));
  assertNotNill(module2.parser.asset);
  F(module2.parser.asset, "dataUrlCondition", () => ({}));
  if (typeof module2.parser.asset.dataUrlCondition === "object") {
    D(module2.parser.asset.dataUrlCondition, "maxSize", 8096);
  }
  F(module2.parser, "javascript", () => ({}));
  assertNotNill(module2.parser.javascript);
  applyJavascriptParserOptionsDefaults(module2.parser.javascript);
  if (css) {
    F(module2.parser, "css", () => ({}));
    assertNotNill(module2.parser.css);
    D(module2.parser.css, "namedExports", true);
    F(module2.parser, "css/auto", () => ({}));
    assertNotNill(module2.parser["css/auto"]);
    D(module2.parser["css/auto"], "namedExports", true);
    F(module2.parser, "css/module", () => ({}));
    assertNotNill(module2.parser["css/module"]);
    D(module2.parser["css/module"], "namedExports", true);
    F(module2.generator, "css", () => ({}));
    assertNotNill(module2.generator.css);
    D(
      module2.generator.css,
      "exportsOnly",
      !targetProperties || !targetProperties.document
    );
    D(module2.generator.css, "esModule", true);
    F(module2.generator, "css/auto", () => ({}));
    assertNotNill(module2.generator["css/auto"]);
    D(
      module2.generator["css/auto"],
      "exportsOnly",
      !targetProperties || !targetProperties.document
    );
    D(module2.generator["css/auto"], "exportsConvention", "as-is");
    D(
      module2.generator["css/auto"],
      "localIdentName",
      "[uniqueName]-[id]-[local]"
    );
    D(module2.generator["css/auto"], "esModule", true);
    F(module2.generator, "css/module", () => ({}));
    assertNotNill(module2.generator["css/module"]);
    D(
      module2.generator["css/module"],
      "exportsOnly",
      !targetProperties || !targetProperties.document
    );
    D(module2.generator["css/module"], "exportsConvention", "as-is");
    D(
      module2.generator["css/module"],
      "localIdentName",
      "[uniqueName]-[id]-[local]"
    );
    D(module2.generator["css/module"], "esModule", true);
  }
  A(module2, "defaultRules", () => {
    const esm = {
      type: "javascript/esm",
      resolve: {
        byDependency: {
          esm: {
            fullySpecified: true
          }
        }
      }
    };
    const commonjs = {
      type: "javascript/dynamic"
    };
    const rules = [
      {
        mimetype: "application/node",
        type: "javascript/auto"
      },
      {
        test: /\.json$/i,
        type: "json"
      },
      {
        mimetype: "application/json",
        type: "json"
      },
      {
        test: /\.mjs$/i,
        ...esm
      },
      {
        test: /\.js$/i,
        descriptionData: {
          type: "module"
        },
        ...esm
      },
      {
        test: /\.cjs$/i,
        ...commonjs
      },
      {
        test: /\.js$/i,
        descriptionData: {
          type: "commonjs"
        },
        ...commonjs
      },
      {
        mimetype: {
          or: ["text/javascript", "application/javascript"]
        },
        ...esm
      }
    ];
    if (asyncWebAssembly) {
      const wasm2 = {
        type: "webassembly/async",
        rules: [
          {
            descriptionData: {
              type: "module"
            },
            resolve: {
              fullySpecified: true
            }
          }
        ]
      };
      rules.push({
        test: /\.wasm$/i,
        ...wasm2
      });
      rules.push({
        mimetype: "application/wasm",
        ...wasm2
      });
    }
    if (css) {
      const resolve2 = {
        fullySpecified: true,
        preferRelative: true
      };
      rules.push({
        test: /\.css$/i,
        type: "css/auto",
        resolve: resolve2
      });
      rules.push({
        mimetype: "text/css+module",
        type: "css/module",
        resolve: resolve2
      });
      rules.push({
        mimetype: "text/css",
        type: "css",
        resolve: resolve2
      });
    }
    rules.push(
      {
        dependency: "url",
        oneOf: [
          {
            scheme: /^data$/,
            type: "asset/inline"
          },
          {
            type: "asset/resource"
          }
        ]
      },
      {
        with: { type: "json" },
        type: "json"
      }
    );
    return rules;
  });
};
var applyOutputDefaults = (output2, {
  context: context2,
  outputModule: outputModule2,
  targetProperties: tp,
  isAffectedByBrowserslist,
  development,
  entry: entry2,
  futureDefaults
}) => {
  const getLibraryName = (library3) => {
    const libraryName2 = typeof library3 === "object" && library3 && !Array.isArray(library3) && "type" in library3 ? library3.name : library3;
    if (Array.isArray(libraryName2)) {
      return libraryName2.join(".");
    }
    if (typeof libraryName2 === "object") {
      return getLibraryName(libraryName2.root);
    }
    if (typeof libraryName2 === "string") {
      return libraryName2;
    }
    return "";
  };
  F(output2, "uniqueName", () => {
    const libraryName2 = getLibraryName(output2.library).replace(
      /^\[(\\*[\w:]+\\*)\](\.)|(\.)\[(\\*[\w:]+\\*)\](?=\.|$)|\[(\\*[\w:]+\\*)\]/g,
      (m, a, d1, d2, b, c) => {
        const content = a || b || c;
        return content.startsWith("\\") && content.endsWith("\\") ? `${d2 || ""}[${content.slice(1, -1)}]${d1 || ""}` : "";
      }
    );
    if (libraryName2) return libraryName2;
    const pkgPath = import_node_path6.default.resolve(context2, "package.json");
    try {
      const packageInfo = JSON.parse(import_node_fs.default.readFileSync(pkgPath, "utf-8"));
      return packageInfo.name || "";
    } catch (err) {
      const e = err;
      if (e.code !== "ENOENT") {
        e.message += `
while determining default 'output.uniqueName' from 'name' in ${pkgPath}`;
        throw e;
      }
      return "";
    }
  });
  F(output2, "devtoolNamespace", () => output2.uniqueName);
  F(output2, "module", () => !!outputModule2);
  D(output2, "filename", output2.module ? "[name].mjs" : "[name].js");
  F(output2, "iife", () => !output2.module);
  F(output2, "chunkFilename", () => {
    const filename2 = output2.filename;
    if (typeof filename2 !== "function") {
      const hasName = filename2.includes("[name]");
      const hasId = filename2.includes("[id]");
      const hasChunkHash = filename2.includes("[chunkhash]");
      const hasContentHash = filename2.includes("[contenthash]");
      if (hasChunkHash || hasContentHash || hasName || hasId) return filename2;
      return filename2.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
    }
    return "[id].js";
  });
  F(output2, "cssFilename", () => {
    const filename2 = output2.filename;
    if (typeof filename2 !== "function") {
      return filename2.replace(/\.[mc]?js(\?|$)/, ".css$1");
    }
    return "[id].css";
  });
  F(output2, "cssChunkFilename", () => {
    const chunkFilename2 = output2.chunkFilename;
    if (typeof chunkFilename2 !== "function") {
      return chunkFilename2.replace(/\.[mc]?js(\?|$)/, ".css$1");
    }
    return "[id].css";
  });
  D(
    output2,
    "hotUpdateChunkFilename",
    `[id].[fullhash].hot-update.${output2.module ? "mjs" : "js"}`
  );
  D(output2, "hotUpdateMainFilename", "[runtime].[fullhash].hot-update.json");
  const uniqueNameId = Template.toIdentifier(output2.uniqueName);
  F(output2, "hotUpdateGlobal", () => `webpackHotUpdate${uniqueNameId}`);
  F(output2, "chunkLoadingGlobal", () => `webpackChunk${uniqueNameId}`);
  D(output2, "cssHeadDataCompression", !development);
  D(output2, "assetModuleFilename", "[hash][ext][query]");
  D(output2, "webassemblyModuleFilename", "[hash].module.wasm");
  F(output2, "path", () => import_node_path6.default.join(process.cwd(), "dist"));
  F(output2, "pathinfo", () => development);
  D(
    output2,
    "publicPath",
    tp && (tp.document || tp.importScripts) ? "auto" : ""
  );
  D(output2, "hashFunction", futureDefaults ? "xxhash64" : "md4");
  D(output2, "hashDigest", "hex");
  D(output2, "hashDigestLength", futureDefaults ? 16 : 20);
  D(output2, "strictModuleErrorHandling", false);
  if (output2.library) {
    F(output2.library, "type", () => output2.module ? "module" : "var");
  }
  F(output2, "chunkFormat", () => {
    if (tp) {
      const helpMessage = isAffectedByBrowserslist ? "Make sure that your 'browserslist' includes only platforms that support these features or select an appropriate 'target' to allow selecting a chunk format by default. Alternatively specify the 'output.chunkFormat' directly." : "Select an appropriate 'target' to allow selecting one by default, or specify the 'output.chunkFormat' directly.";
      if (output2.module) {
        if (tp.dynamicImport) return "module";
        if (tp.document) return "array-push";
        throw new Error(
          `For the selected environment is no default ESM chunk format available:
ESM exports can be chosen when 'import()' is available.
JSONP Array push can be chosen when 'document' is available.
${helpMessage}`
        );
      }
      if (tp.document) return "array-push";
      if (tp.require) return "commonjs";
      if (tp.nodeBuiltins) return "commonjs";
      if (tp.importScripts) return "array-push";
      throw new Error(
        `For the selected environment is no default script chunk format available:
JSONP Array push can be chosen when 'document' or 'importScripts' is available.
CommonJs exports can be chosen when 'require' or node builtins are available.
${helpMessage}`
      );
    }
    throw new Error(
      "Chunk format can't be selected by default when no target is specified"
    );
  });
  D(output2, "asyncChunks", true);
  F(output2, "chunkLoading", () => {
    if (tp) {
      switch (output2.chunkFormat) {
        case "array-push":
          if (tp.document) return "jsonp";
          if (tp.importScripts) return "import-scripts";
          break;
        case "commonjs":
          if (tp.require) return "require";
          if (tp.nodeBuiltins) return "async-node";
          break;
        case "module":
          if (tp.dynamicImport) return "import";
          break;
      }
      if (tp.require === null || tp.nodeBuiltins === null || tp.document === null || tp.importScripts === null) {
        return "universal";
      }
    }
    return false;
  });
  F(output2, "workerChunkLoading", () => {
    if (tp) {
      switch (output2.chunkFormat) {
        case "array-push":
          if (tp.importScriptsInWorker) return "import-scripts";
          break;
        case "commonjs":
          if (tp.require) return "require";
          if (tp.nodeBuiltins) return "async-node";
          break;
        case "module":
          if (tp.dynamicImportInWorker) return "import";
          break;
      }
      if (tp.require === null || tp.nodeBuiltins === null || tp.importScriptsInWorker === null) {
        return "universal";
      }
    }
    return false;
  });
  F(output2, "wasmLoading", () => {
    if (tp) {
      if (tp.fetchWasm) return "fetch";
      if (tp.nodeBuiltins)
        return output2.module ? "async-node-module" : "async-node";
      if (tp.nodeBuiltins === null || tp.fetchWasm === null) {
        return "universal";
      }
    }
    return false;
  });
  F(output2, "workerWasmLoading", () => output2.wasmLoading);
  F(output2, "globalObject", () => {
    if (tp) {
      if (tp.global) return "global";
      if (tp.globalThis) return "globalThis";
    }
    return "self";
  });
  D(output2, "importFunctionName", "import");
  D(output2, "importMetaName", "import.meta");
  F(output2, "clean", () => !!output2.clean);
  D(output2, "crossOriginLoading", false);
  D(output2, "workerPublicPath", "");
  D(output2, "sourceMapFilename", "[file].map[query]");
  F(output2, "scriptType", () => output2.module ? "module" : false);
  D(output2, "charset", true);
  D(output2, "chunkLoadTimeout", 12e4);
  const { trustedTypes: trustedTypes2 } = output2;
  if (trustedTypes2) {
    F(
      trustedTypes2,
      "policyName",
      () => output2.uniqueName.replace(/[^a-zA-Z0-9\-#=_/@.%]+/g, "_") || "webpack"
    );
  }
  const forEachEntry = (fn2) => {
    if (typeof entry2 === "function") {
      return;
    }
    for (const name2 of Object.keys(entry2)) {
      fn2(entry2[name2]);
    }
  };
  A(output2, "enabledLibraryTypes", () => {
    const enabledLibraryTypes2 = [];
    if (output2.library) {
      enabledLibraryTypes2.push(output2.library.type);
    }
    forEachEntry((desc) => {
      if (desc.library) {
        enabledLibraryTypes2.push(desc.library.type);
      }
    });
    return enabledLibraryTypes2;
  });
  A(output2, "enabledChunkLoadingTypes", () => {
    const enabledChunkLoadingTypes2 = /* @__PURE__ */ new Set();
    if (output2.chunkLoading) {
      enabledChunkLoadingTypes2.add(output2.chunkLoading);
    }
    if (output2.workerChunkLoading) {
      enabledChunkLoadingTypes2.add(output2.workerChunkLoading);
    }
    forEachEntry((desc) => {
      if (desc.chunkLoading) {
        enabledChunkLoadingTypes2.add(desc.chunkLoading);
      }
    });
    return Array.from(enabledChunkLoadingTypes2);
  });
  A(output2, "enabledWasmLoadingTypes", () => {
    const enabledWasmLoadingTypes2 = /* @__PURE__ */ new Set();
    if (output2.wasmLoading) {
      enabledWasmLoadingTypes2.add(output2.wasmLoading);
    }
    if (output2.workerWasmLoading) {
      enabledWasmLoadingTypes2.add(output2.workerWasmLoading);
    }
    return Array.from(enabledWasmLoadingTypes2);
  });
  const environment2 = output2.environment;
  const optimistic = (v) => v || v === void 0;
  const conditionallyOptimistic = (v, c) => v === void 0 && c || v;
  F(environment2, "globalThis", () => tp == null ? void 0 : tp.globalThis);
  F(environment2, "bigIntLiteral", () => tp && optimistic(tp.bigIntLiteral));
  F(environment2, "const", () => tp && optimistic(tp.const));
  F(environment2, "arrowFunction", () => tp && optimistic(tp.arrowFunction));
  F(environment2, "asyncFunction", () => tp && optimistic(tp.asyncFunction));
  F(environment2, "forOf", () => tp && optimistic(tp.forOf));
  F(environment2, "destructuring", () => tp && optimistic(tp.destructuring));
  F(
    environment2,
    "optionalChaining",
    () => tp && optimistic(tp.optionalChaining)
  );
  F(
    environment2,
    "nodePrefixForCoreModules",
    () => tp && optimistic(tp.nodePrefixForCoreModules)
  );
  F(environment2, "templateLiteral", () => tp && optimistic(tp.templateLiteral));
  F(
    environment2,
    "dynamicImport",
    () => conditionallyOptimistic(tp == null ? void 0 : tp.dynamicImport, output2.module)
  );
  F(
    environment2,
    "dynamicImportInWorker",
    () => conditionallyOptimistic(tp == null ? void 0 : tp.dynamicImportInWorker, output2.module)
  );
  F(
    environment2,
    "module",
    () => conditionallyOptimistic(tp == null ? void 0 : tp.module, output2.module)
  );
  F(environment2, "document", () => tp && optimistic(tp.document));
};
var applyExternalsPresetsDefaults = (externalsPresets2, { targetProperties }) => {
  D(externalsPresets2, "web", targetProperties == null ? void 0 : targetProperties.web);
  D(externalsPresets2, "node", targetProperties == null ? void 0 : targetProperties.node);
  D(externalsPresets2, "electron", targetProperties == null ? void 0 : targetProperties.electron);
  D(
    externalsPresets2,
    "electronMain",
    (targetProperties == null ? void 0 : targetProperties.electron) && targetProperties.electronMain
  );
  D(
    externalsPresets2,
    "electronPreload",
    (targetProperties == null ? void 0 : targetProperties.electron) && targetProperties.electronPreload
  );
  D(
    externalsPresets2,
    "electronRenderer",
    (targetProperties == null ? void 0 : targetProperties.electron) && targetProperties.electronRenderer
  );
  D(externalsPresets2, "nwjs", targetProperties == null ? void 0 : targetProperties.nwjs);
};
var applyLoaderDefaults = (loader2, { targetProperties, environment: environment2 }) => {
  F(loader2, "target", () => {
    if (targetProperties) {
      if (targetProperties.electron) {
        if (targetProperties.electronMain) return "electron-main";
        if (targetProperties.electronPreload) return "electron-preload";
        if (targetProperties.electronRenderer) return "electron-renderer";
        return "electron";
      }
      if (targetProperties.nwjs) return "nwjs";
      if (targetProperties.node) return "node";
      if (targetProperties.web) return "web";
    }
  });
  D(loader2, "environment", environment2);
};
var applyNodeDefaults = (node3, {
  outputModule: outputModule2,
  targetProperties
}) => {
  if (node3 === false) return;
  F(node3, "global", () => {
    if (targetProperties == null ? void 0 : targetProperties.global) return false;
    return "warn";
  });
  F(node3, "__dirname", () => {
    if (targetProperties == null ? void 0 : targetProperties.node)
      return outputModule2 ? "node-module" : "eval-only";
    return "warn-mock";
  });
  F(node3, "__filename", () => {
    if (targetProperties == null ? void 0 : targetProperties.node)
      return outputModule2 ? "node-module" : "eval-only";
    return "warn-mock";
  });
};
var applyPerformanceDefaults = (performance2, { production }) => {
  if (performance2 === false) return;
  D(performance2, "maxAssetSize", 25e4);
  D(performance2, "maxEntrypointSize", 25e4);
  F(performance2, "hints", () => production ? "warning" : false);
};
var applyOptimizationDefaults = (optimization2, {
  production,
  development,
  css
}) => {
  D(optimization2, "removeAvailableModules", false);
  D(optimization2, "removeEmptyChunks", true);
  D(optimization2, "mergeDuplicateChunks", true);
  F(optimization2, "moduleIds", () => {
    if (production) return "deterministic";
    if (development) return "named";
    return "natural";
  });
  F(optimization2, "chunkIds", () => {
    if (production) return "deterministic";
    if (development) return "named";
    return "natural";
  });
  F(optimization2, "sideEffects", () => production ? true : "flag");
  D(optimization2, "mangleExports", production);
  D(optimization2, "providedExports", true);
  D(optimization2, "usedExports", production);
  D(optimization2, "innerGraph", production);
  D(optimization2, "emitOnErrors", !production);
  D(optimization2, "runtimeChunk", false);
  D(optimization2, "realContentHash", production);
  D(optimization2, "minimize", production);
  D(optimization2, "concatenateModules", production);
  A(optimization2, "minimizer", () => [
    new SwcJsMinimizerRspackPlugin(),
    new LightningCssMinimizerRspackPlugin()
  ]);
  F(optimization2, "nodeEnv", () => {
    if (production) return "production";
    if (development) return "development";
    return false;
  });
  const { splitChunks } = optimization2;
  if (splitChunks) {
    A(
      splitChunks,
      "defaultSizeTypes",
      () => css ? ["javascript", "css", "unknown"] : ["javascript", "unknown"]
    );
    D(splitChunks, "hidePathInfo", production);
    D(splitChunks, "chunks", "async");
    D(splitChunks, "usedExports", optimization2.usedExports === true);
    D(splitChunks, "minChunks", 1);
    F(splitChunks, "minSize", () => production ? 2e4 : 1e4);
    F(
      splitChunks,
      "maxAsyncRequests",
      () => production ? 30 : Number.POSITIVE_INFINITY
    );
    F(
      splitChunks,
      "maxInitialRequests",
      () => production ? 30 : Number.POSITIVE_INFINITY
    );
    D(splitChunks, "automaticNameDelimiter", "-");
    const { cacheGroups } = splitChunks;
    if (cacheGroups) {
      F(cacheGroups, "default", () => ({
        idHint: "",
        reuseExistingChunk: true,
        minChunks: 2,
        priority: -20
      }));
      F(cacheGroups, "defaultVendors", () => ({
        idHint: "vendors",
        reuseExistingChunk: true,
        test: /[\\/]node_modules[\\/]/i,
        priority: -10
      }));
    }
  }
};
var getResolveLoaderDefaults = () => {
  const resolveOptions2 = {
    conditionNames: ["loader", "require", "node"],
    exportsFields: ["exports"],
    mainFields: ["loader", "main"],
    extensions: [".js"],
    mainFiles: ["index"]
  };
  return resolveOptions2;
};
var getResolveDefaults = ({
  context: context2,
  targetProperties,
  mode: mode2,
  css
}) => {
  const conditions = ["webpack"];
  conditions.push(mode2 === "development" ? "development" : "production");
  if (targetProperties) {
    if (targetProperties.webworker) conditions.push("worker");
    if (targetProperties.node) conditions.push("node");
    if (targetProperties.web) conditions.push("browser");
    if (targetProperties.electron) conditions.push("electron");
    if (targetProperties.nwjs) conditions.push("nwjs");
  }
  const jsExtensions = [".js", ".json", ".wasm"];
  const tp = targetProperties;
  const browserField = (tp == null ? void 0 : tp.web) && (!tp.node || tp.electron && tp.electronRenderer);
  const aliasFields = browserField ? ["browser"] : [];
  const mainFields = browserField ? ["browser", "module", "..."] : ["module", "..."];
  const cjsDeps = () => ({
    aliasFields,
    mainFields,
    conditionNames: ["require", "module", "..."],
    extensions: [...jsExtensions]
  });
  const esmDeps = () => ({
    aliasFields,
    mainFields,
    conditionNames: ["import", "module", "..."],
    extensions: [...jsExtensions]
  });
  const resolveOptions2 = {
    modules: ["node_modules"],
    conditionNames: conditions,
    mainFiles: ["index"],
    extensions: [],
    aliasFields: [],
    exportsFields: ["exports"],
    roots: [context2],
    mainFields: ["main"],
    importsFields: ["imports"],
    byDependency: {
      wasm: esmDeps(),
      esm: esmDeps(),
      url: {
        preferRelative: true
      },
      worker: {
        ...esmDeps(),
        preferRelative: true
      },
      commonjs: cjsDeps(),
      // amd: cjsDeps(),
      // for backward-compat: loadModule
      // loader: cjsDeps(),
      // for backward-compat: Custom Dependency and getResolve without dependencyType
      unknown: cjsDeps()
    }
  };
  if (css) {
    const styleConditions = [];
    styleConditions.push("webpack");
    styleConditions.push(mode2 === "development" ? "development" : "production");
    styleConditions.push("style");
    resolveOptions2.byDependency["css-import"] = {
      // We avoid using any main files because we have to be consistent with CSS `@import`
      // and CSS `@import` does not handle `main` files in directories,
      // you should always specify the full URL for styles
      mainFiles: [],
      mainFields: ["style", "..."],
      conditionNames: styleConditions,
      extensions: [".css"],
      preferRelative: true
    };
  }
  return resolveOptions2;
};
var D = (obj, prop, value) => {
  if (obj[prop] === void 0) {
    obj[prop] = value;
  }
};
var F = (obj, prop, factory) => {
  if (obj[prop] === void 0) {
    obj[prop] = factory();
  }
};
var A = (obj, prop, factory) => {
  const value = obj[prop];
  if (value === void 0) {
    obj[prop] = factory();
  } else if (Array.isArray(value)) {
    let newArray = void 0;
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      if (item === "...") {
        if (newArray === void 0) {
          newArray = value.slice(0, i);
          obj[prop] = newArray;
        }
        const items = factory();
        if (items !== void 0) {
          for (const item2 of items) {
            newArray.push(item2);
          }
        }
      } else if (newArray !== void 0) {
        newArray.push(item);
      }
    }
  }
};

// src/config/normalization.ts
var getNormalizedRspackOptions = (config2) => {
  return {
    ignoreWarnings: config2.ignoreWarnings !== void 0 ? config2.ignoreWarnings.map((ignore) => {
      if (typeof ignore === "function") {
        return ignore;
      }
      return (warning) => {
        return ignore.test(warning.message);
      };
    }) : void 0,
    name: config2.name,
    dependencies: config2.dependencies,
    context: config2.context,
    mode: config2.mode,
    entry: config2.entry === void 0 ? { main: {} } : typeof config2.entry === "function" ? /* @__PURE__ */ ((fn2) => () => Promise.resolve().then(fn2).then(getNormalizedEntryStatic))(config2.entry) : getNormalizedEntryStatic(config2.entry),
    output: nestedConfig(config2.output, (output2) => {
      const { library: library3 } = output2;
      const libraryAsName = library3;
      const libraryBase = typeof library3 === "object" && library3 && !Array.isArray(library3) && "type" in library3 ? library3 : libraryAsName || output2.libraryTarget ? {
        name: libraryAsName
      } : void 0;
      return {
        path: output2.path,
        pathinfo: output2.pathinfo,
        publicPath: output2.publicPath,
        filename: output2.filename,
        clean: output2.clean,
        chunkFormat: output2.chunkFormat,
        chunkLoading: output2.chunkLoading,
        chunkFilename: output2.chunkFilename,
        crossOriginLoading: output2.crossOriginLoading,
        cssHeadDataCompression: output2.cssHeadDataCompression,
        cssFilename: output2.cssFilename,
        cssChunkFilename: output2.cssChunkFilename,
        hotUpdateMainFilename: output2.hotUpdateMainFilename,
        hotUpdateChunkFilename: output2.hotUpdateChunkFilename,
        hotUpdateGlobal: output2.hotUpdateGlobal,
        assetModuleFilename: output2.assetModuleFilename,
        wasmLoading: output2.wasmLoading,
        enabledChunkLoadingTypes: output2.enabledChunkLoadingTypes ? [...output2.enabledChunkLoadingTypes] : ["..."],
        enabledWasmLoadingTypes: output2.enabledWasmLoadingTypes ? [...output2.enabledWasmLoadingTypes] : ["..."],
        webassemblyModuleFilename: output2.webassemblyModuleFilename,
        uniqueName: output2.uniqueName,
        chunkLoadingGlobal: output2.chunkLoadingGlobal,
        enabledLibraryTypes: output2.enabledLibraryTypes ? [...output2.enabledLibraryTypes] : ["..."],
        globalObject: output2.globalObject,
        importFunctionName: output2.importFunctionName,
        importMetaName: output2.importMetaName,
        iife: output2.iife,
        module: output2.module,
        sourceMapFilename: output2.sourceMapFilename,
        library: libraryBase && {
          type: output2.libraryTarget !== void 0 ? output2.libraryTarget : libraryBase.type,
          auxiliaryComment: output2.auxiliaryComment !== void 0 ? output2.auxiliaryComment : libraryBase.auxiliaryComment,
          amdContainer: libraryBase.amdContainer,
          export: output2.libraryExport !== void 0 ? output2.libraryExport : libraryBase.export,
          name: libraryBase.name,
          umdNamedDefine: output2.umdNamedDefine !== void 0 ? output2.umdNamedDefine : libraryBase.umdNamedDefine
        },
        strictModuleErrorHandling: output2.strictModuleErrorHandling ?? output2.strictModuleExceptionHandling,
        trustedTypes: optionalNestedConfig(
          output2.trustedTypes,
          (trustedTypes2) => {
            if (trustedTypes2 === true) return {};
            if (typeof trustedTypes2 === "string")
              return { policyName: trustedTypes2 };
            return { ...trustedTypes2 };
          }
        ),
        hashDigest: output2.hashDigest,
        hashDigestLength: output2.hashDigestLength,
        hashFunction: output2.hashFunction,
        hashSalt: output2.hashSalt,
        asyncChunks: output2.asyncChunks,
        workerChunkLoading: output2.workerChunkLoading,
        workerWasmLoading: output2.workerWasmLoading,
        workerPublicPath: output2.workerPublicPath,
        scriptType: output2.scriptType,
        devtoolNamespace: output2.devtoolNamespace,
        devtoolModuleFilenameTemplate: output2.devtoolModuleFilenameTemplate,
        devtoolFallbackModuleFilenameTemplate: output2.devtoolFallbackModuleFilenameTemplate,
        chunkLoadTimeout: output2.chunkLoadTimeout,
        charset: output2.charset,
        environment: cloneObject(output2.environment)
      };
    }),
    resolve: nestedConfig(config2.resolve, (resolve2) => ({
      ...resolve2,
      tsConfig: optionalNestedConfig(resolve2.tsConfig, (tsConfig) => {
        return typeof tsConfig === "string" ? { configFile: tsConfig } : tsConfig;
      })
    })),
    resolveLoader: nestedConfig(config2.resolveLoader, (resolve2) => ({
      ...resolve2,
      tsConfig: optionalNestedConfig(resolve2.tsConfig, (tsConfig) => {
        return typeof tsConfig === "string" ? { configFile: tsConfig } : tsConfig;
      })
    })),
    module: nestedConfig(config2.module, (module2) => ({
      noParse: module2.noParse,
      parser: keyedNestedConfig(
        module2.parser,
        cloneObject,
        {}
      ),
      generator: keyedNestedConfig(
        module2.generator,
        cloneObject,
        {}
      ),
      defaultRules: optionalNestedArray(module2.defaultRules, (r) => [...r]),
      rules: nestedArray(module2.rules, (r) => [...r])
    })),
    target: config2.target,
    externals: config2.externals,
    externalsType: config2.externalsType,
    externalsPresets: cloneObject(config2.externalsPresets),
    infrastructureLogging: cloneObject(config2.infrastructureLogging),
    devtool: config2.devtool,
    node: nestedConfig(
      config2.node,
      (node3) => node3 && {
        ...node3
      }
    ),
    loader: cloneObject(config2.loader),
    snapshot: nestedConfig(config2.snapshot, (_snapshot) => ({})),
    cache: optionalNestedConfig(config2.cache, (cache) => cache),
    stats: nestedConfig(config2.stats, (stats) => {
      if (stats === false) {
        return {
          preset: "none"
        };
      }
      if (stats === true) {
        return {
          preset: "normal"
        };
      }
      if (typeof stats === "string") {
        return {
          preset: stats
        };
      }
      return {
        ...stats
      };
    }),
    optimization: nestedConfig(config2.optimization, (optimization2) => {
      return {
        ...optimization2,
        runtimeChunk: getNormalizedOptimizationRuntimeChunk(
          optimization2.runtimeChunk
        ),
        splitChunks: nestedConfig(
          optimization2.splitChunks,
          (splitChunks) => splitChunks && {
            ...splitChunks,
            defaultSizeTypes: splitChunks.defaultSizeTypes ? [...splitChunks.defaultSizeTypes] : ["..."],
            cacheGroups: cloneObject(splitChunks.cacheGroups)
          }
        )
      };
    }),
    performance: config2.performance,
    plugins: nestedArray(config2.plugins, (p) => [...p]),
    experiments: nestedConfig(config2.experiments, (experiments3) => ({
      ...experiments3,
      lazyCompilation: optionalNestedConfig(
        experiments3.lazyCompilation,
        (options) => options === true ? {} : options
      ),
      incremental: optionalNestedConfig(
        experiments3.incremental,
        (options) => options === true ? {} : options
      )
    })),
    watch: config2.watch,
    watchOptions: cloneObject(config2.watchOptions),
    devServer: config2.devServer,
    profile: config2.profile,
    bail: config2.bail
  };
};
var getNormalizedEntryStatic = (entry2) => {
  if (typeof entry2 === "string") {
    return {
      main: {
        import: [entry2]
      }
    };
  }
  if (Array.isArray(entry2)) {
    return {
      main: {
        import: entry2
      }
    };
  }
  const result2 = {};
  for (const key of Object.keys(entry2)) {
    const value = entry2[key];
    if (typeof value === "string") {
      result2[key] = {
        import: [value]
      };
    } else if (Array.isArray(value)) {
      result2[key] = {
        import: value
      };
    } else {
      result2[key] = {
        import: Array.isArray(value.import) ? value.import : [value.import],
        runtime: value.runtime,
        publicPath: value.publicPath,
        baseUri: value.baseUri,
        chunkLoading: value.chunkLoading,
        asyncChunks: value.asyncChunks,
        filename: value.filename,
        library: value.library,
        layer: value.layer,
        dependOn: Array.isArray(value.dependOn) ? value.dependOn : value.dependOn ? [value.dependOn] : void 0
      };
    }
  }
  return result2;
};
var getNormalizedOptimizationRuntimeChunk = (runtimeChunk) => {
  if (runtimeChunk === void 0) return void 0;
  if (runtimeChunk === false) return false;
  if (runtimeChunk === "single") {
    return {
      name: "single"
    };
  }
  if (runtimeChunk === true || runtimeChunk === "multiple") {
    return {
      name: "multiple"
    };
  }
  if (runtimeChunk.name) {
    const opts = {
      name: runtimeChunk.name
    };
    return opts;
  }
};
var nestedConfig = (value, fn2) => value === void 0 ? fn2({}) : fn2(value);
var optionalNestedConfig = (value, fn2) => value === void 0 ? void 0 : fn2(value);
var nestedArray = (value, fn2) => Array.isArray(value) ? fn2(value) : fn2([]);
var optionalNestedArray = (value, fn2) => Array.isArray(value) ? fn2(value) : void 0;
var cloneObject = (value) => ({ ...value });
var keyedNestedConfig = (value, fn2, customKeys) => {
  const result2 = value === void 0 ? {} : Object.keys(value).reduce(
    (obj, key) => {
      obj[key] = (customKeys && key in customKeys ? customKeys[key] : fn2)(
        value[key]
      );
      return obj;
    },
    {}
  );
  if (customKeys) {
    for (const key of Object.keys(customKeys)) {
      if (!(key in result2)) {
        result2[key] = customKeys[key]({});
      }
    }
  }
  return result2;
};

// src/config/zod.ts
var import_node_path7 = __toESM(require("path"));
var import_zod = require("../compiled/zod/index.js");
var filenameTemplate = import_zod.z.string();
var filename = filenameTemplate.or(
  import_zod.z.function().args(import_zod.z.custom(), import_zod.z.custom().optional()).returns(import_zod.z.string())
);
var name = import_zod.z.string();
var dependencies = import_zod.z.array(name);
var context = import_zod.z.string().refine(
  (val) => import_node_path7.default.isAbsolute(val),
  (val) => ({
    message: `The provided value ${JSON.stringify(val)} must be an absolute path.`
  })
);
var mode = import_zod.z.enum([
  "development",
  "production",
  "none"
]);
var falsy = import_zod.z.union([
  import_zod.z.literal(false),
  import_zod.z.literal(0),
  import_zod.z.literal(""),
  import_zod.z.null(),
  import_zod.z.undefined()
]);
var publicPath = import_zod.z.literal("auto").or(filename);
var baseUri = import_zod.z.string();
var chunkLoadingType = import_zod.z.enum(["jsonp", "import-scripts", "require", "async-node", "import"]).or(import_zod.z.string());
var chunkLoading = import_zod.z.literal(false).or(chunkLoadingType);
var asyncChunks = import_zod.z.boolean();
var wasmLoadingType = import_zod.z.enum(["fetch-streaming", "fetch", "async-node"]).or(import_zod.z.string());
var wasmLoading = import_zod.z.literal(false).or(wasmLoadingType);
var scriptType = import_zod.z.enum(["text/javascript", "module"]).or(import_zod.z.literal(false));
var libraryCustomUmdObject = import_zod.z.strictObject({
  amd: import_zod.z.string().optional(),
  commonjs: import_zod.z.string().optional(),
  root: import_zod.z.string().or(import_zod.z.array(import_zod.z.string())).optional()
});
var libraryName = import_zod.z.string().or(import_zod.z.array(import_zod.z.string())).or(libraryCustomUmdObject);
var libraryCustomUmdCommentObject = import_zod.z.strictObject({
  amd: import_zod.z.string().optional(),
  commonjs: import_zod.z.string().optional(),
  commonjs2: import_zod.z.string().optional(),
  root: import_zod.z.string().optional()
});
var amdContainer = import_zod.z.string();
var auxiliaryComment = import_zod.z.string().or(libraryCustomUmdCommentObject);
var libraryExport = import_zod.z.string().or(import_zod.z.array(import_zod.z.string()));
var libraryType = import_zod.z.enum([
  "var",
  "module",
  "assign",
  "assign-properties",
  "this",
  "window",
  "self",
  "global",
  "commonjs",
  "commonjs2",
  "commonjs-module",
  "commonjs-static",
  "amd",
  "amd-require",
  "umd",
  "umd2",
  "jsonp",
  "system"
]).or(import_zod.z.string());
var umdNamedDefine = import_zod.z.boolean();
var libraryOptions = import_zod.z.strictObject({
  amdContainer: amdContainer.optional(),
  auxiliaryComment: auxiliaryComment.optional(),
  export: libraryExport.optional(),
  name: libraryName.optional(),
  type: libraryType,
  umdNamedDefine: umdNamedDefine.optional()
});
var library = libraryName.or(libraryOptions).optional();
var layer = import_zod.z.string().or(import_zod.z.null());
var entryFilename = filename;
var entryRuntime = import_zod.z.literal(false).or(import_zod.z.string());
var entryItem = import_zod.z.string().or(import_zod.z.array(import_zod.z.string()));
var entryDependOn = import_zod.z.string().or(import_zod.z.array(import_zod.z.string()));
var entryDescription = import_zod.z.strictObject({
  import: entryItem,
  runtime: entryRuntime.optional(),
  publicPath: publicPath.optional(),
  baseUri: baseUri.optional(),
  chunkLoading: chunkLoading.optional(),
  asyncChunks: asyncChunks.optional(),
  wasmLoading: wasmLoading.optional(),
  filename: entryFilename.optional(),
  library: libraryOptions.optional(),
  dependOn: entryDependOn.optional(),
  layer: layer.optional()
});
var entryUnnamed = entryItem;
var entryObject = import_zod.z.record(
  entryItem.or(entryDescription)
);
var entryStatic = entryObject.or(
  entryUnnamed
);
var entryDynamic = import_zod.z.function().returns(
  entryStatic.or(import_zod.z.promise(entryStatic))
);
var entry = entryStatic.or(entryDynamic);
var path6 = import_zod.z.string();
var pathinfo = import_zod.z.boolean().or(import_zod.z.literal("verbose"));
var assetModuleFilename = filename;
var webassemblyModuleFilename = import_zod.z.string();
var chunkFilename = filename;
var crossOriginLoading = import_zod.z.literal(false).or(
  import_zod.z.enum(["anonymous", "use-credentials"])
);
var cssFilename = filename;
var cssChunkFilename = filename;
var hotUpdateChunkFilename = filenameTemplate;
var hotUpdateMainFilename = filenameTemplate;
var hotUpdateGlobal = import_zod.z.string();
var uniqueName = import_zod.z.string();
var chunkLoadingGlobal = import_zod.z.string();
var enabledLibraryTypes = import_zod.z.array(
  libraryType
);
var clean = import_zod.z.boolean();
var outputModule = import_zod.z.boolean();
var strictModuleExceptionHandling = import_zod.z.boolean();
var strictModuleErrorHandling = import_zod.z.boolean();
var globalObject = import_zod.z.string();
var enabledWasmLoadingTypes = import_zod.z.array(
  wasmLoadingType
);
var importFunctionName = import_zod.z.string();
var importMetaName = import_zod.z.string();
var iife = import_zod.z.boolean();
var enabledChunkLoadingTypes = import_zod.z.array(
  chunkLoadingType
);
var chunkFormat = import_zod.z.literal(false).or(import_zod.z.string());
var workerPublicPath = import_zod.z.string();
var trustedTypes = import_zod.z.strictObject({
  policyName: import_zod.z.string().optional()
});
var hashDigest = import_zod.z.string();
var hashDigestLength = import_zod.z.number();
var hashFunction = import_zod.z.enum([
  "md4",
  "xxhash64"
]);
var hashSalt = import_zod.z.string();
var sourceMapFilename = import_zod.z.string();
var devtoolNamespace = import_zod.z.string();
var devtoolModuleFilenameTemplate = import_zod.z.union([
  import_zod.z.string(),
  import_zod.z.function(import_zod.z.tuple([import_zod.z.any()]), import_zod.z.any())
]);
var devtoolFallbackModuleFilenameTemplate = devtoolModuleFilenameTemplate;
var environment = import_zod.z.strictObject({
  arrowFunction: import_zod.z.boolean().optional(),
  asyncFunction: import_zod.z.boolean().optional(),
  bigIntLiteral: import_zod.z.boolean().optional(),
  const: import_zod.z.boolean().optional(),
  destructuring: import_zod.z.boolean().optional(),
  document: import_zod.z.boolean().optional(),
  dynamicImport: import_zod.z.boolean().optional(),
  dynamicImportInWorker: import_zod.z.boolean().optional(),
  forOf: import_zod.z.boolean().optional(),
  globalThis: import_zod.z.boolean().optional(),
  module: import_zod.z.boolean().optional(),
  nodePrefixForCoreModules: import_zod.z.boolean().optional(),
  optionalChaining: import_zod.z.boolean().optional(),
  templateLiteral: import_zod.z.boolean().optional()
});
var output = import_zod.z.strictObject({
  path: path6.optional(),
  pathinfo: pathinfo.optional(),
  clean: clean.optional(),
  publicPath: publicPath.optional(),
  filename: filename.optional(),
  chunkFilename: chunkFilename.optional(),
  crossOriginLoading: crossOriginLoading.optional(),
  cssFilename: cssFilename.optional(),
  cssHeadDataCompression: import_zod.z.boolean().optional(),
  cssChunkFilename: cssChunkFilename.optional(),
  hotUpdateMainFilename: hotUpdateMainFilename.optional(),
  hotUpdateChunkFilename: hotUpdateChunkFilename.optional(),
  hotUpdateGlobal: hotUpdateGlobal.optional(),
  assetModuleFilename: assetModuleFilename.optional(),
  uniqueName: uniqueName.optional(),
  chunkLoadingGlobal: chunkLoadingGlobal.optional(),
  enabledLibraryTypes: enabledLibraryTypes.optional(),
  library: library.optional(),
  libraryExport: libraryExport.optional(),
  libraryTarget: libraryType.optional(),
  umdNamedDefine: umdNamedDefine.optional(),
  auxiliaryComment: auxiliaryComment.optional(),
  module: outputModule.optional(),
  strictModuleExceptionHandling: strictModuleExceptionHandling.optional(),
  strictModuleErrorHandling: strictModuleErrorHandling.optional(),
  globalObject: globalObject.optional(),
  importFunctionName: importFunctionName.optional(),
  importMetaName: importMetaName.optional(),
  iife: iife.optional(),
  wasmLoading: wasmLoading.optional(),
  enabledWasmLoadingTypes: enabledWasmLoadingTypes.optional(),
  webassemblyModuleFilename: webassemblyModuleFilename.optional(),
  chunkFormat: chunkFormat.optional(),
  chunkLoading: chunkLoading.optional(),
  enabledChunkLoadingTypes: enabledChunkLoadingTypes.optional(),
  trustedTypes: import_zod.z.literal(true).or(import_zod.z.string()).or(trustedTypes).optional(),
  sourceMapFilename: sourceMapFilename.optional(),
  hashDigest: hashDigest.optional(),
  hashDigestLength: hashDigestLength.optional(),
  hashFunction: hashFunction.optional(),
  hashSalt: hashSalt.optional(),
  asyncChunks: asyncChunks.optional(),
  workerChunkLoading: chunkLoading.optional(),
  workerWasmLoading: wasmLoading.optional(),
  workerPublicPath: workerPublicPath.optional(),
  scriptType: scriptType.optional(),
  devtoolNamespace: devtoolNamespace.optional(),
  devtoolModuleFilenameTemplate: devtoolModuleFilenameTemplate.optional(),
  devtoolFallbackModuleFilenameTemplate: devtoolFallbackModuleFilenameTemplate.optional(),
  chunkLoadTimeout: import_zod.z.number().optional(),
  charset: import_zod.z.boolean().optional(),
  environment: environment.optional()
});
var resolveAlias = import_zod.z.record(
  import_zod.z.literal(false).or(import_zod.z.string()).or(import_zod.z.array(import_zod.z.string().or(import_zod.z.literal(false))))
);
var resolveTsConfigFile = import_zod.z.string();
var resolveTsConfig = resolveTsConfigFile.or(
  import_zod.z.strictObject({
    configFile: resolveTsConfigFile,
    references: import_zod.z.array(import_zod.z.string()).or(import_zod.z.literal("auto")).optional()
  })
);
var baseResolveOptions = import_zod.z.strictObject({
  alias: resolveAlias.optional(),
  conditionNames: import_zod.z.array(import_zod.z.string()).optional(),
  extensions: import_zod.z.array(import_zod.z.string()).optional(),
  fallback: resolveAlias.optional(),
  mainFields: import_zod.z.array(import_zod.z.string()).optional(),
  mainFiles: import_zod.z.array(import_zod.z.string()).optional(),
  modules: import_zod.z.array(import_zod.z.string()).optional(),
  preferRelative: import_zod.z.boolean().optional(),
  preferAbsolute: import_zod.z.boolean().optional(),
  symlinks: import_zod.z.boolean().optional(),
  enforceExtension: import_zod.z.boolean().optional(),
  importsFields: import_zod.z.array(import_zod.z.string()).optional(),
  descriptionFiles: import_zod.z.array(import_zod.z.string()).optional(),
  tsConfig: resolveTsConfig.optional(),
  fullySpecified: import_zod.z.boolean().optional(),
  exportsFields: import_zod.z.array(import_zod.z.string()).optional(),
  extensionAlias: import_zod.z.record(import_zod.z.string().or(import_zod.z.array(import_zod.z.string()))).optional(),
  aliasFields: import_zod.z.array(import_zod.z.string()).optional(),
  restrictions: import_zod.z.array(import_zod.z.string()).optional(),
  roots: import_zod.z.array(import_zod.z.string()).optional()
});
var resolveOptions = baseResolveOptions.extend({
  byDependency: import_zod.z.lazy(() => import_zod.z.record(resolveOptions)).optional()
});
var baseRuleSetCondition = import_zod.z.instanceof(RegExp).or(import_zod.z.string()).or(import_zod.z.function().args(import_zod.z.string()).returns(import_zod.z.boolean()));
var ruleSetCondition = baseRuleSetCondition.or(import_zod.z.lazy(() => ruleSetConditions)).or(import_zod.z.lazy(() => ruleSetLogicalConditions));
var ruleSetConditions = import_zod.z.lazy(
  () => import_zod.z.array(ruleSetCondition)
);
var ruleSetLogicalConditions = import_zod.z.strictObject({
  and: ruleSetConditions.optional(),
  or: ruleSetConditions.optional(),
  not: ruleSetCondition.optional()
});
var ruleSetLoader = import_zod.z.string();
var ruleSetLoaderOptions = import_zod.z.string().or(import_zod.z.record(import_zod.z.any()));
var ruleSetLoaderWithOptions = import_zod.z.strictObject({
  ident: import_zod.z.string().optional(),
  loader: ruleSetLoader,
  options: ruleSetLoaderOptions.optional()
});
var ruleSetUseItem = ruleSetLoader.or(ruleSetLoaderWithOptions);
var ruleSetUse = ruleSetUseItem.or(ruleSetUseItem.array()).or(
  import_zod.z.function().args(import_zod.z.custom()).returns(ruleSetUseItem.array())
);
var baseRuleSetRule = import_zod.z.strictObject({
  test: ruleSetCondition.optional(),
  exclude: ruleSetCondition.optional(),
  include: ruleSetCondition.optional(),
  issuer: ruleSetCondition.optional(),
  issuerLayer: ruleSetCondition.optional(),
  dependency: ruleSetCondition.optional(),
  resource: ruleSetCondition.optional(),
  resourceFragment: ruleSetCondition.optional(),
  resourceQuery: ruleSetCondition.optional(),
  scheme: ruleSetCondition.optional(),
  mimetype: ruleSetCondition.optional(),
  descriptionData: import_zod.z.record(ruleSetCondition).optional(),
  with: import_zod.z.record(ruleSetCondition).optional(),
  type: import_zod.z.string().optional(),
  layer: import_zod.z.string().optional(),
  loader: ruleSetLoader.optional(),
  options: ruleSetLoaderOptions.optional(),
  use: ruleSetUse.optional(),
  parser: import_zod.z.record(import_zod.z.any()).optional(),
  generator: import_zod.z.record(import_zod.z.any()).optional(),
  resolve: resolveOptions.optional(),
  sideEffects: import_zod.z.boolean().optional(),
  enforce: import_zod.z.literal("pre").or(import_zod.z.literal("post")).optional()
});
var ruleSetRule = baseRuleSetRule.extend({
  oneOf: import_zod.z.lazy(() => ruleSetRule.array()).optional(),
  rules: import_zod.z.lazy(() => ruleSetRule.array()).optional()
});
var ruleSetRules = import_zod.z.array(import_zod.z.literal("...").or(ruleSetRule).or(falsy));
var assetParserDataUrlOptions = import_zod.z.strictObject({
  maxSize: import_zod.z.number().optional()
});
var assetParserDataUrl = assetParserDataUrlOptions;
var assetParserOptions = import_zod.z.strictObject({
  dataUrlCondition: assetParserDataUrl.optional()
});
var cssParserNamedExports = import_zod.z.boolean();
var cssParserOptions = import_zod.z.strictObject({
  namedExports: cssParserNamedExports.optional()
});
var cssAutoParserOptions = import_zod.z.strictObject({
  namedExports: cssParserNamedExports.optional()
});
var cssModuleParserOptions = import_zod.z.strictObject({
  namedExports: cssParserNamedExports.optional()
});
var dynamicImportMode = import_zod.z.enum(["eager", "lazy", "weak", "lazy-once"]);
var dynamicImportPreload = import_zod.z.union([import_zod.z.boolean(), import_zod.z.number()]);
var dynamicImportPrefetch = import_zod.z.union([import_zod.z.boolean(), import_zod.z.number()]);
var dynamicImportFetchPriority = import_zod.z.enum(["low", "high", "auto"]);
var javascriptParserUrl = import_zod.z.union([import_zod.z.literal("relative"), import_zod.z.boolean()]);
var exprContextCritical = import_zod.z.boolean();
var wrappedContextCritical = import_zod.z.boolean();
var exportsPresence = import_zod.z.enum(["error", "warn", "auto"]).or(import_zod.z.literal(false));
var importExportsPresence = import_zod.z.enum(["error", "warn", "auto"]).or(import_zod.z.literal(false));
var reexportExportsPresence = import_zod.z.enum(["error", "warn", "auto"]).or(import_zod.z.literal(false));
var strictExportPresence = import_zod.z.boolean();
var worker = import_zod.z.array(import_zod.z.string()).or(import_zod.z.boolean());
var overrideStrict = import_zod.z.enum(["strict", "non-strict"]);
var requireAsExpression = import_zod.z.boolean();
var requireDynamic = import_zod.z.boolean();
var requireResolve = import_zod.z.boolean();
var importDynamic = import_zod.z.boolean();
var javascriptParserOptions = import_zod.z.strictObject({
  dynamicImportMode: dynamicImportMode.optional(),
  dynamicImportPreload: dynamicImportPreload.optional(),
  dynamicImportPrefetch: dynamicImportPrefetch.optional(),
  dynamicImportFetchPriority: dynamicImportFetchPriority.optional(),
  importMeta: import_zod.z.boolean().optional(),
  url: javascriptParserUrl.optional(),
  exprContextCritical: exprContextCritical.optional(),
  wrappedContextCritical: wrappedContextCritical.optional(),
  exportsPresence: exportsPresence.optional(),
  importExportsPresence: importExportsPresence.optional(),
  reexportExportsPresence: reexportExportsPresence.optional(),
  strictExportPresence: strictExportPresence.optional(),
  worker: worker.optional(),
  overrideStrict: overrideStrict.optional(),
  // #region Not available in webpack yet.
  requireAsExpression: requireAsExpression.optional(),
  requireDynamic: requireDynamic.optional(),
  requireResolve: requireResolve.optional(),
  importDynamic: importDynamic.optional()
  // #endregion
});
var parserOptionsByModuleTypeKnown = import_zod.z.strictObject({
  asset: assetParserOptions.optional(),
  css: cssParserOptions.optional(),
  "css/auto": cssAutoParserOptions.optional(),
  "css/module": cssModuleParserOptions.optional(),
  javascript: javascriptParserOptions.optional(),
  "javascript/auto": javascriptParserOptions.optional(),
  "javascript/dynamic": javascriptParserOptions.optional(),
  "javascript/esm": javascriptParserOptions.optional()
});
var parserOptionsByModuleTypeUnknown = import_zod.z.record(import_zod.z.record(import_zod.z.any()));
var parserOptionsByModuleType = parserOptionsByModuleTypeKnown.or(
  parserOptionsByModuleTypeUnknown
);
var assetGeneratorDataUrlOptions = import_zod.z.strictObject({
  encoding: import_zod.z.literal(false).or(import_zod.z.literal("base64")).optional(),
  mimetype: import_zod.z.string().optional()
});
var assetGeneratorDataUrlFunction = import_zod.z.function().args(
  import_zod.z.strictObject({
    content: import_zod.z.string(),
    filename: import_zod.z.string()
  })
).returns(import_zod.z.string());
var assetGeneratorDataUrl = assetGeneratorDataUrlOptions.or(
  assetGeneratorDataUrlFunction
);
var assetInlineGeneratorOptions = import_zod.z.strictObject({
  dataUrl: assetGeneratorDataUrl.optional()
});
var assetResourceGeneratorOptions = import_zod.z.strictObject({
  emit: import_zod.z.boolean().optional(),
  filename: filename.optional(),
  publicPath: publicPath.optional()
});
var assetGeneratorOptions = assetInlineGeneratorOptions.merge(
  assetResourceGeneratorOptions
);
var cssGeneratorExportsConvention = import_zod.z.enum([
  "as-is",
  "camel-case",
  "camel-case-only",
  "dashes",
  "dashes-only"
]);
var cssGeneratorExportsOnly = import_zod.z.boolean();
var cssGeneratorLocalIdentName = import_zod.z.string();
var cssGeneratorEsModule = import_zod.z.boolean();
var cssGeneratorOptions = import_zod.z.strictObject({
  exportsOnly: cssGeneratorExportsOnly.optional(),
  esModule: cssGeneratorEsModule.optional()
});
var cssAutoGeneratorOptions = import_zod.z.strictObject({
  exportsConvention: cssGeneratorExportsConvention.optional(),
  exportsOnly: cssGeneratorExportsOnly.optional(),
  localIdentName: cssGeneratorLocalIdentName.optional(),
  esModule: cssGeneratorEsModule.optional()
});
var cssModuleGeneratorOptions = import_zod.z.strictObject({
  exportsConvention: cssGeneratorExportsConvention.optional(),
  exportsOnly: cssGeneratorExportsOnly.optional(),
  localIdentName: cssGeneratorLocalIdentName.optional(),
  esModule: cssGeneratorEsModule.optional()
});
var generatorOptionsByModuleTypeKnown = import_zod.z.strictObject({
  asset: assetGeneratorOptions.optional(),
  "asset/inline": assetInlineGeneratorOptions.optional(),
  "asset/resource": assetResourceGeneratorOptions.optional(),
  css: cssGeneratorOptions.optional(),
  "css/auto": cssAutoGeneratorOptions.optional(),
  "css/module": cssModuleGeneratorOptions.optional()
});
var generatorOptionsByModuleTypeUnknown = import_zod.z.record(import_zod.z.record(import_zod.z.any()));
var generatorOptionsByModuleType = generatorOptionsByModuleTypeKnown.or(
  generatorOptionsByModuleTypeUnknown
);
var noParseOptionSingle = import_zod.z.string().or(import_zod.z.instanceof(RegExp)).or(import_zod.z.function().args(import_zod.z.string()).returns(import_zod.z.boolean()));
var noParseOption = noParseOptionSingle.or(import_zod.z.array(noParseOptionSingle));
var moduleOptions = import_zod.z.strictObject({
  defaultRules: ruleSetRules.optional(),
  rules: ruleSetRules.optional(),
  parser: parserOptionsByModuleType.optional(),
  generator: generatorOptionsByModuleType.optional(),
  noParse: noParseOption.optional()
});
var allowTarget = import_zod.z.union([
  import_zod.z.enum([
    "web",
    "webworker",
    "es3",
    "es5",
    "es2015",
    "es2016",
    "es2017",
    "es2018",
    "es2019",
    "es2020",
    "es2021",
    "es2022"
  ]),
  import_zod.z.literal("node"),
  import_zod.z.literal("async-node"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^node\d+$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^async-node\d+$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^node\d+\.\d+$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^async-node\d+\.\d+$/.test(value)
  ),
  import_zod.z.literal("electron-main"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+-main$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+\.\d+-main$/.test(value)
  ),
  import_zod.z.literal("electron-renderer"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+-renderer$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+\.\d+-renderer$/.test(value)
  ),
  import_zod.z.literal("electron-preload"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+-preload$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^electron\d+\.\d+-preload$/.test(value)
  ),
  import_zod.z.literal("nwjs"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^nwjs\d+$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^nwjs\d+\.\d+$/.test(value)
  ),
  import_zod.z.literal("node-webkit"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^node-webkit\d+$/.test(value)
  ),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^node-webkit\d+\.\d+$/.test(value)
  ),
  import_zod.z.literal("browserslist"),
  import_zod.z.custom(
    (value) => typeof value === "string" && /^browserslist:(.+)$/.test(value)
  )
]);
var target = import_zod.z.union([import_zod.z.literal(false), allowTarget, allowTarget.array()]);
var externalsType = import_zod.z.enum([
  "var",
  "module",
  "assign",
  "this",
  "window",
  "self",
  "global",
  "commonjs",
  "commonjs2",
  "commonjs-module",
  "commonjs-static",
  "amd",
  "amd-require",
  "umd",
  "umd2",
  "jsonp",
  "system",
  "promise",
  "import",
  "module-import",
  "script",
  "node-commonjs"
]);
var externalItemValue = import_zod.z.string().or(import_zod.z.boolean()).or(import_zod.z.string().array().min(1)).or(
  import_zod.z.record(import_zod.z.string().or(import_zod.z.string().array()))
);
var externalItemObjectUnknown = import_zod.z.record(
  externalItemValue
);
var externalItemFunctionData = import_zod.z.strictObject({
  context: import_zod.z.string().optional(),
  dependencyType: import_zod.z.string().optional(),
  request: import_zod.z.string().optional(),
  contextInfo: import_zod.z.strictObject({
    issuer: import_zod.z.string()
  }).optional()
});
var externalItem = import_zod.z.string().or(import_zod.z.instanceof(RegExp)).or(externalItemObjectUnknown).or(
  import_zod.z.function().args(
    externalItemFunctionData,
    import_zod.z.function().args(
      import_zod.z.instanceof(Error).optional(),
      externalItemValue.optional(),
      externalsType.optional()
    ).returns(import_zod.z.void())
  )
).or(
  import_zod.z.function().args(externalItemFunctionData).returns(import_zod.z.promise(externalItemValue))
);
var externals = externalItem.array().or(externalItem);
var externalsPresets = import_zod.z.strictObject({
  node: import_zod.z.boolean().optional(),
  web: import_zod.z.boolean().optional(),
  webAsync: import_zod.z.boolean().optional(),
  electron: import_zod.z.boolean().optional(),
  electronMain: import_zod.z.boolean().optional(),
  electronPreload: import_zod.z.boolean().optional(),
  electronRenderer: import_zod.z.boolean().optional(),
  nwjs: import_zod.z.boolean().optional()
});
var filterItemTypes = import_zod.z.instanceof(RegExp).or(import_zod.z.string()).or(import_zod.z.function().args(import_zod.z.string()).returns(import_zod.z.boolean()));
var filterTypes = filterItemTypes.array().or(filterItemTypes);
var infrastructureLogging = import_zod.z.strictObject({
  appendOnly: import_zod.z.boolean().optional(),
  colors: import_zod.z.boolean().optional(),
  console: import_zod.z.custom().optional(),
  debug: import_zod.z.boolean().or(filterTypes).optional(),
  level: import_zod.z.enum(["none", "error", "warn", "info", "log", "verbose"]).optional(),
  stream: import_zod.z.custom().optional()
});
var devTool = import_zod.z.literal(false).or(
  import_zod.z.enum([
    "eval",
    "cheap-source-map",
    "cheap-module-source-map",
    "source-map",
    "inline-cheap-source-map",
    "inline-cheap-module-source-map",
    "inline-source-map",
    "inline-nosources-cheap-source-map",
    "inline-nosources-cheap-module-source-map",
    "inline-nosources-source-map",
    "nosources-cheap-source-map",
    "nosources-cheap-module-source-map",
    "nosources-source-map",
    "hidden-nosources-cheap-source-map",
    "hidden-nosources-cheap-module-source-map",
    "hidden-nosources-source-map",
    "hidden-cheap-source-map",
    "hidden-cheap-module-source-map",
    "hidden-source-map",
    "eval-cheap-source-map",
    "eval-cheap-module-source-map",
    "eval-source-map",
    "eval-nosources-cheap-source-map",
    "eval-nosources-cheap-module-source-map",
    "eval-nosources-source-map"
  ])
);
var nodeOptions = import_zod.z.strictObject({
  __dirname: import_zod.z.boolean().or(import_zod.z.enum(["warn-mock", "mock", "eval-only", "node-module"])).optional(),
  __filename: import_zod.z.boolean().or(import_zod.z.enum(["warn-mock", "mock", "eval-only", "node-module"])).optional(),
  global: import_zod.z.boolean().or(import_zod.z.literal("warn")).optional()
});
var node = import_zod.z.literal(false).or(nodeOptions);
var loader = import_zod.z.record(import_zod.z.string(), import_zod.z.any());
var snapshotOptions = import_zod.z.strictObject({});
var cacheOptions = import_zod.z.boolean();
var statsPresets = import_zod.z.enum([
  "normal",
  "none",
  "verbose",
  "errors-only",
  "errors-warnings",
  "minimal",
  "detailed",
  "summary"
]);
var statsOptions = import_zod.z.strictObject({
  all: import_zod.z.boolean().optional(),
  preset: import_zod.z.boolean().or(statsPresets).optional(),
  assets: import_zod.z.boolean().optional(),
  chunks: import_zod.z.boolean().optional(),
  modules: import_zod.z.boolean().optional(),
  entrypoints: import_zod.z.boolean().or(import_zod.z.literal("auto")).optional(),
  chunkGroups: import_zod.z.boolean().optional(),
  warnings: import_zod.z.boolean().optional(),
  warningsCount: import_zod.z.boolean().optional(),
  errors: import_zod.z.boolean().optional(),
  errorsCount: import_zod.z.boolean().optional(),
  colors: import_zod.z.boolean().optional(),
  hash: import_zod.z.boolean().optional(),
  version: import_zod.z.boolean().optional(),
  reasons: import_zod.z.boolean().optional(),
  publicPath: import_zod.z.boolean().optional(),
  outputPath: import_zod.z.boolean().optional(),
  chunkModules: import_zod.z.boolean().optional(),
  chunkRelations: import_zod.z.boolean().optional(),
  ids: import_zod.z.boolean().optional(),
  timings: import_zod.z.boolean().optional(),
  builtAt: import_zod.z.boolean().optional(),
  moduleAssets: import_zod.z.boolean().optional(),
  nestedModules: import_zod.z.boolean().optional(),
  source: import_zod.z.boolean().optional(),
  logging: import_zod.z.enum(["none", "error", "warn", "info", "log", "verbose"]).or(import_zod.z.boolean()).optional(),
  loggingDebug: import_zod.z.boolean().or(filterTypes).optional(),
  loggingTrace: import_zod.z.boolean().optional(),
  runtimeModules: import_zod.z.boolean().optional(),
  children: import_zod.z.boolean().optional(),
  usedExports: import_zod.z.boolean().optional(),
  providedExports: import_zod.z.boolean().optional(),
  optimizationBailout: import_zod.z.boolean().optional(),
  groupModulesByType: import_zod.z.boolean().optional(),
  groupModulesByCacheStatus: import_zod.z.boolean().optional(),
  groupModulesByLayer: import_zod.z.boolean().optional(),
  groupModulesByAttributes: import_zod.z.boolean().optional(),
  groupModulesByPath: import_zod.z.boolean().optional(),
  groupModulesByExtension: import_zod.z.boolean().optional(),
  modulesSpace: import_zod.z.number().optional(),
  chunkModulesSpace: import_zod.z.number().optional(),
  nestedModulesSpace: import_zod.z.number().optional(),
  relatedAssets: import_zod.z.boolean().optional(),
  groupAssetsByEmitStatus: import_zod.z.boolean().optional(),
  groupAssetsByInfo: import_zod.z.boolean().optional(),
  groupAssetsByPath: import_zod.z.boolean().optional(),
  groupAssetsByExtension: import_zod.z.boolean().optional(),
  groupAssetsByChunk: import_zod.z.boolean().optional(),
  assetsSpace: import_zod.z.number().optional(),
  orphanModules: import_zod.z.boolean().optional(),
  excludeModules: import_zod.z.array(
    import_zod.z.string().or(import_zod.z.instanceof(RegExp)).or(import_zod.z.function(import_zod.z.tuple([import_zod.z.string(), import_zod.z.any(), import_zod.z.any()]), import_zod.z.boolean()))
  ).or(import_zod.z.string()).or(import_zod.z.instanceof(RegExp)).or(import_zod.z.function(import_zod.z.tuple([import_zod.z.string(), import_zod.z.any(), import_zod.z.any()]), import_zod.z.boolean())).or(import_zod.z.boolean()).optional(),
  excludeAssets: import_zod.z.array(
    import_zod.z.string().or(import_zod.z.instanceof(RegExp)).or(import_zod.z.function(import_zod.z.tuple([import_zod.z.string(), import_zod.z.any()]), import_zod.z.boolean()))
  ).or(import_zod.z.string()).or(import_zod.z.instanceof(RegExp)).or(import_zod.z.function(import_zod.z.tuple([import_zod.z.string(), import_zod.z.any()]), import_zod.z.boolean())).optional(),
  modulesSort: import_zod.z.string().optional(),
  chunkModulesSort: import_zod.z.string().optional(),
  nestedModulesSort: import_zod.z.string().optional(),
  chunksSort: import_zod.z.string().optional(),
  assetsSort: import_zod.z.string().optional(),
  performance: import_zod.z.boolean().optional(),
  env: import_zod.z.boolean().optional(),
  chunkGroupAuxiliary: import_zod.z.boolean().optional(),
  chunkGroupChildren: import_zod.z.boolean().optional(),
  chunkGroupMaxAssets: import_zod.z.number().optional(),
  dependentModules: import_zod.z.boolean().optional(),
  chunkOrigins: import_zod.z.boolean().optional(),
  runtime: import_zod.z.boolean().optional(),
  depth: import_zod.z.boolean().optional(),
  reasonsSpace: import_zod.z.number().optional(),
  groupReasonsByOrigin: import_zod.z.boolean().optional(),
  errorDetails: import_zod.z.boolean().optional(),
  errorStack: import_zod.z.boolean().optional(),
  moduleTrace: import_zod.z.boolean().optional(),
  cachedModules: import_zod.z.boolean().optional(),
  cachedAssets: import_zod.z.boolean().optional(),
  cached: import_zod.z.boolean().optional(),
  errorsSpace: import_zod.z.number().optional(),
  warningsSpace: import_zod.z.number().optional()
});
var statsValue = import_zod.z.boolean().or(statsPresets).or(statsOptions);
var plugin = import_zod.z.union([
  import_zod.z.custom(),
  falsy
]);
var plugins = plugin.array();
var optimizationRuntimeChunk = import_zod.z.enum(["single", "multiple"]).or(import_zod.z.boolean()).or(
  import_zod.z.strictObject({
    name: import_zod.z.string().or(
      import_zod.z.function().args(import_zod.z.strictObject({ name: import_zod.z.string() })).returns(import_zod.z.string())
    ).optional()
  })
);
var optimizationSplitChunksNameFunction = import_zod.z.function().args(
  import_zod.z.instanceof(Module).optional()
  // FIXME: z.array(z.instanceof(Chunk)).optional(), z.string()
  // FIXME: Chunk[],   															cacheChunkKey
);
var optimizationSplitChunksName = import_zod.z.string().or(import_zod.z.literal(false)).or(optimizationSplitChunksNameFunction);
var optimizationSplitChunksChunks = import_zod.z.enum(["initial", "async", "all"]).or(import_zod.z.instanceof(RegExp)).or(
  import_zod.z.function().args(import_zod.z.instanceof(Chunk, { message: "Input not instance of Chunk" })).returns(import_zod.z.boolean())
);
var optimizationSplitChunksSizes = import_zod.z.number().or(import_zod.z.record(import_zod.z.number()));
var optimizationSplitChunksDefaultSizeTypes = import_zod.z.array(import_zod.z.string());
var sharedOptimizationSplitChunksCacheGroup = {
  chunks: optimizationSplitChunksChunks.optional(),
  defaultSizeTypes: optimizationSplitChunksDefaultSizeTypes.optional(),
  minChunks: import_zod.z.number().min(1).optional(),
  usedExports: import_zod.z.boolean().optional(),
  name: optimizationSplitChunksName.optional(),
  minSize: optimizationSplitChunksSizes.optional(),
  maxSize: optimizationSplitChunksSizes.optional(),
  maxAsyncSize: optimizationSplitChunksSizes.optional(),
  maxInitialSize: optimizationSplitChunksSizes.optional(),
  maxAsyncRequests: import_zod.z.number().optional(),
  maxInitialRequests: import_zod.z.number().optional(),
  automaticNameDelimiter: import_zod.z.string().optional()
};
var optimizationSplitChunksCacheGroup = import_zod.z.strictObject({
  test: import_zod.z.string().or(import_zod.z.instanceof(RegExp)).or(
    import_zod.z.function().args(
      import_zod.z.instanceof(Module)
      /** FIXME: lack of CacheGroupContext */
    )
  ).optional(),
  priority: import_zod.z.number().optional(),
  enforce: import_zod.z.boolean().optional(),
  filename: import_zod.z.string().optional(),
  reuseExistingChunk: import_zod.z.boolean().optional(),
  type: import_zod.z.string().or(import_zod.z.instanceof(RegExp)).optional(),
  idHint: import_zod.z.string().optional(),
  ...sharedOptimizationSplitChunksCacheGroup
});
var optimizationSplitChunksOptions = import_zod.z.strictObject({
  cacheGroups: import_zod.z.record(import_zod.z.literal(false).or(optimizationSplitChunksCacheGroup)).optional(),
  fallbackCacheGroup: import_zod.z.strictObject({
    chunks: optimizationSplitChunksChunks.optional(),
    minSize: import_zod.z.number().optional(),
    maxSize: import_zod.z.number().optional(),
    maxAsyncSize: import_zod.z.number().optional(),
    maxInitialSize: import_zod.z.number().optional(),
    automaticNameDelimiter: import_zod.z.string().optional()
  }).optional(),
  hidePathInfo: import_zod.z.boolean().optional(),
  ...sharedOptimizationSplitChunksCacheGroup
});
var optimization = import_zod.z.strictObject({
  moduleIds: import_zod.z.enum(["named", "natural", "deterministic"]).optional(),
  chunkIds: import_zod.z.enum(["natural", "named", "deterministic"]).optional(),
  minimize: import_zod.z.boolean().optional(),
  minimizer: import_zod.z.literal("...").or(plugin).array().optional(),
  mergeDuplicateChunks: import_zod.z.boolean().optional(),
  splitChunks: import_zod.z.literal(false).or(optimizationSplitChunksOptions).optional(),
  runtimeChunk: optimizationRuntimeChunk.optional(),
  removeAvailableModules: import_zod.z.boolean().optional(),
  removeEmptyChunks: import_zod.z.boolean().optional(),
  realContentHash: import_zod.z.boolean().optional(),
  sideEffects: import_zod.z.enum(["flag"]).or(import_zod.z.boolean()).optional(),
  providedExports: import_zod.z.boolean().optional(),
  concatenateModules: import_zod.z.boolean().optional(),
  innerGraph: import_zod.z.boolean().optional(),
  usedExports: import_zod.z.enum(["global"]).or(import_zod.z.boolean()).optional(),
  mangleExports: import_zod.z.enum(["size", "deterministic"]).or(import_zod.z.boolean()).optional(),
  nodeEnv: import_zod.z.union([import_zod.z.string(), import_zod.z.literal(false)]).optional(),
  emitOnErrors: import_zod.z.boolean().optional()
});
var rspackFutureOptions = import_zod.z.strictObject({
  bundlerInfo: import_zod.z.strictObject({
    version: import_zod.z.string().optional(),
    bundler: import_zod.z.string().optional(),
    force: import_zod.z.boolean().or(import_zod.z.array(import_zod.z.enum(["version", "uniqueId"]))).optional()
  }).optional()
});
var listenOptions = import_zod.z.object({
  port: import_zod.z.number().optional(),
  host: import_zod.z.string().optional(),
  backlog: import_zod.z.number().optional(),
  path: import_zod.z.string().optional(),
  exclusive: import_zod.z.boolean().optional(),
  readableAll: import_zod.z.boolean().optional(),
  writableAll: import_zod.z.boolean().optional(),
  ipv6Only: import_zod.z.boolean().optional()
});
var lazyCompilationOptions = import_zod.z.object({
  backend: import_zod.z.object({
    client: import_zod.z.string().optional(),
    listen: import_zod.z.number().optional().or(listenOptions),
    protocol: import_zod.z.enum(["http", "https"]).optional()
  }).optional(),
  imports: import_zod.z.boolean().optional(),
  entries: import_zod.z.boolean().optional(),
  test: import_zod.z.instanceof(RegExp).or(import_zod.z.function().args(import_zod.z.custom()).returns(import_zod.z.boolean())).optional()
});
var incremental = import_zod.z.strictObject({
  make: import_zod.z.boolean().optional(),
  emitAssets: import_zod.z.boolean().optional(),
  inferAsyncModules: import_zod.z.boolean().optional(),
  providedExports: import_zod.z.boolean().optional(),
  moduleHashes: import_zod.z.boolean().optional(),
  moduleCodegen: import_zod.z.boolean().optional(),
  moduleRuntimeRequirements: import_zod.z.boolean().optional()
});
var experiments = import_zod.z.strictObject({
  lazyCompilation: import_zod.z.boolean().optional().or(lazyCompilationOptions),
  asyncWebAssembly: import_zod.z.boolean().optional(),
  outputModule: import_zod.z.boolean().optional(),
  topLevelAwait: import_zod.z.boolean().optional(),
  css: import_zod.z.boolean().optional(),
  layers: import_zod.z.boolean().optional(),
  incremental: import_zod.z.boolean().or(incremental).optional(),
  futureDefaults: import_zod.z.boolean().optional(),
  rspackFuture: rspackFutureOptions.optional()
});
var watch = import_zod.z.boolean();
var watchOptions = import_zod.z.strictObject({
  aggregateTimeout: import_zod.z.number().optional(),
  followSymlinks: import_zod.z.boolean().optional(),
  ignored: import_zod.z.string().array().or(import_zod.z.instanceof(RegExp)).or(import_zod.z.string()).optional(),
  poll: import_zod.z.number().or(import_zod.z.boolean()).optional(),
  stdin: import_zod.z.boolean().optional()
});
var devServer = import_zod.z.custom();
var ignoreWarnings = import_zod.z.instanceof(RegExp).or(
  import_zod.z.function().args(import_zod.z.instanceof(Error), import_zod.z.custom()).returns(import_zod.z.boolean())
).array();
var profile = import_zod.z.boolean();
var bail = import_zod.z.boolean();
var performance = import_zod.z.strictObject({
  assetFilter: import_zod.z.function().args(import_zod.z.string()).returns(import_zod.z.boolean()).optional(),
  hints: import_zod.z.enum(["error", "warning"]).or(import_zod.z.literal(false)).optional(),
  maxAssetSize: import_zod.z.number().optional(),
  maxEntrypointSize: import_zod.z.number().optional()
}).or(import_zod.z.literal(false));
var rspackOptions = import_zod.z.strictObject({
  name: name.optional(),
  dependencies: dependencies.optional(),
  entry: entry.optional(),
  output: output.optional(),
  target: target.optional(),
  mode: mode.optional(),
  experiments: experiments.optional(),
  externals: externals.optional(),
  externalsType: externalsType.optional(),
  externalsPresets: externalsPresets.optional(),
  infrastructureLogging: infrastructureLogging.optional(),
  cache: cacheOptions.optional(),
  context: context.optional(),
  devtool: devTool.optional(),
  node: node.optional(),
  loader: loader.optional(),
  ignoreWarnings: ignoreWarnings.optional(),
  watchOptions: watchOptions.optional(),
  watch: watch.optional(),
  stats: statsValue.optional(),
  snapshot: snapshotOptions.optional(),
  optimization: optimization.optional(),
  resolve: resolveOptions.optional(),
  resolveLoader: resolveOptions.optional(),
  plugins: plugins.optional(),
  devServer: devServer.optional(),
  module: moduleOptions.optional(),
  profile: profile.optional(),
  bail: bail.optional(),
  performance: performance.optional()
});

// src/builtin-plugin/EntryPlugin.ts
var EntryPlugin = create2(
  import_binding24.BuiltinPluginName.EntryPlugin,
  (context2, entry2, options = "") => {
    const entryOptions = typeof options === "string" ? { name: options } : options;
    return {
      context: context2,
      entry: entry2,
      options: getRawEntryOptions(entryOptions)
    };
  },
  "make"
);
function getRawEntryOptions(entry2) {
  const runtime = entry2.runtime;
  const chunkLoading2 = entry2.chunkLoading;
  return {
    name: entry2.name,
    publicPath: entry2.publicPath,
    baseUri: entry2.baseUri,
    runtime,
    chunkLoading: !isNil(chunkLoading2) ? getRawChunkLoading(chunkLoading2) : void 0,
    asyncChunks: entry2.asyncChunks,
    filename: entry2.filename,
    library: entry2.library && getRawLibrary(entry2.library),
    layer: entry2.layer ?? void 0,
    dependOn: entry2.dependOn
  };
}

// src/builtin-plugin/DynamicEntryPlugin.ts
var DynamicEntryPlugin = class extends RspackBuiltinPlugin {
  constructor(context2, entry2) {
    super();
    this.context = context2;
    this.entry = entry2;
    this.name = import_binding25.BuiltinPluginName.DynamicEntryPlugin;
    this.affectedHooks = "make";
  }
  raw(compiler) {
    const raw = {
      context: this.context,
      entry: async () => {
        const result2 = await this.entry();
        return Object.entries(result2).map(([name2, desc]) => {
          const options = EntryOptionPlugin_default.entryDescriptionToOptions(
            compiler,
            name2,
            desc
          );
          return {
            import: desc.import,
            options: getRawEntryOptions(options)
          };
        });
      }
    };
    return createBuiltinPlugin(this.name, raw);
  }
};

// src/builtin-plugin/ElectronTargetPlugin.ts
var import_binding26 = require("@rspack/binding");
var ElectronTargetPlugin = create2(
  import_binding26.BuiltinPluginName.ElectronTargetPlugin,
  (context2) => context2 ?? "none"
);

// src/builtin-plugin/EnableChunkLoadingPlugin.ts
var import_binding27 = require("@rspack/binding");
var EnableChunkLoadingPlugin = create2(
  import_binding27.BuiltinPluginName.EnableChunkLoadingPlugin,
  (type) => type
);

// src/builtin-plugin/EnableLibraryPlugin.ts
var import_binding28 = require("@rspack/binding");
var enabledTypes = /* @__PURE__ */ new WeakMap();
var getEnabledTypes = (compiler) => {
  let set = enabledTypes.get(compiler);
  if (set === void 0) {
    set = /* @__PURE__ */ new Set();
    enabledTypes.set(compiler, set);
  }
  return set;
};
var EnableLibraryPlugin = class extends RspackBuiltinPlugin {
  constructor(type) {
    super();
    this.type = type;
    this.name = import_binding28.BuiltinPluginName.EnableLibraryPlugin;
  }
  static setEnabled(compiler, type) {
    getEnabledTypes(compiler).add(type);
  }
  static checkEnabled(compiler, type) {
    if (!getEnabledTypes(compiler).has(type)) {
      throw new Error(
        `Library type "${type}" is not enabled. EnableLibraryPlugin need to be used to enable this type of library. This usually happens through the "output.enabledLibraryTypes" option. If you are using a function as entry which sets "library", you need to add all potential library types to "output.enabledLibraryTypes". These types are enabled: ${Array.from(getEnabledTypes(compiler)).join(", ")}`
      );
    }
  }
  raw(compiler) {
    const { type } = this;
    const enabled = getEnabledTypes(compiler);
    if (enabled.has(type)) return;
    enabled.add(type);
    return createBuiltinPlugin(this.name, type);
  }
};

// src/builtin-plugin/EnableWasmLoadingPlugin.ts
var import_binding29 = require("@rspack/binding");
var EnableWasmLoadingPlugin = create2(
  import_binding29.BuiltinPluginName.EnableWasmLoadingPlugin,
  (type) => type
);

// src/builtin-plugin/EnsureChunkConditionsPlugin.ts
var import_binding30 = require("@rspack/binding");
var EnsureChunkConditionsPlugin = create2(
  import_binding30.BuiltinPluginName.EnsureChunkConditionsPlugin,
  () => {
  }
);

// src/builtin-plugin/EvalDevToolModulePlugin.ts
var import_binding31 = require("@rspack/binding");
var EvalDevToolModulePlugin = create2(
  import_binding31.BuiltinPluginName.EvalDevToolModulePlugin,
  (options) => options,
  "compilation"
);

// src/builtin-plugin/EvalSourceMapDevToolPlugin.ts
var import_binding32 = require("@rspack/binding");
var EvalSourceMapDevToolPlugin = create2(
  import_binding32.BuiltinPluginName.EvalSourceMapDevToolPlugin,
  (options) => {
    return {
      filename: options.filename || void 0,
      append: options.append,
      namespace: options.namespace ?? "",
      columns: options.columns ?? true,
      noSources: options.noSources ?? false,
      publicPath: options.publicPath,
      module: options.module
    };
  },
  "compilation"
);

// src/builtin-plugin/ExternalsPlugin.ts
var import_binding33 = require("@rspack/binding");
var ExternalsPlugin = create2(
  import_binding33.BuiltinPluginName.ExternalsPlugin,
  (type, externals2) => {
    return {
      type,
      externals: (Array.isArray(externals2) ? externals2 : [externals2]).filter(Boolean).map(getRawExternalItem)
    };
  }
);
function getRawExternalItem(item) {
  if (typeof item === "string" || item instanceof RegExp) {
    return item;
  }
  if (typeof item === "function") {
    return async (ctx) => {
      return await new Promise((resolve2, reject) => {
        const promise = item(ctx, (err, result2, type) => {
          if (err) reject(err);
          resolve2({
            result: getRawExternalItemValueFormFnResult(result2),
            externalType: type
          });
        });
        if (promise == null ? void 0 : promise.then) {
          promise.then(
            (result2) => resolve2({
              result: getRawExternalItemValueFormFnResult(result2),
              externalType: void 0
            }),
            (e) => reject(e)
          );
        }
      });
    };
  }
  if (typeof item === "object") {
    return Object.fromEntries(
      Object.entries(item).map(([k, v]) => [k, getRawExternalItemValue(v)])
    );
  }
  throw new TypeError(`Unexpected type of external item: ${typeof item}`);
}
function getRawExternalItemValueFormFnResult(result2) {
  return result2 === void 0 ? result2 : getRawExternalItemValue(result2);
}
function getRawExternalItemValue(value) {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    return Object.fromEntries(
      Object.entries(value).map(([k, v]) => [k, Array.isArray(v) ? v : [v]])
    );
  }
  return value;
}

// src/builtin-plugin/FileUriPlugin.ts
var import_binding34 = require("@rspack/binding");
var FileUriPlugin = create2(
  import_binding34.BuiltinPluginName.FileUriPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/FlagDependencyExportsPlugin.ts
var import_binding35 = require("@rspack/binding");
var FlagDependencyExportsPlugin = create2(
  import_binding35.BuiltinPluginName.FlagDependencyExportsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/FlagDependencyUsagePlugin.ts
var import_binding36 = require("@rspack/binding");
var FlagDependencyUsagePlugin = create2(
  import_binding36.BuiltinPluginName.FlagDependencyUsagePlugin,
  (global) => global,
  "compilation"
);

// src/builtin-plugin/HotModuleReplacementPlugin.ts
var import_binding37 = require("@rspack/binding");
var HotModuleReplacementPlugin = class extends RspackBuiltinPlugin {
  constructor() {
    super(...arguments);
    this.name = import_binding37.BuiltinPluginName.HotModuleReplacementPlugin;
  }
  raw(compiler) {
    if (compiler.options.output.strictModuleErrorHandling === void 0) {
      compiler.options.output.strictModuleErrorHandling = true;
    }
    return createBuiltinPlugin(this.name, void 0);
  }
};

// src/builtin-plugin/HtmlRspackPlugin.ts
var import_node_fs2 = __toESM(require("fs"));
var import_node_path8 = __toESM(require("path"));
var import_binding38 = require("@rspack/binding");
var liteTapable3 = __toESM(require("@rspack/lite-tapable"));
var import_zod2 = require("../compiled/zod/index.js");

// ../../node_modules/.pnpm/zod-validation-error@3.3.1_zod@3.23.8/node_modules/zod-validation-error/dist/index.mjs
var zod = __toESM(require("../compiled/zod/index.js"), 1);
function isZodErrorLike(err) {
  return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
}
var ValidationError = class extends Error {
  name;
  details;
  constructor(message, options) {
    super(message, options);
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options) {
  if (options) {
    const cause = options.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";
function prefixMessage(message, prefix, prefixSeparator) {
  if (prefix !== null) {
    if (message.length > 0) {
      return [prefix, message].join(prefixSeparator);
    }
    return prefix;
  }
  if (message.length > 0) {
    return message;
  }
  return PREFIX;
}
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path10) {
  if (path10.length === 1) {
    return path10[0].toString();
  }
  return path10.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
function isNonEmptyArray(value) {
  return value.length !== 0;
}
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === "invalid_arguments") {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === "invalid_return_type") {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function fromZodError(zodError, options = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options);
}
function fromZodErrorWithoutRuntimeCheck(zodError, options = {}) {
  const {
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix = PREFIX,
    includePath = true
  } = options;
  const zodIssues = zodError.errors;
  const reason = zodIssues.length === 0 ? zodError.message : zodIssues.slice(0, maxIssuesInMessage).map(
    (issue) => getMessageFromZodIssue({
      issue,
      issueSeparator,
      unionSeparator,
      includePath
    })
  ).join(issueSeparator);
  const message = prefixMessage(reason, prefix, prefixSeparator);
  return new ValidationError(message, { cause: zodError });
}
var toValidationError = (options = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
};
function fromError(err, options = {}) {
  return toValidationError(options)(err);
}

// src/util/validate.ts
var ValidationError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
};
function validate(opts, schema) {
  const res = schema.safeParse(opts);
  if (!res.success) {
    const strategy = process.env.RSPACK_CONFIG_VALIDATE ?? "strict";
    if (strategy === "loose-silent") return;
    let friendlyErr;
    const originalIssues = res.error.issues;
    if (strategy === "loose-unrecognized-keys" && res.error.issues.length > 0) {
      const unrecognizedKeys = originalIssues.filter(
        (issue) => issue.code === "unrecognized_keys"
      );
      if (unrecognizedKeys.length > 0) {
        res.error.issues = unrecognizedKeys;
        friendlyErr = toValidationError2(res.error);
        console.error(friendlyErr.message);
        res.error.issues = originalIssues;
      }
      res.error.issues = originalIssues.filter(
        (issue) => issue.code !== "unrecognized_keys"
      );
      if (res.error.issues.length > 0) {
        throw toValidationError2(res.error);
      }
      return;
    }
    if (strategy === "loose-unrecognized-keys" || strategy === "loose") {
      friendlyErr = toValidationError2(res.error);
      console.error(friendlyErr.message);
      return;
    }
    friendlyErr = toValidationError2(res.error);
    throw friendlyErr;
  }
}
function toValidationError2(error) {
  const issueSeparator = "$issue$";
  const prefixSeparator = "$prefix$";
  const validationErr = fromZodError(error, {
    prefix: "Invalid configuration object. Rspack has been initialized using a configuration object that does not match the API schema.",
    prefixSeparator,
    issueSeparator
  });
  const [prefix, reason] = validationErr.message.split(prefixSeparator);
  const reasonItem = reason.split(issueSeparator);
  const message = `${prefix}
${reasonItem.map((item) => `- ${item}`).join("\n")}`;
  const friendlyErr = new ValidationError2(message);
  return friendlyErr;
}
function isValidate(opts, schema) {
  try {
    validate(opts, schema);
    return true;
  } catch {
    return false;
  }
}

// src/builtin-plugin/HtmlRspackPlugin.ts
var templateRenderFunction = import_zod2.z.function().args(import_zod2.z.record(import_zod2.z.string(), import_zod2.z.any())).returns(
  import_zod2.z.string().or(import_zod2.z.promise(import_zod2.z.string()))
);
var templateParamFunction = import_zod2.z.function().args(import_zod2.z.record(import_zod2.z.string(), import_zod2.z.any())).returns(
  import_zod2.z.record(import_zod2.z.string(), import_zod2.z.any()).or(import_zod2.z.promise(import_zod2.z.record(import_zod2.z.string(), import_zod2.z.any())))
);
var htmlRspackPluginOptions = import_zod2.z.strictObject({
  filename: import_zod2.z.string().optional(),
  template: import_zod2.z.string().refine(
    (val) => !val.includes("!"),
    () => ({
      message: "HtmlRspackPlugin does not support template path with loader yet"
    })
  ).optional(),
  templateContent: import_zod2.z.string().or(templateRenderFunction).optional(),
  templateParameters: import_zod2.z.record(import_zod2.z.string()).or(import_zod2.z.boolean()).or(templateParamFunction).optional(),
  inject: import_zod2.z.enum(["head", "body"]).or(import_zod2.z.boolean()).optional(),
  publicPath: import_zod2.z.string().optional(),
  base: import_zod2.z.string().or(
    import_zod2.z.strictObject({
      href: import_zod2.z.string().optional(),
      target: import_zod2.z.enum(["_self", "_blank", "_parent", "_top"]).optional()
    })
  ).optional(),
  scriptLoading: import_zod2.z.enum(["blocking", "defer", "module", "systemjs-module"]).optional(),
  chunks: import_zod2.z.string().array().optional(),
  excludeChunks: import_zod2.z.string().array().optional(),
  sri: import_zod2.z.enum(["sha256", "sha384", "sha512"]).optional(),
  minify: import_zod2.z.boolean().optional(),
  title: import_zod2.z.string().optional(),
  favicon: import_zod2.z.string().optional(),
  meta: import_zod2.z.record(import_zod2.z.string().or(import_zod2.z.record(import_zod2.z.string()))).optional(),
  hash: import_zod2.z.boolean().optional()
});
var HtmlRspackPluginImpl = create2(
  import_binding38.BuiltinPluginName.HtmlRspackPlugin,
  function(c = {}) {
    validate(c, htmlRspackPluginOptions);
    const meta = {};
    for (const key in c.meta) {
      const value = c.meta[key];
      if (typeof value === "string") {
        meta[key] = {
          name: key,
          content: value
        };
      } else {
        meta[key] = {
          name: key,
          ...value
        };
      }
    }
    const scriptLoading = c.scriptLoading ?? "defer";
    const configInject = c.inject ?? true;
    const inject = configInject === true ? scriptLoading === "blocking" ? "body" : "head" : configInject === false ? "false" : configInject;
    const base = typeof c.base === "string" ? { href: c.base } : c.base;
    let compilation = null;
    this.hooks.compilation.tap("HtmlRspackPlugin", (compilationInstance) => {
      compilation = compilationInstance;
      compilationOptionsMap.set(compilation, c);
    });
    this.hooks.done.tap("HtmlRspackPlugin", (stats) => {
      compilationHooksMap2.delete(stats.compilation);
      compilationOptionsMap.delete(stats.compilation);
    });
    function generateRenderData(data) {
      var _a, _b, _c, _d;
      const json = JSON.parse(data);
      if (typeof c.templateParameters !== "function") {
        json.compilation = compilation;
      }
      const renderTag = function() {
        return htmlTagObjectToString(this);
      };
      const renderTagList = function() {
        return this.join("");
      };
      if (Array.isArray((_b = (_a = json.htmlRspackPlugin) == null ? void 0 : _a.tags) == null ? void 0 : _b.headTags)) {
        for (const tag of json.htmlRspackPlugin.tags.headTags) {
          tag.toString = renderTag;
        }
        json.htmlRspackPlugin.tags.headTags.toString = renderTagList;
      }
      if (Array.isArray((_d = (_c = json.htmlRspackPlugin) == null ? void 0 : _c.tags) == null ? void 0 : _d.bodyTags)) {
        for (const tag of json.htmlRspackPlugin.tags.bodyTags) {
          tag.toString = renderTag;
        }
        json.htmlRspackPlugin.tags.bodyTags.toString = renderTagList;
      }
      return json;
    }
    let templateContent = c.templateContent;
    let templateFn = void 0;
    if (typeof templateContent === "function") {
      templateFn = async (data) => {
        try {
          const renderer = c.templateContent;
          if (c.templateParameters === false) {
            return await renderer({});
          }
          return await renderer(generateRenderData(data));
        } catch (e) {
          const error = new Error(
            `HtmlRspackPlugin: render template function failed, ${e.message}`
          );
          error.stack = e.stack;
          throw error;
        }
      };
      templateContent = "";
    } else if (c.template) {
      const filename2 = c.template.split("?")[0];
      if ([".js", ".cjs"].includes(import_node_path8.default.extname(filename2))) {
        templateFn = async (data) => {
          const context2 = this.options.context || process.cwd();
          const templateFilePath = import_node_path8.default.resolve(context2, filename2);
          if (!import_node_fs2.default.existsSync(templateFilePath)) {
            throw new Error(
              `HtmlRspackPlugin: could not load file \`${filename2}\` from \`${context2}\``
            );
          }
          try {
            const renderer = require(templateFilePath);
            if (c.templateParameters === false) {
              return await renderer({});
            }
            return await renderer(generateRenderData(data));
          } catch (e) {
            const error = new Error(
              `HtmlRspackPlugin: render template function failed, ${e.message}`
            );
            error.stack = e.stack;
            throw error;
          }
        };
      }
    }
    const rawTemplateParameters = c.templateParameters;
    let templateParameters;
    if (typeof rawTemplateParameters === "function") {
      templateParameters = async (data) => {
        const newData = await rawTemplateParameters(JSON.parse(data));
        return JSON.stringify(newData);
      };
    } else {
      templateParameters = rawTemplateParameters;
    }
    return {
      filename: c.filename,
      template: c.template,
      hash: c.hash,
      title: c.title,
      favicon: c.favicon,
      publicPath: c.publicPath,
      chunks: c.chunks,
      excludeChunks: c.excludeChunks,
      sri: c.sri,
      minify: c.minify,
      meta,
      scriptLoading,
      inject,
      base,
      templateFn,
      templateContent,
      templateParameters
    };
  }
);
function htmlTagObjectToString(tag) {
  const attributes = Object.keys(tag.attributes || {}).filter(
    (attributeName) => tag.attributes[attributeName] === "" || tag.attributes[attributeName]
  ).map((attributeName) => {
    if (tag.attributes[attributeName] === "true") {
      return attributeName;
    }
    return `${attributeName}="${tag.attributes[attributeName]}"`;
  });
  const res = `<${[tag.tagName].concat(attributes).join(" ")}${tag.voidTag && !tag.innerHTML ? "/" : ""}>${tag.innerHTML || ""}${tag.voidTag && !tag.innerHTML ? "" : `</${tag.tagName}>`}`;
  return res;
}
var compilationHooksMap2 = /* @__PURE__ */ new WeakMap();
var compilationOptionsMap = /* @__PURE__ */ new WeakMap();
var HtmlRspackPlugin = HtmlRspackPluginImpl;
var voidTags = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
HtmlRspackPlugin.createHtmlTagObject = (tagName, attributes, innerHTML) => {
  return {
    tagName,
    voidTag: voidTags.includes(tagName),
    attributes: attributes || {},
    innerHTML
  };
};
HtmlRspackPlugin.getCompilationOptions = (compilation) => {
  if (!(compilation instanceof Compilation)) {
    throw new TypeError(
      "The 'compilation' argument must be an instance of Compilation"
    );
  }
  return compilationOptionsMap.get(compilation);
};
HtmlRspackPlugin.getCompilationHooks = (compilation) => {
  if (!(compilation instanceof Compilation)) {
    throw new TypeError(
      "The 'compilation' argument must be an instance of Compilation"
    );
  }
  let hooks = compilationHooksMap2.get(compilation);
  if (hooks === void 0) {
    hooks = {
      beforeAssetTagGeneration: new liteTapable3.AsyncSeriesWaterfallHook([
        "data"
      ]),
      alterAssetTags: new liteTapable3.AsyncSeriesWaterfallHook(["data"]),
      alterAssetTagGroups: new liteTapable3.AsyncSeriesWaterfallHook(["data"]),
      afterTemplateExecution: new liteTapable3.AsyncSeriesWaterfallHook([
        "data"
      ]),
      beforeEmit: new liteTapable3.AsyncSeriesWaterfallHook(["data"]),
      afterEmit: new liteTapable3.AsyncSeriesWaterfallHook(["data"])
    };
    compilationHooksMap2.set(compilation, hooks);
  }
  return hooks;
};

// src/builtin-plugin/HttpExternalsRspackPlugin.ts
var import_binding39 = require("@rspack/binding");
var HttpExternalsRspackPlugin = create2(
  import_binding39.BuiltinPluginName.HttpExternalsRspackPlugin,
  (css, webAsync) => {
    return {
      css,
      webAsync
    };
  }
);

// src/builtin-plugin/IgnorePlugin.ts
var import_binding40 = require("@rspack/binding");
var import_zod3 = require("../compiled/zod/index.js");
var IgnorePluginOptions = import_zod3.z.union([
  import_zod3.z.object({
    contextRegExp: import_zod3.z.instanceof(RegExp).optional(),
    resourceRegExp: import_zod3.z.instanceof(RegExp)
  }),
  import_zod3.z.object({
    checkResource: import_zod3.z.function(import_zod3.z.tuple([import_zod3.z.string(), import_zod3.z.string()]), import_zod3.z.boolean())
  })
]);
var IgnorePlugin = create2(
  import_binding40.BuiltinPluginName.IgnorePlugin,
  (options) => {
    validate(options, IgnorePluginOptions);
    return options;
  }
);

// src/builtin-plugin/InferAsyncModulesPlugin.ts
var import_binding41 = require("@rspack/binding");
var InferAsyncModulesPlugin = create2(
  import_binding41.BuiltinPluginName.InferAsyncModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/JavascriptModulesPlugin.ts
var import_binding42 = require("@rspack/binding");
var liteTapable4 = __toESM(require("@rspack/lite-tapable"));
var compilationHooksMap3 = /* @__PURE__ */ new WeakMap();
var JavascriptModulesPlugin = class extends RspackBuiltinPlugin {
  constructor() {
    super(...arguments);
    this.name = import_binding42.BuiltinPluginName.JavascriptModulesPlugin;
    this.affectedHooks = "compilation";
  }
  raw() {
    return createBuiltinPlugin(this.name, void 0);
  }
  static getCompilationHooks(compilation) {
    if (!(compilation instanceof Compilation)) {
      throw new TypeError(
        "The 'compilation' argument must be an instance of Compilation"
      );
    }
    let hooks = compilationHooksMap3.get(compilation);
    if (hooks === void 0) {
      hooks = {
        chunkHash: new liteTapable4.SyncHook(["chunk", "hash"])
      };
      compilationHooksMap3.set(compilation, hooks);
    }
    return hooks;
  }
};

// src/builtin-plugin/JsLoaderRspackPlugin.ts
var import_binding43 = require("@rspack/binding");
var JsLoaderRspackPlugin = create2(
  import_binding43.BuiltinPluginName.JsLoaderRspackPlugin,
  (compiler) => runLoaders.bind(null, compiler),
  /* Not Inheretable */
  "thisCompilation"
);

// src/builtin-plugin/JsonModulesPlugin.ts
var import_binding44 = require("@rspack/binding");
var JsonModulesPlugin = create2(
  import_binding44.BuiltinPluginName.JsonModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/lazy-compilation/backend.ts
var getBackend = (options) => (compiler, callback) => {
  const logger = compiler.getInfrastructureLogger("LazyCompilationBackend");
  const activeModules = /* @__PURE__ */ new Map();
  const filesByKey = /* @__PURE__ */ new Map();
  const prefix = "/lazy-compilation-using-";
  const isHttps = options.protocol === "https" || typeof options.server === "object" && ("key" in options.server || "pfx" in options.server);
  const createServer = typeof options.server === "function" ? options.server : (() => {
    const http = isHttps ? require("https") : require("http");
    return http.createServer.bind(http, options.server);
  })();
  const listen = typeof options.listen === "function" ? options.listen : (server2) => {
    let listen2 = options.listen;
    if (typeof listen2 === "object" && !("port" in listen2))
      listen2 = { ...listen2, port: void 0 };
    server2.listen(listen2);
  };
  const protocol = options.protocol || (isHttps ? "https" : "http");
  const requestListener = (req, res) => {
    const keys = req.url.slice(prefix.length).split("@");
    req.socket.on("close", () => {
      setTimeout(() => {
        for (const key of keys) {
          const oldValue = activeModules.get(key) || 0;
          activeModules.set(key, oldValue - 1);
          if (oldValue === 1) {
            logger.log(
              `${key} is no longer in use. Next compilation will skip this module.`
            );
          }
        }
      }, 12e4);
    });
    req.socket.setNoDelay(true);
    res.writeHead(200, {
      "content-type": "text/event-stream",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "*",
      "Access-Control-Allow-Headers": "*"
    });
    res.write("\n");
    const moduleActivated = [];
    for (const key of keys) {
      const oldValue = activeModules.get(key) || 0;
      activeModules.set(key, oldValue + 1);
      if (oldValue === 0) {
        logger.log(`${key} is now in use and will be compiled.`);
        moduleActivated.push(key);
      }
    }
    if (moduleActivated.length && compiler.watching) {
      compiler.watching.lazyCompilationInvalidate(
        new Set(moduleActivated.map((key) => filesByKey.get(key)))
      );
    }
  };
  const server = createServer();
  server.on("request", requestListener);
  let isClosing = false;
  const sockets = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    sockets.add(socket);
    socket.on("close", () => {
      sockets.delete(socket);
    });
    if (isClosing) socket.destroy();
  });
  server.on("clientError", (e) => {
    if (e.message !== "Server is disposing") logger.warn(e);
  });
  server.on("listening", (err) => {
    if (err) return callback(err);
    const addr = server.address();
    if (typeof addr === "string")
      throw new Error("addr must not be a string");
    const urlBase = addr.address === "::" || addr.address === "0.0.0.0" ? `${protocol}://localhost:${addr.port}` : addr.family === "IPv6" ? `${protocol}://[${addr.address}]:${addr.port}` : `${protocol}://${addr.address}:${addr.port}`;
    logger.log(
      `Server-Sent-Events server for lazy compilation open at ${urlBase}.`
    );
    const result2 = {
      dispose(callback2) {
        isClosing = true;
        server.off("request", requestListener);
        server.close((err2) => {
          callback2(err2);
        });
        for (const socket of sockets) {
          socket.destroy(new Error("Server is disposing"));
        }
      },
      module({
        module: originalModule,
        path: path10
      }) {
        const key = `${encodeURIComponent(
          originalModule.replace(/\\/g, "/").replace(/@/g, "_")
        ).replace(/%(2F|3A|24|26|2B|2C|3B|3D|3A)/g, decodeURIComponent)}`;
        filesByKey.set(key, path10);
        const active = activeModules.get(key) > 0;
        return {
          client: `${options.client}?${encodeURIComponent(urlBase + prefix)}`,
          data: key,
          active
        };
      }
    };
    state.module = result2.module;
    state.dispose = result2.dispose;
    callback(null, result2);
  });
  listen(server);
};
var backend_default = getBackend;
function unimplemented() {
  throw new Error("access before initialization");
}
var state = {
  module: unimplemented,
  dispose: unimplemented
};
function dispose(callback) {
  state.dispose(callback);
  state.dispose = unimplemented;
  state.module = unimplemented;
}
function moduleImpl(args) {
  return state.module(args);
}

// src/builtin-plugin/lazy-compilation/lazyCompilation.ts
var import_binding45 = require("@rspack/binding");
var BuiltinLazyCompilationPlugin = create2(
  import_binding45.BuiltinPluginName.LazyCompilationPlugin,
  (module2, cacheable, entries, imports, test) => ({ module: module2, cacheable, imports, entries, test }),
  "thisCompilation"
);

// src/builtin-plugin/lazy-compilation/plugin.ts
var LazyCompilationPlugin = class {
  constructor(cacheable, entries, imports, test, backend) {
    this.cacheable = cacheable;
    this.entries = entries;
    this.imports = imports;
    this.test = test;
    this.backend = backend;
  }
  apply(compiler) {
    const backend = backend_default({
      ...this.backend,
      client: require.resolve(`../hot/lazy-compilation-${compiler.options.externalsPresets.node ? "node" : "web"}.js`)
    });
    new BuiltinLazyCompilationPlugin(
      moduleImpl,
      this.cacheable,
      this.entries,
      this.imports,
      this.test
    ).apply(compiler);
    let initialized = false;
    compiler.hooks.beforeCompile.tapAsync(
      "LazyCompilationPlugin",
      (_params, callback) => {
        if (initialized) return callback();
        backend(compiler, (err, result2) => {
          if (err) return callback(err);
          initialized = true;
          callback();
        });
      }
    );
    compiler.hooks.shutdown.tapAsync("LazyCompilationPlugin", (callback) => {
      dispose(callback);
    });
  }
};

// src/builtin-plugin/LimitChunkCountPlugin.ts
var import_binding46 = require("@rspack/binding");
var LimitChunkCountPlugin = create2(
  import_binding46.BuiltinPluginName.LimitChunkCountPlugin,
  (options) => {
    return options;
  }
);

// src/builtin-plugin/MangleExportsPlugin.ts
var import_binding47 = require("@rspack/binding");
var MangleExportsPlugin = create2(
  import_binding47.BuiltinPluginName.MangleExportsPlugin,
  (deterministic) => deterministic,
  "compilation"
);

// src/builtin-plugin/MergeDuplicateChunksPlugin.ts
var import_binding48 = require("@rspack/binding");
var MergeDuplicateChunksPlugin = create2(
  import_binding48.BuiltinPluginName.MergeDuplicateChunksPlugin,
  () => {
  }
);

// src/builtin-plugin/ModuleChunkFormatPlugin.ts
var import_binding49 = require("@rspack/binding");
var ModuleChunkFormatPlugin = create2(
  import_binding49.BuiltinPluginName.ModuleChunkFormatPlugin,
  () => {
  }
);

// src/builtin-plugin/ModuleConcatenationPlugin.ts
var import_binding50 = require("@rspack/binding");
var ModuleConcatenationPlugin = create2(
  import_binding50.BuiltinPluginName.ModuleConcatenationPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/NamedChunkIdsPlugin.ts
var import_binding51 = require("@rspack/binding");
var NamedChunkIdsPlugin = create2(
  import_binding51.BuiltinPluginName.NamedChunkIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/NamedModuleIdsPlugin.ts
var import_binding52 = require("@rspack/binding");
var NamedModuleIdsPlugin = create2(
  import_binding52.BuiltinPluginName.NamedModuleIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/NaturalChunkIdsPlugin.ts
var import_binding53 = require("@rspack/binding");
var NaturalChunkIdsPlugin = create2(
  import_binding53.BuiltinPluginName.NaturalChunkIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/NaturalModuleIdsPlugin.ts
var import_binding54 = require("@rspack/binding");
var NaturalModuleIdsPlugin = create2(
  import_binding54.BuiltinPluginName.NaturalModuleIdsPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/NodeTargetPlugin.ts
var import_binding55 = require("@rspack/binding");
var NodeTargetPlugin = create2(
  import_binding55.BuiltinPluginName.NodeTargetPlugin,
  () => void 0
);

// src/builtin-plugin/ProgressPlugin.ts
var import_binding56 = require("@rspack/binding");
var ProgressPlugin = create2(
  import_binding56.BuiltinPluginName.ProgressPlugin,
  (progress = {}) => {
    if (typeof progress === "function") {
      return {
        handler: (percentage, msg, items) => {
          progress(percentage, msg, ...items);
        }
      };
    }
    return progress;
  }
);

// src/builtin-plugin/ProvidePlugin.ts
var import_binding57 = require("@rspack/binding");
var ProvidePlugin = create2(
  import_binding57.BuiltinPluginName.ProvidePlugin,
  (provide) => {
    const entries = Object.entries(provide).map(([key, value]) => {
      if (typeof value === "string") {
        value = [value];
      }
      return [key, value];
    });
    return Object.fromEntries(entries);
  }
);

// src/builtin-plugin/RealContentHashPlugin.ts
var import_binding58 = require("@rspack/binding");
var RealContentHashPlugin = create2(
  import_binding58.BuiltinPluginName.RealContentHashPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/RemoveEmptyChunksPlugin.ts
var import_binding59 = require("@rspack/binding");
var RemoveEmptyChunksPlugin = create2(
  import_binding59.BuiltinPluginName.RemoveEmptyChunksPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/RuntimeChunkPlugin.ts
var import_binding60 = require("@rspack/binding");
var RuntimeChunkPlugin = create2(
  import_binding60.BuiltinPluginName.RuntimeChunkPlugin,
  (options) => options,
  "thisCompilation"
);

// src/builtin-plugin/RuntimePlugin.ts
var import_binding61 = require("@rspack/binding");
var RuntimePlugin = create2(
  import_binding61.BuiltinPluginName.RuntimePlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/SideEffectsFlagPlugin.ts
var import_binding62 = require("@rspack/binding");
var SideEffectsFlagPlugin = create2(
  import_binding62.BuiltinPluginName.SideEffectsFlagPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/SizeLimitsPlugin.ts
var import_binding63 = require("@rspack/binding");
var SizeLimitsPlugin = create2(
  import_binding63.BuiltinPluginName.SizeLimitsPlugin,
  (options) => {
    const hints = options.hints === false ? void 0 : options.hints;
    return { ...options, hints };
  }
);

// src/builtin-plugin/SourceMapDevToolPlugin.ts
var import_binding64 = require("@rspack/binding");

// src/lib/ModuleFilenameHelpers.ts
var ModuleFilenameHelpers_exports = {};
__export(ModuleFilenameHelpers_exports, {
  asRegExp: () => asRegExp,
  matchObject: () => matchObject,
  matchPart: () => matchPart
});
var asRegExp = (test) => {
  if (typeof test === "string") {
    return new RegExp(`^${test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}`);
  }
  return test;
};
var matchPart = (str, test) => {
  if (!test) return true;
  if (Array.isArray(test)) {
    return test.map(asRegExp).some((regExp) => regExp.test(str));
  }
  return asRegExp(test).test(str);
};
var matchObject = (obj, str) => {
  if (obj.test) {
    if (!matchPart(str, obj.test)) {
      return false;
    }
  }
  if (obj.include) {
    if (!matchPart(str, obj.include)) {
      return false;
    }
  }
  if (obj.exclude) {
    if (matchPart(str, obj.exclude)) {
      return false;
    }
  }
  return true;
};

// src/builtin-plugin/SourceMapDevToolPlugin.ts
var SourceMapDevToolPlugin = create2(
  import_binding64.BuiltinPluginName.SourceMapDevToolPlugin,
  (options) => {
    const { test, include, exclude, ...rest } = options;
    const rawOptions = rest;
    if (test || include || exclude) {
      rawOptions.test = (text) => matchObject({ test, include, exclude }, text);
    }
    return rawOptions;
  },
  "compilation"
);

// src/builtin-plugin/SplitChunksPlugin.ts
var import_node_assert5 = __toESM(require("assert"));
var import_binding65 = require("@rspack/binding");

// src/util/SplitChunkSize.ts
var JsSplitChunkSizes = class {
  static __to_binding(sizes) {
    if (typeof sizes === "number") {
      return sizes;
    }
    if (sizes && typeof sizes === "object") {
      const chunkSizes = {
        sizes
      };
      return chunkSizes;
    }
    return sizes;
  }
};

// src/builtin-plugin/SplitChunksPlugin.ts
var SplitChunksPlugin = class extends RspackBuiltinPlugin {
  constructor(options) {
    super();
    this.options = options;
    this.name = import_binding65.BuiltinPluginName.SplitChunksPlugin;
    this.affectedHooks = "thisCompilation";
  }
  raw(compiler) {
    const rawOptions = toRawSplitChunksOptions(this.options, compiler);
    (0, import_node_assert5.default)(typeof rawOptions !== "undefined");
    return createBuiltinPlugin(this.name, rawOptions);
  }
};
function toRawSplitChunksOptions(sc, compiler) {
  if (!sc) {
    return;
  }
  function getName(name3) {
    if (typeof name3 === "function") {
      return (ctx) => {
        if (typeof ctx.module === "undefined") {
          return name3(void 0);
        }
        return name3(
          Module.__from_binding(ctx.module, compiler._lastCompilation),
          getChunks(ctx.chunks),
          ctx.cacheGroupKey
        );
      };
    }
    return name3;
  }
  function getTest(test) {
    if (typeof test === "function") {
      return (ctx) => {
        if (typeof ctx.module === "undefined") {
          return test(void 0);
        }
        return test(
          Module.__from_binding(ctx.module, compiler._lastCompilation)
        );
      };
    }
    return test;
  }
  function getChunks(chunks2) {
    if (typeof chunks2 === "function") {
      return (chunk) => chunks2(
        Chunk.__from_binding(
          chunk,
          compiler._lastCompilation.__internal_getInner()
        )
      );
    }
    return chunks2;
  }
  const {
    name: name2,
    chunks,
    defaultSizeTypes,
    cacheGroups = {},
    fallbackCacheGroup,
    minSize,
    maxSize,
    maxAsyncSize,
    maxInitialSize,
    ...passThrough
  } = sc;
  return {
    name: getName(name2),
    chunks: getChunks(chunks),
    defaultSizeTypes: defaultSizeTypes || ["javascript", "unknown"],
    cacheGroups: Object.entries(cacheGroups).filter(([_key, group]) => group !== false).map(([key, group]) => {
      group = group;
      const {
        test,
        name: name3,
        chunks: chunks2,
        minSize: minSize2,
        maxSize: maxSize2,
        maxAsyncSize: maxAsyncSize2,
        maxInitialSize: maxInitialSize2,
        ...passThrough2
      } = group;
      const rawGroup = {
        key,
        test: getTest(test),
        name: getName(name3),
        chunks: getChunks(chunks2),
        minSize: JsSplitChunkSizes.__to_binding(minSize2),
        maxSize: JsSplitChunkSizes.__to_binding(maxSize2),
        maxAsyncSize: JsSplitChunkSizes.__to_binding(maxAsyncSize2),
        maxInitialSize: JsSplitChunkSizes.__to_binding(maxInitialSize2),
        ...passThrough2
      };
      return rawGroup;
    }),
    fallbackCacheGroup: {
      chunks: getChunks(chunks),
      ...fallbackCacheGroup
    },
    minSize: JsSplitChunkSizes.__to_binding(minSize),
    maxSize: JsSplitChunkSizes.__to_binding(maxSize),
    maxAsyncSize: JsSplitChunkSizes.__to_binding(maxAsyncSize),
    maxInitialSize: JsSplitChunkSizes.__to_binding(maxInitialSize),
    ...passThrough
  };
}

// src/builtin-plugin/LightningCssMiminizerRspackPlugin.ts
var import_binding66 = require("@rspack/binding");
var LightningCssMinimizerRspackPlugin = create2(
  import_binding66.BuiltinPluginName.LightningCssMinimizerRspackPlugin,
  (options) => {
    var _a, _b, _c;
    const { include, exclude, draft, nonStandard, pseudoClasses } = (options == null ? void 0 : options.minimizerOptions) ?? {};
    const targets = ((_a = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _a.targets) ?? "fully supports es6";
    return {
      test: options == null ? void 0 : options.test,
      include: options == null ? void 0 : options.include,
      exclude: options == null ? void 0 : options.exclude,
      removeUnusedLocalIdents: (options == null ? void 0 : options.removeUnusedLocalIdents) ?? true,
      minimizerOptions: {
        errorRecovery: ((_b = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _b.errorRecovery) ?? true,
        unusedSymbols: ((_c = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _c.unusedSymbols) ?? [],
        include: include ? toFeatures(include) : void 0,
        exclude: exclude ? toFeatures(exclude) : void 0,
        targets: typeof targets === "string" ? [targets] : targets,
        draft: draft ? { customMedia: draft.customMedia ?? false } : void 0,
        nonStandard: nonStandard ? {
          deepSelectorCombinator: nonStandard.deepSelectorCombinator ?? false
        } : void 0,
        pseudoClasses
      }
    };
  }
);

// src/builtin-plugin/SwcJsMinimizerPlugin.ts
var import_binding67 = require("@rspack/binding");
function isObject2(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function");
}
function getRawExtractCommentsOptions(extractComments) {
  const conditionStr = (condition) => {
    if (typeof condition === "undefined" || condition === true) {
      return "@preserve|@lic|@cc_on|^\\**!";
    }
    if (condition === false) {
      throw Error("unreachable");
    }
    return condition.source;
  };
  if (typeof extractComments === "boolean") {
    if (!extractComments) {
      return void 0;
    }
    const res = {
      condition: conditionStr(extractComments)
    };
    return res;
  }
  if (extractComments instanceof RegExp) {
    const res = {
      condition: extractComments.source
    };
    return res;
  }
  if (isObject2(extractComments)) {
    if (extractComments.condition === false) {
      return void 0;
    }
    const res = {
      condition: conditionStr(extractComments.condition),
      banner: extractComments.banner
    };
    return res;
  }
  return void 0;
}
var SwcJsMinimizerRspackPlugin = create2(
  import_binding67.BuiltinPluginName.SwcJsMinimizerRspackPlugin,
  (options) => {
    var _a, _b, _c, _d, _e;
    let compress = ((_a = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _a.compress) ?? true;
    const mangle = ((_b = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _b.mangle) ?? true;
    const format3 = {
      comments: false,
      // terser and swc use different default value: 'some'
      ...(_c = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _c.format
    };
    if (compress && typeof compress === "object") {
      compress = {
        passes: 1,
        // terser and swc use different default value: 0
        ...compress
      };
    } else if (compress) {
      compress = {
        passes: 1
      };
    }
    return {
      test: options == null ? void 0 : options.test,
      include: options == null ? void 0 : options.include,
      exclude: options == null ? void 0 : options.exclude,
      extractComments: getRawExtractCommentsOptions(options == null ? void 0 : options.extractComments),
      minimizerOptions: {
        compress,
        mangle,
        format: format3,
        minify: (_d = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _d.minify,
        module: (_e = options == null ? void 0 : options.minimizerOptions) == null ? void 0 : _e.module
      }
    };
  },
  "compilation"
);

// src/builtin-plugin/WarnCaseSensitiveModulesPlugin.ts
var import_binding68 = require("@rspack/binding");
var WarnCaseSensitiveModulesPlugin = create2(
  import_binding68.BuiltinPluginName.WarnCaseSensitiveModulesPlugin,
  () => {
  },
  "compilation"
);

// src/builtin-plugin/WebWorkerTemplatePlugin.ts
var import_binding69 = require("@rspack/binding");
var WebWorkerTemplatePlugin = create2(
  import_binding69.BuiltinPluginName.WebWorkerTemplatePlugin,
  () => void 0
);

// src/builtin-plugin/WorkerPlugin.ts
var import_binding70 = require("@rspack/binding");
var WorkerPlugin = class extends RspackBuiltinPlugin {
  constructor(chunkLoading2, wasmLoading2, module2, workerPublicPath2) {
    super();
    this.chunkLoading = chunkLoading2;
    this.wasmLoading = wasmLoading2;
    this.module = module2;
    this.workerPublicPath = workerPublicPath2;
    this.name = import_binding70.BuiltinPluginName.WorkerPlugin;
  }
  raw(compiler) {
    if (this.chunkLoading) {
      new EnableChunkLoadingPlugin(this.chunkLoading).apply(compiler);
    }
    if (this.wasmLoading) {
      new EnableWasmLoadingPlugin(this.wasmLoading).apply(compiler);
    }
    return createBuiltinPlugin(this.name, void 0);
  }
};

// src/builtin-plugin/FetchCompileAsyncWasmPlugin.ts
var import_binding71 = require("@rspack/binding");
var FetchCompileAsyncWasmPlugin = create2(
  import_binding71.BuiltinPluginName.FetchCompileAsyncWasmPlugin,
  () => {
  },
  "thisCompilation"
);

// src/builtin-plugin/NoEmitOnErrorsPlugin.ts
var import_binding72 = require("@rspack/binding");
var NoEmitOnErrorsPlugin = create2(
  import_binding72.BuiltinPluginName.NoEmitOnErrorsPlugin,
  () => void 0
);

// src/builtin-plugin/ContextReplacementPlugin.ts
var import_binding73 = require("@rspack/binding");
var ContextReplacementPlugin = create2(
  import_binding73.BuiltinPluginName.ContextReplacementPlugin,
  (resourceRegExp, newContentResource, newContentRecursive, newContentRegExp) => {
    const rawOptions = {
      resourceRegExp
    };
    if (typeof newContentResource === "function") {
    } else if (typeof newContentResource === "string" && typeof newContentRecursive === "object") {
      rawOptions.newContentResource = newContentResource;
      rawOptions.newContentCreateContextMap = newContentRecursive;
    } else if (typeof newContentResource === "string" && typeof newContentRecursive === "function") {
      rawOptions.newContentResource = newContentResource;
    } else {
      if (typeof newContentResource !== "string") {
        newContentRegExp = newContentRecursive;
        newContentRecursive = newContentResource;
        newContentResource = void 0;
      }
      if (typeof newContentRecursive !== "boolean") {
        newContentRegExp = newContentRecursive;
        newContentRecursive = void 0;
      }
      rawOptions.newContentResource = newContentResource;
      rawOptions.newContentRecursive = newContentRecursive;
      rawOptions.newContentRegExp = newContentRegExp;
    }
    return rawOptions;
  }
);

// src/ContextModuleFactory.ts
var liteTapable5 = __toESM(require("@rspack/lite-tapable"));
var ContextModuleFactory = class {
  constructor() {
    this.hooks = {
      beforeResolve: new liteTapable5.AsyncSeriesWaterfallHook(["resolveData"]),
      afterResolve: new liteTapable5.AsyncSeriesWaterfallHook(["resolveData"])
    };
  }
};

// src/FileSystem.ts
var import_node_util4 = __toESM(require("util"));

// src/util/fs.ts
var import_node_assert6 = __toESM(require("assert"));
var import_node_path9 = __toESM(require("path"));
function rmrf(fs5, p, callback) {
  fs5.stat(p, (err, stats) => {
    if (err) {
      if (err.code === "ENOENT") {
        return callback();
      }
      return callback(err);
    }
    if (stats.isDirectory()) {
      fs5.readdir(p, (err2, files) => {
        if (err2) {
          return callback(err2);
        }
        let count = files.length;
        if (count === 0) {
          fs5.rmdir(p, callback);
        } else {
          for (const file of files) {
            (0, import_node_assert6.default)(typeof file === "string");
            const fullPath = join2(fs5, p, file);
            rmrf(fs5, fullPath, (err3) => {
              if (err3) {
                return callback(err3);
              }
              count--;
              if (count === 0) {
                fs5.rmdir(p, callback);
              }
            });
          }
        }
      });
    } else {
      fs5.unlink(p, callback);
    }
  });
}
var join2 = (fs5, rootPath, filename2) => {
  if (fs5 == null ? void 0 : fs5.join) {
    return fs5.join(rootPath, filename2);
  }
  if (import_node_path9.default.posix.isAbsolute(rootPath)) {
    return import_node_path9.default.posix.join(rootPath, filename2);
  }
  if (import_node_path9.default.win32.isAbsolute(rootPath)) {
    return import_node_path9.default.win32.join(rootPath, filename2);
  }
  throw new Error(
    `${rootPath} is neither a posix nor a windows path, and there is no 'join' method defined in the file system`
  );
};
var dirname2 = (fs5, absPath) => {
  if (fs5 == null ? void 0 : fs5.dirname) {
    return fs5.dirname(absPath);
  }
  if (import_node_path9.default.posix.isAbsolute(absPath)) {
    return import_node_path9.default.posix.dirname(absPath);
  }
  if (import_node_path9.default.win32.isAbsolute(absPath)) {
    return import_node_path9.default.win32.dirname(absPath);
  }
  throw new Error(
    `${absPath} is neither a posix nor a windows path, and there is no 'dirname' method defined in the file system`
  );
};
var mkdirp = (fs5, p, callback) => {
  fs5.mkdir(p, (err) => {
    if (err) {
      if (err.code === "ENOENT") {
        const dir = dirname2(fs5, p);
        if (dir === p) {
          callback(err);
          return;
        }
        mkdirp(fs5, dir, (err2) => {
          if (err2) {
            callback(err2);
            return;
          }
          fs5.mkdir(p, (err3) => {
            if (err3) {
              if (err3.code === "EEXIST") {
                callback();
                return;
              }
              callback(err3);
              return;
            }
            callback();
          });
        });
        return;
      }
      if (err.code === "EEXIST") {
        callback();
        return;
      }
      callback(err);
      return;
    }
    callback();
  });
};

// src/FileSystem.ts
var NOOP_FILESYSTEM = {
  writeFile() {
  },
  removeFile() {
  },
  mkdir() {
  },
  mkdirp() {
  },
  removeDirAll() {
  }
};
var ThreadsafeWritableNodeFS = class {
  constructor(fs5) {
    if (!fs5) {
      Object.assign(this, NOOP_FILESYSTEM);
      return;
    }
    this.writeFile = memoizeFn(() => import_node_util4.default.promisify(fs5.writeFile.bind(fs5)));
    this.removeFile = memoizeFn(() => import_node_util4.default.promisify(fs5.unlink.bind(fs5)));
    this.mkdir = memoizeFn(() => import_node_util4.default.promisify(fs5.mkdir.bind(fs5)));
    this.mkdirp = memoizeFn(() => import_node_util4.default.promisify(mkdirp.bind(null, fs5)));
    this.removeDirAll = memoizeFn(() => import_node_util4.default.promisify(rmrf.bind(null, fs5)));
  }
  static __to_binding(fs5) {
    return new this(fs5);
  }
};

// src/NormalModuleFactory.ts
var liteTapable6 = __toESM(require("@rspack/lite-tapable"));
var NormalModuleFactory = class {
  constructor() {
    this.hooks = {
      resolveForScheme: new liteTapable6.HookMap(
        () => new liteTapable6.AsyncSeriesBailHook(["resourceData"])
      ),
      beforeResolve: new liteTapable6.AsyncSeriesBailHook(["resolveData"]),
      factorize: new liteTapable6.AsyncSeriesBailHook(["resolveData"]),
      resolve: new liteTapable6.AsyncSeriesBailHook(["resolveData"]),
      afterResolve: new liteTapable6.AsyncSeriesBailHook(["resolveData"]),
      createModule: new liteTapable6.AsyncSeriesBailHook([
        "createData",
        "resolveData"
      ])
    };
  }
};

// src/ResolverFactory.ts
var binding = __toESM(require("@rspack/binding"));

// src/Resolver.ts
function isString(value) {
  return typeof value === "string";
}
var Resolver = class _Resolver {
  constructor(binding3) {
    this.binding = binding3;
  }
  resolveSync(context2, path10, request) {
    return this.binding.resolveSync(path10, request);
  }
  resolve(context2, path10, request, resolveContext, callback) {
    try {
      const res = this.binding.resolveSync(path10, request);
      callback(null, res);
    } catch (err) {
      callback(err);
    }
  }
  withOptions({
    dependencyCategory,
    resolveToContext,
    ...resolve2
  }) {
    const rawResolve = getRawResolve(resolve2);
    if (Array.isArray(rawResolve.restrictions)) {
      rawResolve.restrictions = rawResolve.restrictions.filter(isString);
    }
    const binding3 = this.binding.withOptions({
      dependencyCategory,
      resolveToContext,
      ...rawResolve
    });
    return new _Resolver(binding3);
  }
};

// src/ResolverFactory.ts
var ResolverFactory = class {
  #binding;
  static __to_binding(resolver_factory) {
    return resolver_factory.#binding;
  }
  constructor() {
    this.#binding = new binding.JsResolverFactory();
  }
  get(type, resolveOptions2) {
    const { dependencyCategory, resolveToContext, ...resolve2 } = resolveOptions2 || {};
    const binding3 = this.#binding.get(type, {
      ...getRawResolve(resolve2),
      dependencyCategory,
      resolveToContext
    });
    return new Resolver(binding3);
  }
};

// src/RuleSetCompiler.ts
var RuleSetCompiler = class {
  constructor() {
    this.references = /* @__PURE__ */ new Map();
    this.builtinReferences = /* @__PURE__ */ new Map();
  }
};

// src/Watching.ts
var import_node_assert7 = __toESM(require("assert"));
var Watching = class {
  #invalidReported;
  #closeCallbacks;
  #initial;
  #closed;
  #collectedChangedFiles;
  #collectedRemovedFiles;
  constructor(compiler, watchOptions2, handler) {
    this.callbacks = [];
    this.invalid = false;
    this.#invalidReported = true;
    this.blocked = false;
    this.isBlocked = () => false;
    this.onChange = () => {
    };
    this.onInvalid = () => {
    };
    this.compiler = compiler;
    this.running = false;
    this.#initial = true;
    this.#closed = false;
    this.watchOptions = watchOptions2;
    this.handler = handler;
    this.suspended = false;
    if (typeof this.watchOptions.aggregateTimeout !== "number") {
      this.watchOptions.aggregateTimeout = 5;
    }
    process.nextTick(() => {
      if (this.#initial) this.#invalidate();
    });
  }
  watch(files, dirs, missing) {
    this.pausedWatcher = void 0;
    this.watcher = this.compiler.watchFileSystem.watch(
      files,
      dirs,
      missing,
      this.lastWatcherStartTime,
      this.watchOptions,
      (err, fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) => {
        if (err) {
          this.compiler.fileTimestamps = void 0;
          this.compiler.contextTimestamps = void 0;
          this.compiler.modifiedFiles = void 0;
          this.compiler.removedFiles = void 0;
          return this.handler(err);
        }
        this.#invalidate(
          fileTimeInfoEntries,
          contextTimeInfoEntries,
          changedFiles,
          removedFiles
        );
        this.onChange();
      },
      (fileName, changeTime) => {
        if (!this.#invalidReported) {
          this.#invalidReported = true;
          this.compiler.hooks.invalid.call(fileName, changeTime);
        }
        this.onInvalid();
      }
    );
  }
  close(callback) {
    if (this.#closeCallbacks) {
      if (callback) {
        this.#closeCallbacks.push(callback);
      }
      return;
    }
    const finalCallback = (err) => {
      this.running = false;
      this.compiler.running = false;
      this.compiler.watching = void 0;
      this.compiler.watchMode = false;
      this.compiler.modifiedFiles = void 0;
      this.compiler.removedFiles = void 0;
      this.compiler.fileTimestamps = void 0;
      this.compiler.contextTimestamps = void 0;
      const shutdown = (err2) => {
        this.compiler.hooks.watchClose.call();
        const closeCallbacks = this.#closeCallbacks;
        this.#closeCallbacks = void 0;
        for (const cb of closeCallbacks) cb(err2);
      };
      shutdown(err);
    };
    this.#closed = true;
    if (this.watcher) {
      this.watcher.close();
      this.watcher = void 0;
    }
    if (this.pausedWatcher) {
      this.pausedWatcher.close();
      this.pausedWatcher = void 0;
    }
    this.compiler.watching = void 0;
    this.compiler.watchMode = false;
    this.#closeCallbacks = [];
    if (callback) {
      this.#closeCallbacks.push(callback);
    }
    if (this.running) {
      this.invalid = true;
      this._done = finalCallback;
    } else {
      finalCallback(null);
    }
  }
  invalidate(callback) {
    if (callback) {
      this.callbacks.push(callback);
    }
    if (!this.#invalidReported) {
      this.#invalidReported = true;
      this.compiler.hooks.invalid.call(null, Date.now());
    }
    this.onChange();
    this.#invalidate();
  }
  lazyCompilationInvalidate(files) {
    this.#invalidate(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), files, /* @__PURE__ */ new Set());
  }
  #invalidate(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) {
    this.#mergeWithCollected(changedFiles, removedFiles);
    if (this.suspended || this.isBlocked() && (this.blocked = true)) {
      return;
    }
    if (this.running) {
      this.invalid = true;
      return;
    }
    this.#go(
      fileTimeInfoEntries,
      contextTimeInfoEntries,
      changedFiles,
      removedFiles
    );
  }
  #go(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) {
    if (this.startTime === void 0) this.startTime = Date.now();
    this.running = true;
    if (this.watcher) {
      this.pausedWatcher = this.watcher;
      this.lastWatcherStartTime = Date.now();
      this.watcher.pause();
      this.watcher = void 0;
    } else if (!this.lastWatcherStartTime) {
      this.lastWatcherStartTime = Date.now();
    }
    if (fileTimeInfoEntries && contextTimeInfoEntries && changedFiles && removedFiles) {
      this.#mergeWithCollected(changedFiles, removedFiles);
      this.compiler.fileTimestamps = fileTimeInfoEntries;
      this.compiler.contextTimestamps = contextTimeInfoEntries;
    } else if (this.pausedWatcher) {
      const { changes, removals, fileTimeInfoEntries: fileTimeInfoEntries2, contextTimeInfoEntries: contextTimeInfoEntries2 } = this.pausedWatcher.getInfo();
      this.#mergeWithCollected(changes, removals);
      this.compiler.fileTimestamps = fileTimeInfoEntries2;
      this.compiler.contextTimestamps = contextTimeInfoEntries2;
    }
    const modifiedFiles = this.compiler.modifiedFiles = this.#collectedChangedFiles;
    const deleteFiles = this.compiler.removedFiles = this.#collectedRemovedFiles;
    this.#collectedChangedFiles = void 0;
    this.#collectedRemovedFiles = void 0;
    this.invalid = false;
    this.#invalidReported = false;
    this.compiler.hooks.watchRun.callAsync(this.compiler, (err) => {
      if (err) return this._done(err, null);
      const canRebuild = !this.#initial && ((modifiedFiles == null ? void 0 : modifiedFiles.size) || (deleteFiles == null ? void 0 : deleteFiles.size));
      const onCompile = (err2) => {
        if (err2) return this._done(err2, null);
        this._done(null, this.compiler._lastCompilation);
      };
      this.compiler.compile(onCompile);
      if (!canRebuild) {
        this.#initial = false;
      }
    });
  }
  _done(error, compilation) {
    this.running = false;
    let stats = void 0;
    const handleError = (err, cbs2) => {
      this.compiler.hooks.failed.call(err);
      this.handler(err, stats);
      const callbacksToExecute = cbs2 || this.callbacks.splice(0);
      for (const cb of callbacksToExecute) {
        cb(err);
      }
    };
    const cbs = this.callbacks;
    this.callbacks = [];
    const startTime = this.startTime;
    this.startTime = void 0;
    if (error) {
      return handleError(error);
    }
    (0, import_node_assert7.default)(compilation);
    compilation.startTime = startTime;
    compilation.endTime = Date.now();
    stats = new Stats(compilation);
    this.compiler.hooks.done.callAsync(stats, (err) => {
      if (err) return handleError(err, cbs);
      this.handler(null, stats);
      process.nextTick(() => {
        if (!this.#closed) {
          this.watch(
            compilation.fileDependencies,
            compilation.contextDependencies,
            compilation.missingDependencies
          );
        }
      });
      for (const cb of cbs) cb(null);
      this.compiler.hooks.afterDone.call(stats);
    });
  }
  #mergeWithCollected(changedFiles, removedFiles) {
    if (!changedFiles) return;
    if (!removedFiles) return;
    if (!this.#collectedChangedFiles || !this.#collectedRemovedFiles) {
      this.#collectedChangedFiles = new Set(changedFiles);
      this.#collectedRemovedFiles = new Set(removedFiles);
    } else {
      for (const file of changedFiles) {
        this.#collectedChangedFiles.add(file);
        this.#collectedRemovedFiles.delete(file);
      }
      for (const file of removedFiles) {
        this.#collectedChangedFiles.delete(file);
        this.#collectedRemovedFiles.add(file);
      }
    }
  }
  suspend() {
    this.suspended = true;
  }
  resume() {
    if (this.suspended) {
      this.suspended = false;
      this.#invalidate();
    }
  }
};

// src/util/bindingVersionCheck.ts
var import_node_fs3 = require("fs");
var import_node_path10 = __toESM(require("path"));
var NodePlatformArchToAbi = {
  android: {
    arm64: "",
    arm: "eabi"
  },
  win32: {
    x64: "msvc",
    ia32: "msvc",
    arm64: "msvc"
  },
  darwin: {
    x64: "",
    arm64: ""
  },
  freebsd: {
    x64: ""
  },
  linux: {
    x64: {
      musl: "musl",
      gnu: "gnu"
    },
    arm64: {
      musl: "musl",
      gnu: "gnu"
    },
    arm: "gnueabihf"
  }
};
function isMusl() {
  if (!process.report || typeof process.report.getReport !== "function") {
    try {
      const lddPath = require("child_process").execSync("which ldd").toString().trim();
      return (0, import_node_fs3.readFileSync)(lddPath, "utf8").includes("musl");
    } catch (e) {
      return true;
    }
  } else {
    const { glibcVersionRuntime } = process.report.getReport().header;
    return !glibcVersionRuntime;
  }
}
var BINDING_VERSION = require("@rspack/binding/package.json").version;
var CORE_VERSION = require_package().version;
var getAddonPlatformArchAbi = () => {
  const { platform, arch } = process;
  let binding3 = "";
  binding3 += platform;
  const abi = NodePlatformArchToAbi[platform][arch];
  if (abi === void 0) return new Error(`unsupported cpu arch: ${arch}`);
  binding3 += `-${arch}`;
  if (typeof abi === "string") {
    binding3 += abi.length ? `-${abi}` : "";
  } else if (typeof abi === "object") {
    binding3 += `-${abi[isMusl() ? "musl" : "gnu"]}`;
  } else {
    return new Error(`unsupported abi: ${abi}`);
  }
  return binding3;
};
var result;
var checkVersion = () => {
  if (result !== void 0) {
    return result;
  }
  const platformArchAbi = getAddonPlatformArchAbi();
  if (platformArchAbi instanceof Error) {
    return result = platformArchAbi;
  }
  let ADDON_VERSION;
  try {
    const BINDING_PKG_DIR = import_node_path10.default.dirname(
      require.resolve("@rspack/binding/package.json")
    );
    const isLocal = (0, import_node_fs3.readdirSync)(BINDING_PKG_DIR).some(
      (item) => item === `rspack.${platformArchAbi}.node`
    );
    if (isLocal) {
      ADDON_VERSION = BINDING_VERSION;
    } else {
      ADDON_VERSION = require(require.resolve(`@rspack/binding-${platformArchAbi}/package.json`, {
        paths: [BINDING_PKG_DIR]
      })).version;
    }
  } catch (error) {
    if (error instanceof Error) {
      return result = new Error(
        `${error.toString()}. Maybe you forget to install the correct addon package ${`@rspack/binding-${platformArchAbi}`} or forget to build binding locally?`
      );
    }
    return result = new Error(error);
  }
  const isMatch = [CORE_VERSION, BINDING_VERSION, ADDON_VERSION].every(
    (v, _, arr) => v === arr[0]
  );
  if (!isMatch) {
    return result = new Error(
      `Unmatched version @rspack/core@${CORE_VERSION}, @rspack/binding@${BINDING_VERSION}, @rspack/binding-${platformArchAbi}@${ADDON_VERSION}`
    );
  }
  return result = null;
};

// src/Compiler.ts
var Compiler = class _Compiler {
  #instance;
  #initial;
  #compilation;
  #compilationParams;
  #builtinPlugins;
  #moduleExecutionResultsMap;
  #nonSkippableRegisters;
  #registers;
  #ruleSet;
  constructor(context2, options) {
    this.#initial = true;
    this.#builtinPlugins = [];
    this.#nonSkippableRegisters = [];
    this.#moduleExecutionResultsMap = /* @__PURE__ */ new Map();
    this.#ruleSet = new RuleSetCompiler();
    this.hooks = {
      initialize: new liteTapable7.SyncHook([]),
      shouldEmit: new liteTapable7.SyncBailHook(["compilation"]),
      done: new liteTapable7.AsyncSeriesHook(["stats"]),
      afterDone: new liteTapable7.SyncHook(["stats"]),
      beforeRun: new liteTapable7.AsyncSeriesHook(["compiler"]),
      run: new liteTapable7.AsyncSeriesHook(["compiler"]),
      emit: new liteTapable7.AsyncSeriesHook(["compilation"]),
      assetEmitted: new liteTapable7.AsyncSeriesHook(["file", "info"]),
      afterEmit: new liteTapable7.AsyncSeriesHook(["compilation"]),
      thisCompilation: new liteTapable7.SyncHook(["compilation", "params"]),
      compilation: new liteTapable7.SyncHook([
        "compilation",
        "params"
      ]),
      invalid: new liteTapable7.SyncHook(["filename", "changeTime"]),
      compile: new liteTapable7.SyncHook(["params"]),
      infrastructureLog: new liteTapable7.SyncBailHook([
        "origin",
        "type",
        "args"
      ]),
      failed: new liteTapable7.SyncHook(["error"]),
      shutdown: new liteTapable7.AsyncSeriesHook([]),
      normalModuleFactory: new liteTapable7.SyncHook([
        "normalModuleFactory"
      ]),
      contextModuleFactory: new liteTapable7.SyncHook([
        "contextModuleFactory"
      ]),
      watchRun: new liteTapable7.AsyncSeriesHook(["compiler"]),
      watchClose: new liteTapable7.SyncHook([]),
      environment: new liteTapable7.SyncHook([]),
      afterEnvironment: new liteTapable7.SyncHook([]),
      afterPlugins: new liteTapable7.SyncHook(["compiler"]),
      afterResolvers: new liteTapable7.SyncHook(["compiler"]),
      make: new liteTapable7.AsyncParallelHook(["compilation"]),
      beforeCompile: new liteTapable7.AsyncSeriesHook(["params"]),
      afterCompile: new liteTapable7.AsyncSeriesHook(["compilation"]),
      finishMake: new liteTapable7.AsyncSeriesHook(["compilation"]),
      entryOption: new liteTapable7.SyncBailHook(["context", "entry"])
    };
    this.webpack = rspack;
    this.rspack = rspack;
    this.root = this;
    this.outputPath = "";
    this.inputFileSystem = null;
    this.intermediateFileSystem = null;
    this.outputFileSystem = null;
    this.watchFileSystem = null;
    this.records = {};
    this.options = options;
    this.resolverFactory = new ResolverFactory();
    this.context = context2;
    this.cache = new Cache_default();
    this.compilerPath = "";
    this.running = false;
    this.idle = false;
    this.watchMode = false;
    new JsLoaderRspackPlugin(this).apply(this);
    new ExecuteModulePlugin().apply(this);
  }
  get recordsInputPath() {
    return unsupported("Compiler.recordsInputPath");
  }
  get recordsOutputPath() {
    return unsupported("Compiler.recordsOutputPath");
  }
  get managedPaths() {
    return unsupported("Compiler.managedPaths");
  }
  get immutablePaths() {
    return unsupported("Compiler.immutablePaths");
  }
  get _lastCompilation() {
    return this.#compilation;
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   * @internal
   */
  get __internal__builtinPlugins() {
    return this.#builtinPlugins;
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   * @internal
   */
  get __internal__ruleSet() {
    return this.#ruleSet;
  }
  /**
   * @param name - cache name
   * @returns the cache facade instance
   */
  getCache(name2) {
    return new CacheFacade_default(
      this.cache,
      `${this.compilerPath}${name2}`,
      this.options.output.hashFunction
    );
  }
  /**
   * @param name - name of the logger, or function called once to get the logger name
   * @returns a logger with that name
   */
  getInfrastructureLogger(name2) {
    if (!name2) {
      throw new TypeError(
        "Compiler.getInfrastructureLogger(name) called without a name"
      );
    }
    let normalizedName = name2;
    return new Logger(
      (type, args) => {
        if (typeof normalizedName === "function") {
          normalizedName = normalizedName();
          if (!normalizedName) {
            throw new TypeError(
              "Compiler.getInfrastructureLogger(name) called with a function not returning a name"
            );
          }
        } else {
          if (this.hooks.infrastructureLog.call(normalizedName, type, args) === void 0) {
            if (this.infrastructureLogger !== void 0) {
              this.infrastructureLogger(normalizedName, type, args);
            }
          }
        }
      },
      (childName) => {
        let normalizedChildName = childName;
        if (typeof normalizedName === "function") {
          if (typeof normalizedChildName === "function") {
            return this.getInfrastructureLogger(() => {
              if (typeof normalizedName === "function") {
                normalizedName = normalizedName();
                if (!normalizedName) {
                  throw new TypeError(
                    "Compiler.getInfrastructureLogger(name) called with a function not returning a name"
                  );
                }
              }
              if (typeof normalizedChildName === "function") {
                normalizedChildName = normalizedChildName();
                if (!normalizedChildName) {
                  throw new TypeError(
                    "Logger.getChildLogger(name) called with a function not returning a name"
                  );
                }
              }
              return `${normalizedName}/${normalizedChildName}`;
            });
          }
          return this.getInfrastructureLogger(() => {
            if (typeof normalizedName === "function") {
              normalizedName = normalizedName();
              if (!normalizedName) {
                throw new TypeError(
                  "Compiler.getInfrastructureLogger(name) called with a function not returning a name"
                );
              }
            }
            return `${normalizedName}/${normalizedChildName}`;
          });
        }
        if (typeof normalizedChildName === "function") {
          return this.getInfrastructureLogger(() => {
            if (typeof normalizedChildName === "function") {
              normalizedChildName = normalizedChildName();
              if (!normalizedChildName) {
                throw new TypeError(
                  "Logger.getChildLogger(name) called with a function not returning a name"
                );
              }
            }
            return `${normalizedName}/${normalizedChildName}`;
          });
        }
        return this.getInfrastructureLogger(
          `${normalizedName}/${normalizedChildName}`
        );
      }
    );
  }
  /**
   * @param watchOptions - the watcher's options
   * @param handler - signals when the call finishes
   * @returns a compiler watcher
   */
  watch(watchOptions2, handler) {
    if (this.running) {
      return handler(new ConcurrentCompilationError());
    }
    this.running = true;
    this.watchMode = true;
    this.watching = new Watching(this, watchOptions2, handler);
    return this.watching;
  }
  /**
   * @param callback - signals when the call finishes
   */
  run(callback) {
    if (this.running) {
      return callback(new ConcurrentCompilationError());
    }
    const startTime = Date.now();
    this.running = true;
    const doRun = () => {
      const finalCallback = (err, stats) => {
        this.idle = true;
        this.cache.beginIdle();
        this.idle = true;
        this.running = false;
        if (err) {
          this.hooks.failed.call(err);
        }
        if (callback) {
          callback(err, stats);
        }
        this.hooks.afterDone.call(stats);
      };
      this.hooks.beforeRun.callAsync(this, (err) => {
        if (err) {
          return finalCallback(err);
        }
        this.hooks.run.callAsync(this, (err2) => {
          if (err2) {
            return finalCallback(err2);
          }
          this.compile((err3) => {
            if (err3) {
              return finalCallback(err3);
            }
            this.#compilation.startTime = startTime;
            this.#compilation.endTime = Date.now();
            const stats = new Stats(this.#compilation);
            this.hooks.done.callAsync(stats, (err4) => {
              if (err4) {
                return finalCallback(err4);
              }
              return finalCallback(null, stats);
            });
          });
        });
      });
    };
    if (this.idle) {
      this.cache.endIdle((err) => {
        if (err) return callback(err);
        this.idle = false;
        doRun();
      });
    } else {
      doRun();
    }
  }
  runAsChild(callback) {
    const finalCallback = (err, entries, compilation) => {
      try {
        callback(err, entries, compilation);
      } catch (e) {
        const err2 = new Error(`compiler.runAsChild callback error: ${e}`);
        this.parentCompilation.errors.push(err2);
        console.log(e);
      }
    };
    this.compile((err, compilation) => {
      if (err) {
        return finalCallback(err);
      }
      assertNotNill(compilation);
      this.parentCompilation.children.push(compilation);
      for (const { name: name2, source, info } of compilation.getAssets()) {
        if (source) {
          this.parentCompilation.emitAsset(name2, source, info);
        }
      }
      const entries = [];
      for (const ep of compilation.entrypoints.values()) {
        entries.push(...ep.chunks);
      }
      return finalCallback(null, entries, compilation);
    });
  }
  purgeInputFileSystem() {
    var _a, _b;
    (_b = (_a = this.inputFileSystem) == null ? void 0 : _a.purge) == null ? void 0 : _b.call(_a);
  }
  /**
   * @param compilation - the compilation
   * @param compilerName - the compiler's name
   * @param compilerIndex - the compiler's index
   * @param outputOptions - the output options
   * @param plugins - the plugins to apply
   * @returns a child compiler
   */
  createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins2) {
    const options = {
      ...this.options,
      output: {
        ...this.options.output,
        ...outputOptions
      }
    };
    applyRspackOptionsDefaults(options);
    const childCompiler = new _Compiler(this.context, options);
    childCompiler.name = compilerName;
    childCompiler.outputPath = this.outputPath;
    childCompiler.inputFileSystem = this.inputFileSystem;
    childCompiler.outputFileSystem = null;
    childCompiler.modifiedFiles = this.modifiedFiles;
    childCompiler.removedFiles = this.removedFiles;
    childCompiler.fileTimestamps = this.fileTimestamps;
    childCompiler.contextTimestamps = this.contextTimestamps;
    childCompiler.fsStartTime = this.fsStartTime;
    childCompiler.cache = this.cache;
    childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;
    const relativeCompilerName = makePathsRelative(
      this.context,
      compilerName,
      this.root
    );
    if (!this.records[relativeCompilerName]) {
      this.records[relativeCompilerName] = [];
    }
    if (this.records[relativeCompilerName][compilerIndex]) {
      childCompiler.records = this.records[relativeCompilerName][compilerIndex];
    } else {
      this.records[relativeCompilerName].push(childCompiler.records = {});
    }
    childCompiler.parentCompilation = compilation;
    childCompiler.root = this.root;
    if (Array.isArray(plugins2)) {
      for (const plugin2 of plugins2) {
        if (plugin2) {
          plugin2.apply(childCompiler);
        }
      }
    }
    childCompiler.#builtinPlugins = [
      ...childCompiler.#builtinPlugins,
      ...this.#builtinPlugins.filter(
        (plugin2) => plugin2.canInherentFromParent === true
      )
    ];
    for (const hookName in this.hooks) {
      const name2 = hookName;
      if (canInherentFromParent(name2)) {
        if (childCompiler.hooks[name2]) {
          childCompiler.hooks[name2].taps = this.hooks[name2].taps.slice();
        }
      }
    }
    compilation.hooks.childCompiler.call(
      childCompiler,
      compilerName,
      compilerIndex
    );
    return childCompiler;
  }
  isChild() {
    const isRoot = this.root === this;
    return !isRoot;
  }
  compile(callback) {
    const startTime = Date.now();
    const params = this.#newCompilationParams();
    this.hooks.beforeCompile.callAsync(params, (err) => {
      if (err) {
        return callback(err);
      }
      this.hooks.compile.call(params);
      this.#resetThisCompilation();
      this.#build((err2) => {
        if (err2) {
          return callback(err2);
        }
        this.#compilation.startTime = startTime;
        this.#compilation.endTime = Date.now();
        this.hooks.afterCompile.callAsync(this.#compilation, (err3) => {
          if (err3) {
            return callback(err3);
          }
          return callback(null, this.#compilation);
        });
      });
    });
  }
  close(callback) {
    if (this.watching) {
      this.watching.close(() => {
        this.close(callback);
      });
      return;
    }
    this.hooks.shutdown.callAsync((err) => {
      if (err) return callback(err);
      this.cache.shutdown(callback);
    });
  }
  #build(callback) {
    this.#getInstance((error, instance) => {
      if (error) {
        return callback == null ? void 0 : callback(error);
      }
      if (!this.#initial) {
        instance.rebuild(
          Array.from(this.modifiedFiles || []),
          Array.from(this.removedFiles || []),
          (error2) => {
            if (error2) {
              return callback == null ? void 0 : callback(error2);
            }
            callback == null ? void 0 : callback(null);
          }
        );
        return;
      }
      this.#initial = false;
      instance.build((error2) => {
        if (error2) {
          return callback == null ? void 0 : callback(error2);
        }
        callback == null ? void 0 : callback(null);
      });
    });
  }
  /**
   * Note: This is not a webpack public API, maybe removed in future.
   * @internal
   */
  __internal__rebuild(modifiedFiles, removedFiles, callback) {
    this.#getInstance((error, instance) => {
      if (error) {
        return callback == null ? void 0 : callback(error);
      }
      instance.rebuild(
        Array.from(modifiedFiles || []),
        Array.from(removedFiles || []),
        (error2) => {
          if (error2) {
            return callback == null ? void 0 : callback(error2);
          }
          callback == null ? void 0 : callback(null);
        }
      );
    });
  }
  #createCompilation(native) {
    const compilation = new Compilation(this, native);
    compilation.name = this.name;
    this.#compilation = compilation;
    return compilation;
  }
  #resetThisCompilation() {
    this.#compilation = void 0;
    this.hooks.thisCompilation.intercept({
      call: () => {
      }
    });
  }
  #newCompilationParams() {
    const normalModuleFactory = new NormalModuleFactory();
    this.hooks.normalModuleFactory.call(normalModuleFactory);
    const contextModuleFactory = new ContextModuleFactory();
    this.hooks.contextModuleFactory.call(contextModuleFactory);
    const params = {
      normalModuleFactory,
      contextModuleFactory
    };
    this.#compilationParams = params;
    return params;
  }
  /**
   * Lazy initialize instance so it could access the changed options
   */
  #getInstance(callback) {
    const error = checkVersion();
    if (error) {
      return callback(error);
    }
    if (this.#instance) {
      return callback(null, this.#instance);
    }
    const options = this.options;
    const rawOptions = getRawOptions(options, this);
    rawOptions.__references = Object.fromEntries(
      this.#ruleSet.builtinReferences.entries()
    );
    const instanceBinding = require("@rspack/binding");
    this.#registers = {
      registerCompilerThisCompilationTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerThisCompilation,
        () => this.hooks.thisCompilation,
        (queried) => (native) => {
          if (this.#compilation === void 0) {
            this.#createCompilation(native);
          }
          queried.call(this.#compilation, this.#compilationParams);
        }
      ),
      registerCompilerCompilationTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerCompilation,
        () => this.hooks.compilation,
        (queried) => () => queried.call(this.#compilation, this.#compilationParams)
      ),
      registerCompilerMakeTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerMake,
        () => this.hooks.make,
        (queried) => async () => await queried.promise(this.#compilation)
      ),
      registerCompilerFinishMakeTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerFinishMake,
        () => this.hooks.finishMake,
        (queried) => async () => await queried.promise(this.#compilation)
      ),
      registerCompilerShouldEmitTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerShouldEmit,
        () => this.hooks.shouldEmit,
        (queried) => () => queried.call(this.#compilation)
      ),
      registerCompilerEmitTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerEmit,
        () => this.hooks.emit,
        (queried) => async () => await queried.promise(this.#compilation)
      ),
      registerCompilerAfterEmitTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerAfterEmit,
        () => this.hooks.afterEmit,
        (queried) => async () => await queried.promise(this.#compilation)
      ),
      registerCompilerAssetEmittedTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilerAssetEmitted,
        () => this.hooks.assetEmitted,
        (queried) => async ({
          filename: filename2,
          targetPath,
          outputPath
        }) => {
          return queried.promise(filename2, {
            compilation: this.#compilation,
            targetPath,
            outputPath,
            get source() {
              var _a;
              return (_a = this.compilation.getAsset(filename2)) == null ? void 0 : _a.source;
            },
            get content() {
              var _a;
              return (_a = this.source) == null ? void 0 : _a.buffer();
            }
          });
        }
      ),
      registerCompilationAdditionalTreeRuntimeRequirements: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationAdditionalTreeRuntimeRequirements,
        () => this.#compilation.hooks.additionalTreeRuntimeRequirements,
        (queried) => ({
          chunk,
          runtimeRequirements
        }) => {
          const set = __from_binding_runtime_globals(runtimeRequirements);
          queried.call(
            Chunk.__from_binding(chunk, this.#compilation),
            set
          );
          return {
            runtimeRequirements: __to_binding_runtime_globals(set)
          };
        }
      ),
      registerCompilationRuntimeRequirementInTree: this.#createHookMapRegisterTaps(
        binding2.RegisterJsTapKind.CompilationRuntimeRequirementInTree,
        () => this.#compilation.hooks.runtimeRequirementInTree,
        (queried) => ({
          chunk: rawChunk,
          runtimeRequirements
        }) => {
          const set = __from_binding_runtime_globals(runtimeRequirements);
          const chunk = Chunk.__from_binding(rawChunk, this.#compilation);
          for (const r of set) {
            queried.for(r).call(chunk, set);
          }
          return {
            runtimeRequirements: __to_binding_runtime_globals(set)
          };
        }
      ),
      registerCompilationRuntimeModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationRuntimeModule,
        () => this.#compilation.hooks.runtimeModule,
        (queried) => ({ module: module2, chunk }) => {
          var _a, _b;
          const originSource = (_a = module2.source) == null ? void 0 : _a.source;
          queried.call(
            module2,
            Chunk.__from_binding(chunk, this.#compilation)
          );
          const newSource = (_b = module2.source) == null ? void 0 : _b.source;
          if (newSource && newSource !== originSource) {
            return module2;
          }
          return;
        }
      ),
      registerCompilationBuildModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationBuildModule,
        () => this.#compilation.hooks.buildModule,
        (queired) => (m) => queired.call(Module.__from_binding(m, this.#compilation))
      ),
      registerCompilationStillValidModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationStillValidModule,
        () => this.#compilation.hooks.stillValidModule,
        (queired) => (m) => queired.call(Module.__from_binding(m, this.#compilation))
      ),
      registerCompilationSucceedModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationSucceedModule,
        () => this.#compilation.hooks.succeedModule,
        (queired) => (m) => queired.call(Module.__from_binding(m, this.#compilation))
      ),
      registerCompilationExecuteModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationExecuteModule,
        () => this.#compilation.hooks.executeModule,
        (queried) => ({
          entry: entry2,
          id,
          codegenResults,
          runtimeModules
        }) => {
          const __webpack_require__ = (id2) => {
            const cached = moduleCache[id2];
            if (cached !== void 0) {
              if (cached.error) throw cached.error;
              return cached.exports;
            }
            const execOptions = {
              id: id2,
              module: {
                id: id2,
                exports: {},
                loaded: false,
                error: void 0
              },
              require: __webpack_require__
            };
            for (const handler of interceptModuleExecution) {
              handler(execOptions);
            }
            const result2 = codegenResults.map[id2]["build time"];
            const moduleObject = execOptions.module;
            if (id2) moduleCache[id2] = moduleObject;
            tryRunOrWebpackError(
              () => queried.call(
                {
                  codeGenerationResult: new CodeGenerationResult(result2),
                  moduleObject
                },
                { __webpack_require__ }
              ),
              "Compilation.hooks.executeModule"
            );
            moduleObject.loaded = true;
            return moduleObject.exports;
          };
          const moduleCache = __webpack_require__[RuntimeGlobals.moduleCache.replace(
            `${RuntimeGlobals.require}.`,
            ""
          )] = {};
          const interceptModuleExecution = __webpack_require__[RuntimeGlobals.interceptModuleExecution.replace(
            `${RuntimeGlobals.require}.`,
            ""
          )] = [];
          for (const runtimeModule of runtimeModules) {
            __webpack_require__(runtimeModule);
          }
          const executeResult = __webpack_require__(entry2);
          this.#moduleExecutionResultsMap.set(id, executeResult);
        }
      ),
      registerCompilationFinishModulesTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationFinishModules,
        () => this.#compilation.hooks.finishModules,
        (queried) => async () => await queried.promise(this.#compilation.modules)
      ),
      registerCompilationOptimizeModulesTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationOptimizeModules,
        () => this.#compilation.hooks.optimizeModules,
        (queried) => () => queried.call(this.#compilation.modules.values())
      ),
      registerCompilationAfterOptimizeModulesTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationAfterOptimizeModules,
        () => this.#compilation.hooks.afterOptimizeModules,
        (queried) => () => {
          queried.call(this.#compilation.modules.values());
        }
      ),
      registerCompilationOptimizeTreeTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationOptimizeTree,
        () => this.#compilation.hooks.optimizeTree,
        (queried) => async () => await queried.promise(
          this.#compilation.chunks,
          this.#compilation.modules
        )
      ),
      registerCompilationOptimizeChunkModulesTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationOptimizeChunkModules,
        () => this.#compilation.hooks.optimizeChunkModules,
        (queried) => async () => await queried.promise(
          this.#compilation.chunks,
          this.#compilation.modules
        )
      ),
      registerCompilationChunkHashTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationChunkHash,
        () => this.#compilation.hooks.chunkHash,
        (queried) => (chunk) => {
          if (!this.options.output.hashFunction) {
            throw new Error("'output.hashFunction' cannot be undefined");
          }
          const hash = createHash(this.options.output.hashFunction);
          queried.call(Chunk.__from_binding(chunk, this.#compilation), hash);
          const digestResult = hash.digest(this.options.output.hashDigest);
          return Buffer.from(digestResult);
        }
      ),
      registerCompilationChunkAssetTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationChunkAsset,
        () => this.#compilation.hooks.chunkAsset,
        (queried) => ({ chunk, filename: filename2 }) => queried.call(
          Chunk.__from_binding(chunk, this.#compilation),
          filename2
        )
      ),
      registerCompilationProcessAssetsTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationProcessAssets,
        () => this.#compilation.hooks.processAssets,
        (queried) => async () => await queried.promise(this.#compilation.assets)
      ),
      registerCompilationAfterProcessAssetsTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationAfterProcessAssets,
        () => this.#compilation.hooks.afterProcessAssets,
        (queried) => () => queried.call(this.#compilation.assets)
      ),
      registerCompilationSealTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationSeal,
        () => this.#compilation.hooks.seal,
        (queried) => () => queried.call()
      ),
      registerCompilationAfterSealTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.CompilationAfterSeal,
        () => this.#compilation.hooks.afterSeal,
        (queried) => async () => await queried.promise()
      ),
      registerNormalModuleFactoryBeforeResolveTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryBeforeResolve,
        () => this.#compilationParams.normalModuleFactory.hooks.beforeResolve,
        (queried) => async (resolveData) => {
          const normalizedResolveData = {
            contextInfo: {
              issuer: resolveData.issuer
            },
            request: resolveData.request,
            context: resolveData.context,
            fileDependencies: [],
            missingDependencies: [],
            contextDependencies: []
          };
          const ret = await queried.promise(normalizedResolveData);
          resolveData.request = normalizedResolveData.request;
          resolveData.context = normalizedResolveData.context;
          return [ret, resolveData];
        }
      ),
      registerNormalModuleFactoryFactorizeTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryFactorize,
        () => this.#compilationParams.normalModuleFactory.hooks.factorize,
        (queried) => async (resolveData) => {
          const normalizedResolveData = {
            contextInfo: {
              issuer: resolveData.issuer
            },
            request: resolveData.request,
            context: resolveData.context,
            fileDependencies: [],
            missingDependencies: [],
            contextDependencies: []
          };
          await queried.promise(normalizedResolveData);
          resolveData.request = normalizedResolveData.request;
          resolveData.context = normalizedResolveData.context;
          return resolveData;
        }
      ),
      registerNormalModuleFactoryResolveTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryResolve,
        () => this.#compilationParams.normalModuleFactory.hooks.resolve,
        (queried) => async (resolveData) => {
          const normalizedResolveData = {
            contextInfo: {
              issuer: resolveData.issuer
            },
            request: resolveData.request,
            context: resolveData.context,
            fileDependencies: [],
            missingDependencies: [],
            contextDependencies: []
          };
          await queried.promise(normalizedResolveData);
          resolveData.request = normalizedResolveData.request;
          resolveData.context = normalizedResolveData.context;
          return resolveData;
        }
      ),
      registerNormalModuleFactoryResolveForSchemeTaps: this.#createHookMapRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryResolveForScheme,
        () => this.#compilationParams.normalModuleFactory.hooks.resolveForScheme,
        (queried) => async (args) => {
          const ret = await queried.for(args.scheme).promise(args.resourceData);
          return [ret, args.resourceData];
        }
      ),
      registerNormalModuleFactoryAfterResolveTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryAfterResolve,
        () => this.#compilationParams.normalModuleFactory.hooks.afterResolve,
        (queried) => async (arg) => {
          const data = {
            contextInfo: {
              issuer: arg.issuer
            },
            request: arg.request,
            context: arg.context,
            fileDependencies: arg.fileDependencies,
            missingDependencies: arg.missingDependencies,
            contextDependencies: arg.contextDependencies,
            createData: arg.createData
          };
          const ret = await queried.promise(data);
          return [ret, data.createData];
        }
      ),
      registerNormalModuleFactoryCreateModuleTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.NormalModuleFactoryCreateModule,
        () => this.#compilationParams.normalModuleFactory.hooks.createModule,
        (queried) => async (args) => {
          const data = {
            ...args,
            settings: {}
          };
          await queried.promise(data, {});
        }
      ),
      registerContextModuleFactoryBeforeResolveTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.ContextModuleFactoryBeforeResolve,
        () => this.#compilationParams.contextModuleFactory.hooks.beforeResolve,
        (queried) => async (bindingData) => {
          const data = bindingData ? ContextModuleFactoryBeforeResolveData.__from_binding(
            bindingData
          ) : false;
          const result2 = await queried.promise(data);
          return result2 ? ContextModuleFactoryBeforeResolveData.__to_binding(result2) : false;
        }
      ),
      registerContextModuleFactoryAfterResolveTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.ContextModuleFactoryAfterResolve,
        () => this.#compilationParams.contextModuleFactory.hooks.afterResolve,
        (queried) => async (bindingData) => {
          const data = bindingData ? ContextModuleFactoryAfterResolveData.__from_binding(
            bindingData
          ) : false;
          const result2 = await queried.promise(data);
          return result2 ? ContextModuleFactoryAfterResolveData.__to_binding(result2) : false;
        }
      ),
      registerJavascriptModulesChunkHashTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.JavascriptModulesChunkHash,
        () => JavascriptModulesPlugin.getCompilationHooks(this.#compilation).chunkHash,
        (queried) => (chunk) => {
          if (!this.options.output.hashFunction) {
            throw new Error("'output.hashFunction' cannot be undefined");
          }
          const hash = createHash(this.options.output.hashFunction);
          queried.call(Chunk.__from_binding(chunk, this.#compilation), hash);
          const digestResult = hash.digest(this.options.output.hashDigest);
          return Buffer.from(digestResult);
        }
      ),
      registerHtmlPluginBeforeAssetTagGenerationTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginBeforeAssetTagGeneration,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).beforeAssetTagGeneration,
        (queried) => async (data) => {
          return await queried.promise({
            ...data,
            plugin: {
              options: HtmlRspackPlugin.getCompilationOptions(this.#compilation) || {}
            }
          });
        }
      ),
      registerHtmlPluginAlterAssetTagsTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginAlterAssetTags,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).alterAssetTags,
        (queried) => async (data) => {
          return await queried.promise(data);
        }
      ),
      registerHtmlPluginAlterAssetTagGroupsTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginAlterAssetTagGroups,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).alterAssetTagGroups,
        (queried) => async (data) => {
          return await queried.promise({
            ...data,
            plugin: {
              options: HtmlRspackPlugin.getCompilationOptions(this.#compilation) || {}
            }
          });
        }
      ),
      registerHtmlPluginAfterTemplateExecutionTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginAfterTemplateExecution,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).afterTemplateExecution,
        (queried) => async (data) => {
          return await queried.promise({
            ...data,
            plugin: {
              options: HtmlRspackPlugin.getCompilationOptions(this.#compilation) || {}
            }
          });
        }
      ),
      registerHtmlPluginBeforeEmitTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginBeforeEmit,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).beforeEmit,
        (queried) => async (data) => {
          return await queried.promise({
            ...data,
            plugin: {
              options: HtmlRspackPlugin.getCompilationOptions(this.#compilation) || {}
            }
          });
        }
      ),
      registerHtmlPluginAfterEmitTaps: this.#createHookRegisterTaps(
        binding2.RegisterJsTapKind.HtmlPluginAfterEmit,
        () => HtmlRspackPlugin.getCompilationHooks(this.#compilation).afterEmit,
        (queried) => async (data) => {
          return await queried.promise({
            ...data,
            plugin: {
              options: HtmlRspackPlugin.getCompilationOptions(this.#compilation) || {}
            }
          });
        }
      )
    };
    this.#instance = new instanceBinding.Rspack(
      rawOptions,
      this.#builtinPlugins,
      this.#registers,
      ThreadsafeWritableNodeFS.__to_binding(this.outputFileSystem),
      ResolverFactory.__to_binding(this.resolverFactory)
    );
    callback(null, this.#instance);
  }
  #updateNonSkippableRegisters() {
    const kinds = [];
    for (const { getHook, getHookMap, registerKind } of Object.values(
      this.#registers
    )) {
      const get = getHook ?? getHookMap;
      const hookOrMap = get();
      if (hookOrMap.isUsed()) {
        kinds.push(registerKind);
      }
    }
    if (this.#nonSkippableRegisters.join() !== kinds.join()) {
      this.#getInstance((_error, instance) => {
        instance.setNonSkippableRegisters(kinds);
        this.#nonSkippableRegisters = kinds;
      });
    }
  }
  #decorateJsTaps(jsTaps) {
    if (jsTaps.length > 0) {
      const last = jsTaps[jsTaps.length - 1];
      const old = last.function;
      last.function = (...args) => {
        const result2 = old(...args);
        if (result2 && typeof result2.then === "function") {
          return result2.then((r) => {
            this.#updateNonSkippableRegisters();
            return r;
          });
        }
        this.#updateNonSkippableRegisters();
        return result2;
      };
    }
  }
  #createHookRegisterTaps(registerKind, getHook, createTap) {
    const getTaps = (stages) => {
      const hook = getHook();
      if (!hook.isUsed()) return [];
      const breakpoints = [
        liteTapable7.minStage,
        ...stages,
        liteTapable7.maxStage
      ];
      const jsTaps = [];
      for (let i = 0; i < breakpoints.length - 1; i++) {
        const from = breakpoints[i];
        const to = breakpoints[i + 1];
        const stageRange = [from, to];
        const queried = hook.queryStageRange(stageRange);
        if (!queried.isUsed()) continue;
        jsTaps.push({
          function: createTap(queried),
          stage: liteTapable7.safeStage(from + 1)
        });
      }
      this.#decorateJsTaps(jsTaps);
      return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHook = getHook;
    return getTaps;
  }
  #createHookMapRegisterTaps(registerKind, getHookMap, createTap) {
    const getTaps = (stages) => {
      const map = getHookMap();
      if (!map.isUsed()) return [];
      const breakpoints = [
        liteTapable7.minStage,
        ...stages,
        liteTapable7.maxStage
      ];
      const jsTaps = [];
      for (let i = 0; i < breakpoints.length - 1; i++) {
        const from = breakpoints[i];
        const to = breakpoints[i + 1];
        const stageRange = [from, to];
        const queried = map.queryStageRange(stageRange);
        if (!queried.isUsed()) continue;
        jsTaps.push({
          function: createTap(queried),
          stage: liteTapable7.safeStage(from + 1)
        });
      }
      this.#decorateJsTaps(jsTaps);
      return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHookMap = getHookMap;
    return getTaps;
  }
  __internal__registerBuiltinPlugin(plugin2) {
    this.#builtinPlugins.push(plugin2);
  }
  __internal__getModuleExecutionResult(id) {
    return this.#moduleExecutionResultsMap.get(id);
  }
};

// src/MultiCompiler.ts
var liteTapable8 = __toESM(require("@rspack/lite-tapable"));
var import_neo_async3 = __toESM(require_async());

// src/MultiStats.ts
var MultiStats = class {
  constructor(stats) {
    this.stats = stats;
  }
  get hash() {
    return this.stats.map((stat) => stat.hash).join("");
  }
  hasErrors() {
    return this.stats.some((stat) => stat.hasErrors());
  }
  hasWarnings() {
    return this.stats.some((stat) => stat.hasWarnings());
  }
  #createChildOptions(options, context2) {
    const { children: childrenOptions = void 0, ...baseOptions } = typeof options === "string" ? { preset: options } : options;
    const children = this.stats.map((stat, idx) => {
      const childOptions = Array.isArray(childrenOptions) ? childrenOptions[idx] : childrenOptions;
      return stat.compilation.createStatsOptions(
        {
          ...baseOptions,
          ...typeof childOptions === "string" ? { preset: childOptions } : childOptions && typeof childOptions === "object" ? childOptions : void 0
        },
        context2
      );
    });
    return {
      hash: children.every((o) => o.hash),
      errorsCount: children.every((o) => o.errorsCount),
      warningsCount: children.every((o) => o.warningsCount),
      errors: children.every((o) => o.errors),
      warnings: children.every((o) => o.warnings),
      children,
      context: "",
      version: ""
    };
  }
  toJson(options) {
    const childOptions = this.#createChildOptions(options || {}, {
      forToString: false
    });
    const obj = {};
    obj.children = this.stats.map((stat, idx) => {
      const obj2 = stat.toJson(childOptions.children[idx]);
      const compilationName = stat.compilation.name;
      const name2 = compilationName && makePathsRelative(
        childOptions.context,
        compilationName,
        stat.compilation.compiler.root
      );
      obj2.name = name2;
      return obj2;
    });
    if (childOptions.version) {
      obj.rspackVersion = require_package().version;
      obj.version = require_package().webpackVersion;
    }
    if (childOptions.hash) {
      obj.hash = obj.children.map((j) => j.hash).join("");
    }
    const mapError = (j, obj2) => {
      return {
        ...obj2,
        compilerPath: obj2.compilerPath ? `${j.name}.${obj2.compilerPath}` : j.name
      };
    };
    if (childOptions.errors) {
      obj.errors = [];
      for (const j of obj.children) {
        for (const i of j.errors || []) {
          obj.errors.push(mapError(j, i));
        }
      }
    }
    if (childOptions.warnings) {
      obj.warnings = [];
      for (const j of obj.children) {
        for (const i of j.warnings || []) {
          obj.warnings.push(mapError(j, i));
        }
      }
    }
    if (childOptions.errorsCount) {
      obj.errorsCount = 0;
      for (const j of obj.children) {
        obj.errorsCount += j.errorsCount || 0;
      }
    }
    if (childOptions.warningsCount) {
      obj.warningsCount = 0;
      for (const j of obj.children) {
        obj.warningsCount += j.warningsCount || 0;
      }
    }
    return obj;
  }
  toString(options) {
    const childOptions = this.#createChildOptions(options || {}, {
      forToString: true
    });
    const results = this.stats.map((stat, idx) => {
      const str = stat.toString(childOptions.children[idx]);
      const compilationName = stat.compilation.name;
      const name2 = compilationName && makePathsRelative(
        childOptions.context,
        compilationName,
        stat.compilation.compiler.root
      ).replace(/\|/g, " ");
      if (!str) return str;
      return name2 ? `${name2}:
${indent(str, "  ")}` : str;
    });
    return results.filter(Boolean).join("\n\n");
  }
};

// src/MultiWatching.ts
var import_neo_async2 = __toESM(require_async());
var MultiWatching = class {
  /**
   * @param watchings - child compilers' watchers
   * @param compiler - the compiler
   */
  constructor(watchings, compiler) {
    this.watchings = watchings;
    this.compiler = compiler;
  }
  invalidate(callback) {
    if (callback) {
      import_neo_async2.default.each(
        this.watchings,
        (watching, callback2) => watching.invalidate(callback2),
        // cannot be resolved without assertion
        // Type 'Error | null | undefined' is not assignable to type 'Error | null'
        callback
      );
    } else {
      for (const watching of this.watchings) {
        watching.invalidate();
      }
    }
  }
  close(callback) {
    import_neo_async2.default.forEach(
      this.watchings,
      (watching, finishedCallback) => {
        watching.close(finishedCallback);
      },
      (err) => {
        this.compiler.hooks.watchClose.call();
        if (typeof callback === "function") {
          this.compiler.running = false;
          callback(err);
        }
      }
    );
  }
  suspend() {
    for (const watching of this.watchings) {
      watching.suspend();
    }
  }
  resume() {
    for (const watching of this.watchings) {
      watching.resume();
    }
  }
};
var MultiWatching_default = MultiWatching;

// src/util/ArrayQueue.ts
var ArrayQueue = class {
  constructor(items) {
    this._list = items ? Array.from(items) : [];
    this._listReversed = [];
  }
  /**
   * Returns the number of elements in this queue.
   * @returns {number} The number of elements in this queue.
   */
  get length() {
    return this._list.length + this._listReversed.length;
  }
  /**
   * Empties the queue.
   */
  clear() {
    this._list.length = 0;
    this._listReversed.length = 0;
  }
  /**
   * Appends the specified element to this queue.
   * @param {T} item The element to add.
   * @returns {void}
   */
  enqueue(item) {
    this._list.push(item);
  }
  /**
   * Retrieves and removes the head of this queue.
   * @returns {T | undefined} The head of the queue of `undefined` if this queue is empty.
   */
  dequeue() {
    if (this._listReversed.length === 0) {
      if (this._list.length === 0) return void 0;
      if (this._list.length === 1) return this._list.pop();
      if (this._list.length < 16) return this._list.shift();
      const temp = this._listReversed;
      this._listReversed = this._list;
      this._listReversed.reverse();
      this._list = temp;
    }
    return this._listReversed.pop();
  }
  /**
   * Finds and removes an item
   * @param {T} item the item
   * @returns {void}
   */
  delete(item) {
    const i = this._list.indexOf(item);
    if (i >= 0) {
      this._list.splice(i, 1);
    } else {
      const i2 = this._listReversed.indexOf(item);
      if (i2 >= 0) this._listReversed.splice(i2, 1);
    }
  }
  [Symbol.iterator]() {
    let i = -1;
    let reversed = false;
    return {
      next: () => {
        if (!reversed) {
          i++;
          if (i < this._list.length) {
            return {
              done: false,
              value: this._list[i]
            };
          }
          reversed = true;
          i = this._listReversed.length;
        }
        i--;
        if (i < 0) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: this._listReversed[i]
        };
      }
    };
  }
};
var ArrayQueue_default = ArrayQueue;

// src/MultiCompiler.ts
var MultiCompiler = class {
  constructor(compilers, options) {
    let normalizedCompilers;
    if (!Array.isArray(compilers)) {
      normalizedCompilers = Object.entries(compilers).map(
        ([name2, compiler]) => {
          compiler.name = name2;
          return compiler;
        }
      );
    } else {
      normalizedCompilers = compilers;
    }
    this.hooks = {
      done: new liteTapable8.SyncHook(["stats"]),
      invalid: new liteTapable8.MultiHook(
        normalizedCompilers.map((c) => c.hooks.invalid)
      ),
      run: new liteTapable8.MultiHook(normalizedCompilers.map((c) => c.hooks.run)),
      watchClose: new liteTapable8.SyncHook([]),
      watchRun: new liteTapable8.MultiHook(
        normalizedCompilers.map((c) => c.hooks.watchRun)
      ),
      infrastructureLog: new liteTapable8.MultiHook(
        normalizedCompilers.map((c) => c.hooks.infrastructureLog)
      )
    };
    this.compilers = normalizedCompilers;
    this._options = {
      parallelism: (options == null ? void 0 : options.parallelism) || Number.POSITIVE_INFINITY
    };
    this.dependencies = /* @__PURE__ */ new WeakMap();
    this.running = false;
    const compilerStats = this.compilers.map(() => null);
    let doneCompilers = 0;
    for (let index = 0; index < this.compilers.length; index++) {
      const compiler = this.compilers[index];
      const compilerIndex = index;
      let compilerDone = false;
      compiler.hooks.done.tap("MultiCompiler", (stats) => {
        if (!compilerDone) {
          compilerDone = true;
          doneCompilers++;
        }
        compilerStats[compilerIndex] = stats;
        if (doneCompilers === this.compilers.length) {
          this.hooks.done.call(new MultiStats(compilerStats));
        }
      });
      compiler.hooks.invalid.tap("MultiCompiler", () => {
        if (compilerDone) {
          compilerDone = false;
          doneCompilers--;
        }
      });
    }
  }
  get options() {
    return Object.assign(
      this.compilers.map((c) => c.options),
      this._options
    );
  }
  get outputPath() {
    let commonPath = this.compilers[0].outputPath;
    for (const compiler of this.compilers) {
      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\]/.test(commonPath)) {
        commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
      }
    }
    if (!commonPath && this.compilers[0].outputPath[0] === "/") return "/";
    return commonPath;
  }
  get inputFileSystem() {
    throw new Error("Cannot read inputFileSystem of a MultiCompiler");
  }
  get outputFileSystem() {
    throw new Error("Cannot read outputFileSystem of a MultiCompiler");
  }
  get watchFileSystem() {
    throw new Error("Cannot read watchFileSystem of a MultiCompiler");
  }
  get intermediateFileSystem() {
    throw new Error("Cannot read outputFileSystem of a MultiCompiler");
  }
  set inputFileSystem(value) {
    for (const compiler of this.compilers) {
      compiler.inputFileSystem = value;
    }
  }
  set outputFileSystem(value) {
    for (const compiler of this.compilers) {
      compiler.outputFileSystem = value;
    }
  }
  set watchFileSystem(value) {
    for (const compiler of this.compilers) {
      compiler.watchFileSystem = value;
    }
  }
  set intermediateFileSystem(value) {
    for (const compiler of this.compilers) {
      compiler.intermediateFileSystem = value;
    }
  }
  getInfrastructureLogger(name2) {
    return this.compilers[0].getInfrastructureLogger(name2);
  }
  /**
   * @param compiler - the child compiler
   * @param dependencies - its dependencies
   */
  setDependencies(compiler, dependencies2) {
    this.dependencies.set(compiler, dependencies2);
  }
  /**
   * @param callback - signals when the validation is complete
   * @returns true if the dependencies are valid
   */
  validateDependencies(callback) {
    const edges = /* @__PURE__ */ new Set();
    const missing = [];
    const targetFound = (compiler) => {
      for (const edge of edges) {
        if (edge.target === compiler) {
          return true;
        }
      }
      return false;
    };
    const sortEdges = (e1, e2) => {
      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);
    };
    for (const source of this.compilers) {
      const dependencies2 = this.dependencies.get(source);
      if (dependencies2) {
        for (const dep of dependencies2) {
          const target2 = this.compilers.find((c) => c.name === dep);
          if (!target2) {
            missing.push(dep);
          } else {
            edges.add({
              source,
              target: target2
            });
          }
        }
      }
    }
    const errors = missing.map(
      (m) => `Compiler dependency \`${m}\` not found.`
    );
    const stack = this.compilers.filter((c) => !targetFound(c));
    while (stack.length > 0) {
      const current = stack.pop();
      for (const edge of edges) {
        if (edge.source === current) {
          edges.delete(edge);
          const target2 = edge.target;
          if (!targetFound(target2)) {
            stack.push(target2);
          }
        }
      }
    }
    if (edges.size > 0) {
      const lines = Array.from(edges).sort(sortEdges).map((edge) => `${edge.source.name} -> ${edge.target.name}`);
      lines.unshift("Circular dependency found in compiler dependencies.");
      errors.unshift(lines.join("\n"));
    }
    if (errors.length > 0) {
      const message = errors.join("\n");
      callback(new Error(message));
      return false;
    }
    return true;
  }
  /**
   * @template SetupResult
   * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler
   * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler
   * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers
   * @returns {SetupResult[]} result of setup
   */
  #runGraph(setup, run, callback) {
    const nodes = this.compilers.map((compiler) => ({
      compiler,
      setupResult: void 0,
      result: void 0,
      state: "blocked",
      children: [],
      parents: []
    }));
    const compilerToNode = /* @__PURE__ */ new Map();
    for (const node3 of nodes) compilerToNode.set(node3.compiler.name, node3);
    for (const node3 of nodes) {
      const dependencies2 = this.dependencies.get(node3.compiler);
      if (!dependencies2) continue;
      for (const dep of dependencies2) {
        const parent = compilerToNode.get(dep);
        node3.parents.push(parent);
        parent.children.push(node3);
      }
    }
    const queue = new ArrayQueue_default();
    for (const node3 of nodes) {
      if (node3.parents.length === 0) {
        node3.state = "queued";
        queue.enqueue(node3);
      }
    }
    let errored = false;
    let running = 0;
    const parallelism = this._options.parallelism;
    const nodeDone = (node3, err, stats) => {
      if (errored) return;
      if (err) {
        errored = true;
        return import_neo_async3.default.each(
          nodes,
          (node4, callback2) => {
            if (node4.compiler.watching) {
              node4.compiler.watching.close(callback2);
            } else {
              callback2();
            }
          },
          () => callback(err)
        );
      }
      node3.result = stats;
      running--;
      if (node3.state === "running") {
        node3.state = "done";
        for (const child of node3.children) {
          if (child.state === "blocked") queue.enqueue(child);
        }
      } else if (node3.state === "running-outdated") {
        node3.state = "blocked";
        queue.enqueue(node3);
      }
      processQueue();
    };
    const nodeInvalidFromParent = (node3) => {
      if (node3.state === "done") {
        node3.state = "blocked";
      } else if (node3.state === "running") {
        node3.state = "running-outdated";
      }
      for (const child of node3.children) {
        nodeInvalidFromParent(child);
      }
    };
    const nodeInvalid = (node3) => {
      if (node3.state === "done") {
        node3.state = "pending";
      } else if (node3.state === "running") {
        node3.state = "running-outdated";
      }
      for (const child of node3.children) {
        nodeInvalidFromParent(child);
      }
    };
    const nodeChange = (node3) => {
      nodeInvalid(node3);
      if (node3.state === "pending") {
        node3.state = "blocked";
      }
      if (node3.state === "blocked") {
        queue.enqueue(node3);
        processQueue();
      }
    };
    const setupResults = [];
    nodes.forEach((node3, i) => {
      setupResults.push(
        node3.setupResult = setup(
          node3.compiler,
          i,
          nodeDone.bind(null, node3),
          () => node3.state !== "starting" && node3.state !== "running",
          () => nodeChange(node3),
          () => nodeInvalid(node3)
        )
      );
    });
    let processing = true;
    const processQueue = () => {
      if (processing) return;
      processing = true;
      process.nextTick(processQueueWorker);
    };
    const processQueueWorker = () => {
      while (running < parallelism && queue.length > 0 && !errored) {
        const node3 = queue.dequeue();
        if (node3.state === "queued" || node3.state === "blocked" && node3.parents.every((p) => p.state === "done")) {
          running++;
          node3.state = "starting";
          run(
            node3.compiler,
            node3.setupResult,
            nodeDone.bind(null, node3)
          );
          node3.state = "running";
        }
      }
      processing = false;
      if (!errored && running === 0 && nodes.every((node3) => node3.state === "done")) {
        const stats = [];
        for (const node3 of nodes) {
          const result2 = node3.result;
          if (result2) {
            node3.result = void 0;
            stats.push(result2);
          }
        }
        if (stats.length > 0) {
          callback(null, new MultiStats(stats));
        }
      }
    };
    processQueueWorker();
    return setupResults;
  }
  /**
   * @param watchOptions - the watcher's options
   * @param handler - signals when the call finishes
   * @returns a compiler watcher
   */
  watch(watchOptions2, handler) {
    if (this.running) {
      return handler(new ConcurrentCompilationError());
    }
    this.running = true;
    if (this.validateDependencies(handler)) {
      const watchings = this.#runGraph(
        (compiler, idx, done, isBlocked, setChanged, setInvalid) => {
          const watching = compiler.watch(
            Array.isArray(watchOptions2) ? watchOptions2[idx] : watchOptions2,
            done
          );
          if (watching) {
            watching.onInvalid = setInvalid;
            watching.onChange = setChanged;
            watching.isBlocked = isBlocked;
          }
          return watching;
        },
        (compiler, watching, _done) => {
          if (compiler.watching !== watching) return;
          if (!watching.running) watching.invalidate();
        },
        handler
      );
      return new MultiWatching_default(watchings, this);
    }
    return new MultiWatching_default([], this);
  }
  run(callback) {
    if (this.running) {
      return callback(new ConcurrentCompilationError());
    }
    this.running = true;
    if (this.validateDependencies(callback)) {
      this.#runGraph(
        () => {
        },
        (compiler, _, callback2) => compiler.run(callback2),
        (err, stats) => {
          this.running = false;
          if (callback !== void 0) {
            return callback(err, stats);
          }
        }
      );
    }
  }
  purgeInputFileSystem() {
    var _a, _b;
    for (const compiler of this.compilers) {
      (_b = (_a = compiler.inputFileSystem) == null ? void 0 : _a.purge) == null ? void 0 : _b.call(_a);
    }
  }
  close(callback) {
    import_neo_async3.default.each(
      this.compilers,
      (compiler, cb) => {
        compiler.close(cb);
      },
      // cannot be resolved without assertion
      // Type 'Error | null | undefined' is not assignable to type 'Error | null'
      callback
    );
  }
};

// src/rspackOptionsApply.ts
var import_node_assert8 = __toESM(require("assert"));
var import_graceful_fs = __toESM(require("../compiled/graceful-fs/index.js"));

// src/lib/IgnoreWarningsPlugin.ts
var IgnoreWarningsPlugin = class {
  /**
   * @param ignoreWarnings conditions to ignore warnings
   */
  constructor(ignorePattern) {
    this.name = "IgnoreWarningsPlugin";
    this._ignorePattern = ignorePattern;
  }
  /**
   * Apply the plugin
   * @param compiler the compiler instance
   * @returns
   */
  apply(compiler) {
    compiler.hooks.compilation.tap(this.name, (compilation) => {
      compilation.hooks.processWarnings.tap(this.name, (warnings) => {
        return warnings.filter((warning) => {
          return !this._ignorePattern.some(
            (ignore) => ignore(warning, compilation)
          );
        });
      });
    });
  }
};
var IgnoreWarningsPlugin_default = IgnoreWarningsPlugin;

// src/lib/cache/MemoryCachePlugin.ts
var _MemoryCachePlugin = class _MemoryCachePlugin {
  apply(compiler) {
    const cache = /* @__PURE__ */ new Map();
    compiler.cache.hooks.store.tap(
      { name: _MemoryCachePlugin.PLUGIN_NAME, stage: Cache.STAGE_MEMORY },
      (identifier, etag, data) => {
        const dataEtag = typeof (etag == null ? void 0 : etag.toString) === "function" ? etag.toString() : etag;
        cache.set(identifier, { etag: dataEtag, data });
      }
    );
    compiler.cache.hooks.get.tap(
      { name: _MemoryCachePlugin.PLUGIN_NAME, stage: Cache.STAGE_MEMORY },
      (identifier, etag, gotHandlers) => {
        const cacheEntry = cache.get(identifier);
        const dataEtag = typeof (etag == null ? void 0 : etag.toString) === "function" ? etag.toString() : etag;
        if (cacheEntry === null) {
          return null;
        }
        if (cacheEntry !== void 0) {
          return cacheEntry.etag === dataEtag ? cacheEntry.data : null;
        }
        gotHandlers.push((result2, callback) => {
          if (result2 === void 0) {
            cache.set(identifier, null);
          } else {
            cache.set(identifier, { etag: dataEtag, data: result2 });
          }
          return callback(null);
        });
      }
    );
    compiler.cache.hooks.shutdown.tap(
      { name: _MemoryCachePlugin.PLUGIN_NAME, stage: Cache.STAGE_MEMORY },
      () => {
        cache.clear();
      }
    );
  }
};
_MemoryCachePlugin.PLUGIN_NAME = "MemoryCachePlugin";
var MemoryCachePlugin = _MemoryCachePlugin;

// src/stats/DefaultStatsFactoryPlugin.ts
var util3 = __toESM(require("util"));

// src/stats/statsFactoryUtils.ts
var iterateConfig = (config2, options, fn2) => {
  for (const hookFor of Object.keys(config2)) {
    const subConfig = config2[hookFor];
    for (const option of Object.keys(subConfig)) {
      if (option !== "_") {
        if (option.startsWith("!")) {
          if (
            // string cannot be used as key, so use "as"
            options[option.slice(1)]
          )
            continue;
        } else {
          const value = options[option];
          if (value === false || value === void 0 || Array.isArray(value) && value.length === 0)
            continue;
        }
      }
      fn2(hookFor, subConfig[option]);
    }
  }
};
var getTotalItems = (children) => {
  let count = 0;
  for (const child of children) {
    if (!child.children && !child.filteredChildren) {
      count++;
    } else {
      if (child.children) count += getTotalItems(child.children);
      if (child.filteredChildren) count += child.filteredChildren;
    }
  }
  return count;
};
var collapse = (children) => {
  const newChildren = [];
  for (const child of children) {
    if (child.children) {
      let filteredChildren = child.filteredChildren || 0;
      filteredChildren += getTotalItems(child.children);
      newChildren.push({
        ...child,
        children: void 0,
        filteredChildren
      });
    } else {
      newChildren.push(child);
    }
  }
  return newChildren;
};
var getTotalSize = (children) => {
  let size = 0;
  for (const child of children) {
    size += getItemSize(child);
  }
  return size;
};
var getItemSize = (item) => {
  return !item.children ? 1 : item.filteredChildren ? 2 + getTotalSize(item.children) : 1 + getTotalSize(item.children);
};
var spaceLimited = (itemsAndGroups, max, filteredChildrenLineReserved = false) => {
  if (max < 1) {
    return {
      children: void 0,
      filteredChildren: getTotalItems(itemsAndGroups)
    };
  }
  let children = void 0;
  let filteredChildren = void 0;
  const groups = [];
  const groupSizes = [];
  const items = [];
  let groupsSize = 0;
  for (const itemOrGroup of itemsAndGroups) {
    if (!itemOrGroup.children && !itemOrGroup.filteredChildren) {
      items.push(itemOrGroup);
    } else {
      groups.push(itemOrGroup);
      const size = getItemSize(itemOrGroup);
      groupSizes.push(size);
      groupsSize += size;
    }
  }
  if (groupsSize + items.length <= max) {
    children = groups.length > 0 ? groups.concat(items) : items;
  } else if (groups.length === 0) {
    const limit = max - (filteredChildrenLineReserved ? 0 : 1);
    filteredChildren = items.length - limit;
    items.length = limit;
    children = items;
  } else {
    const limit = groups.length + (filteredChildrenLineReserved || items.length === 0 ? 0 : 1);
    if (limit < max) {
      let oversize;
      while ((oversize = groupsSize + items.length + (filteredChildren && !filteredChildrenLineReserved ? 1 : 0) - max) > 0) {
        const maxGroupSize = Math.max(...groupSizes);
        if (maxGroupSize < items.length) {
          filteredChildren = items.length;
          items.length = 0;
          continue;
        }
        for (let i = 0; i < groups.length; i++) {
          if (groupSizes[i] === maxGroupSize) {
            const group = groups[i];
            const headerSize = group.filteredChildren ? 2 : 1;
            const limited = spaceLimited(
              group.children,
              maxGroupSize - // we should use ceil to always feet in max
              Math.ceil(oversize / groups.length) - // we substitute size of group head
              headerSize,
              headerSize === 2
            );
            groups[i] = {
              ...group,
              children: limited.children,
              filteredChildren: limited.filteredChildren ? (group.filteredChildren || 0) + limited.filteredChildren : group.filteredChildren
            };
            const newSize = getItemSize(groups[i]);
            groupsSize -= maxGroupSize - newSize;
            groupSizes[i] = newSize;
            break;
          }
        }
      }
      children = groups.concat(items);
    } else if (limit === max) {
      children = collapse(groups);
      filteredChildren = items.length;
    } else {
      filteredChildren = getTotalItems(itemsAndGroups);
    }
  }
  return {
    children,
    filteredChildren
  };
};
var countWithChildren = (compilation, getItems) => {
  let count = getItems(compilation, "").length;
  for (const child of compilation.children) {
    count += countWithChildren(
      child,
      (c, type) => getItems(c, `.children[].compilation${type}`)
    );
  }
  return count;
};
var normalizeFieldKey = (field) => {
  if (field[0] === "!") {
    return field.slice(1);
  }
  return field;
};
var sortOrderRegular = (field) => {
  if (field[0] === "!") {
    return false;
  }
  return true;
};
var sortByField = (field) => {
  if (!field) {
    const noSort = (_a, _b) => 0;
    return noSort;
  }
  const fieldKey = normalizeFieldKey(field);
  let sortFn = compareSelect(
    (m) => m[fieldKey],
    compareIds
  );
  const sortIsRegular = sortOrderRegular(field);
  if (!sortIsRegular) {
    const oldSortFn = sortFn;
    sortFn = (a, b) => oldSortFn(b, a);
  }
  return sortFn;
};
var assetGroup = (children) => {
  let size = 0;
  for (const asset of children) {
    size += asset.size;
  }
  return {
    size
  };
};
var moduleGroup = (children) => {
  let size = 0;
  const sizes = {};
  for (const module2 of children) {
    size += module2.size;
    for (const key of Object.keys(module2.sizes)) {
      sizes[key] = (sizes[key] || 0) + module2.sizes[key];
    }
  }
  return {
    size,
    sizes
  };
};
var mergeToObject = (items) => {
  const obj = /* @__PURE__ */ Object.create(null);
  for (const item of items) {
    obj[item.name] = item;
  }
  return obj;
};
function resolveStatsMillisecond(s) {
  return s.secs * 1e3 + s.subsecMillis;
}
var errorsSpaceLimit = (errors, max) => {
  let filtered = 0;
  if (errors.length + 1 >= max) {
    return {
      errors: errors.map((error) => {
        if (typeof error === "string" || !error.details) return error;
        filtered++;
        return { ...error, details: "" };
      }),
      filtered
    };
  }
  let fullLength = errors.length;
  let result2 = errors;
  let i = 0;
  for (; i < errors.length; i++) {
    const error = errors[i];
    if (typeof error !== "string" && error.details) {
      const splitted = error.details.split("\n");
      const len = splitted.length;
      fullLength += len;
      if (fullLength > max) {
        result2 = i > 0 ? errors.slice(0, i) : [];
        const overLimit = fullLength - max + 1;
        const error2 = errors[i++];
        result2.push({
          ...error2,
          details: error2.details.split("\n").slice(0, -overLimit).join("\n"),
          filteredDetails: overLimit
        });
        filtered = errors.length - i;
        for (; i < errors.length; i++) {
          const error3 = errors[i];
          if (typeof error3 === "string" || !error3.details) result2.push(error3);
          result2.push({ ...error3, details: "" });
        }
        break;
      }
      if (fullLength === max) {
        result2 = errors.slice(0, ++i);
        filtered = errors.length - i;
        for (; i < errors.length; i++) {
          const error2 = errors[i];
          if (typeof error2 === "string" || !error2.details) result2.push(error2);
          result2.push({ ...error2, details: "" });
        }
        break;
      }
    }
  }
  return {
    errors: result2,
    filtered
  };
};

// src/stats/DefaultStatsFactoryPlugin.ts
var compareIds2 = compareIds;
var GROUP_EXTENSION_REGEXP = /(\.[^.]+?)(?:\?|(?: \+ \d+ modules?)?$)/;
var GROUP_PATH_REGEXP = /(.+)[/\\][^/\\]+?(?:\?|(?: \+ \d+ modules?)?$)/;
var ITEM_NAMES = {
  "compilation.children[]": "compilation",
  "compilation.modules[]": "module",
  "compilation.entrypoints[]": "chunkGroup",
  "compilation.namedChunkGroups[]": "chunkGroup",
  "compilation.errors[]": "error",
  "compilation.warnings[]": "warning",
  "chunk.modules[]": "module",
  "chunk.rootModules[]": "module",
  "chunk.origins[]": "chunkOrigin",
  "compilation.chunks[]": "chunk",
  "compilation.assets[]": "asset",
  "asset.related[]": "asset",
  "module.issuerPath[]": "moduleIssuer",
  "module.reasons[]": "moduleReason",
  "module.modules[]": "module",
  "module.children[]": "module",
  "moduleTrace[]": "moduleTraceItem"
  // "moduleTraceItem.dependencies[]": "moduleTraceDependency"
};
var MERGER = {
  "compilation.entrypoints": mergeToObject,
  "compilation.namedChunkGroups": mergeToObject
};
var ASSETS_GROUPERS = {
  _: (groupConfigs, _context, options) => {
    const groupByFlag = (name2, exclude) => {
      groupConfigs.push({
        getKeys: (asset) => {
          return asset[name2] ? ["1"] : void 0;
        },
        getOptions: () => {
          return {
            groupChildren: !exclude,
            force: exclude
          };
        },
        createGroup: (key, children, assets) => {
          return exclude ? {
            type: "assets by status",
            [name2]: !!key,
            filteredChildren: assets.length,
            ...assetGroup(children)
          } : {
            type: "assets by status",
            [name2]: !!key,
            children,
            ...assetGroup(children)
          };
        }
      });
    };
    const {
      groupAssetsByEmitStatus,
      groupAssetsByPath,
      groupAssetsByExtension
    } = options;
    if (groupAssetsByEmitStatus) {
      groupByFlag("emitted");
    }
    if (groupAssetsByEmitStatus || !options.cachedAssets) {
      groupByFlag("cached", !options.cachedAssets);
    }
    if (groupAssetsByPath || groupAssetsByExtension) {
      groupConfigs.push({
        getKeys: (asset) => {
          const extensionMatch = groupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);
          const extension = extensionMatch ? extensionMatch[1] : "";
          const pathMatch = groupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);
          const path10 = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
          const keys = [];
          if (groupAssetsByPath) {
            keys.push(".");
            if (extension)
              keys.push(
                path10.length ? `${path10.join("/")}/*${extension}` : `*${extension}`
              );
            while (path10.length > 0) {
              keys.push(`${path10.join("/")}/`);
              path10.pop();
            }
          } else {
            if (extension) keys.push(`*${extension}`);
          }
          return keys;
        },
        createGroup: (key, children) => {
          return {
            type: groupAssetsByPath ? "assets by path" : "assets by extension",
            name: key,
            children,
            ...assetGroup(children)
          };
        }
      });
    }
  },
  groupAssetsByInfo: (groupConfigs) => {
    const groupByAssetInfoFlag = (name2) => {
      groupConfigs.push({
        getKeys: (asset) => {
          var _a;
          return ((_a = asset.info) == null ? void 0 : _a[name2]) ? ["1"] : void 0;
        },
        createGroup: (key, children) => {
          return {
            type: "assets by info",
            info: {
              [name2]: !!key
            },
            children,
            ...assetGroup(children)
          };
        }
      });
    };
    groupByAssetInfoFlag("immutable");
    groupByAssetInfoFlag("development");
    groupByAssetInfoFlag("hotModuleReplacement");
  },
  groupAssetsByChunk: (groupConfigs) => {
    const groupByNames = (name2) => {
      groupConfigs.push({
        getKeys: (asset) => {
          return asset[name2];
        },
        createGroup: (key, children) => {
          return {
            type: "assets by chunk",
            [name2]: [key],
            children,
            ...assetGroup(children)
          };
        }
      });
    };
    groupByNames("chunkNames");
    groupByNames("auxiliaryChunkNames");
    groupByNames("chunkIdHints");
    groupByNames("auxiliaryChunkIdHints");
  },
  excludeAssets: (groupConfigs, _context, { excludeAssets }) => {
    groupConfigs.push({
      getKeys: (asset) => {
        const ident = asset.name;
        const excluded = excludeAssets.some((fn2) => fn2(ident, asset));
        if (excluded) return ["excluded"];
      },
      getOptions: () => ({
        groupChildren: false,
        force: true
      }),
      createGroup: (_key, children, assets) => ({
        type: "hidden assets",
        filteredChildren: assets.length,
        ...assetGroup(children)
      })
    });
  }
};
var MODULES_GROUPERS = (type) => ({
  _: (groupConfigs, _context, options) => {
    const groupByFlag = (name2, type2, exclude) => {
      groupConfigs.push({
        getKeys: (module2) => {
          return module2[name2] ? ["1"] : void 0;
        },
        getOptions: () => {
          return {
            groupChildren: !exclude,
            force: exclude
          };
        },
        createGroup: (key, children, modules) => {
          return {
            type: type2,
            [name2]: !!key,
            ...exclude ? { filteredChildren: modules.length } : { children },
            ...moduleGroup(children)
          };
        }
      });
    };
    const {
      groupModulesByCacheStatus,
      groupModulesByAttributes,
      groupModulesByType,
      groupModulesByPath,
      groupModulesByExtension
    } = options;
    if (groupModulesByAttributes) {
      groupByFlag("errors", "modules with errors");
      groupByFlag("warnings", "modules with warnings");
      groupByFlag("assets", "modules with assets");
      groupByFlag("optional", "optional modules");
    }
    if (groupModulesByCacheStatus) {
      groupByFlag("cacheable", "cacheable modules");
      groupByFlag("built", "built modules");
      groupByFlag("codeGenerated", "code generated modules");
    }
    if (groupModulesByCacheStatus || !options.cachedModules) {
      groupByFlag("cached", "cached modules", !options.cachedModules);
    }
    if (groupModulesByAttributes || !options.orphanModules) {
      groupByFlag("orphan", "orphan modules", !options.orphanModules);
    }
    if (groupModulesByAttributes || !options.dependentModules) {
      groupByFlag("dependent", "dependent modules", !options.dependentModules);
    }
    if (groupModulesByType || !options.runtimeModules) {
      groupConfigs.push({
        getKeys: (module2) => {
          const moduleType = module2.moduleType;
          if (!moduleType) return;
          if (groupModulesByType) {
            return [moduleType.split("/", 1)[0]];
          }
          if (moduleType === "runtime") {
            return ["runtime"];
          }
        },
        getOptions: (key) => {
          const exclude = key === "runtime" && !options.runtimeModules;
          return {
            groupChildren: !exclude,
            force: exclude
          };
        },
        createGroup: (key, children, modules) => {
          const exclude = key === "runtime" && !options.runtimeModules;
          return {
            type: `${key} modules`,
            moduleType: key,
            ...exclude ? { filteredChildren: modules.length } : { children },
            ...moduleGroup(children)
          };
        }
      });
    }
    if (groupModulesByPath || groupModulesByExtension) {
      groupConfigs.push({
        getKeys: (module2) => {
          if (!module2.name) return;
          const resource = parseResource(module2.name.split("!").pop()).path;
          const dataUrl = /^data:[^,;]+/.exec(resource);
          if (dataUrl) return [dataUrl[0]];
          const extensionMatch = groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);
          const extension = extensionMatch ? extensionMatch[1] : "";
          const pathMatch = groupModulesByPath && GROUP_PATH_REGEXP.exec(resource);
          const path10 = pathMatch ? pathMatch[1].split(/[/\\]/) : [];
          const keys = [];
          if (groupModulesByPath) {
            if (extension)
              keys.push(
                path10.length ? `${path10.join("/")}/*${extension}` : `*${extension}`
              );
            while (path10.length > 0) {
              keys.push(`${path10.join("/")}/`);
              path10.pop();
            }
          } else {
            if (extension) keys.push(`*${extension}`);
          }
          return keys;
        },
        createGroup: (key, children, _modules) => {
          const isDataUrl = key.startsWith("data:");
          return {
            type: isDataUrl ? "modules by mime type" : groupModulesByPath ? "modules by path" : "modules by extension",
            name: isDataUrl ? key.slice(
              /* 'data:'.length */
              5
            ) : key,
            children,
            ...moduleGroup(children)
          };
        }
      });
    }
  },
  excludeModules: (groupConfigs, _context, { excludeModules }) => {
    groupConfigs.push({
      getKeys: (module2) => {
        const name2 = module2.name;
        if (name2) {
          const excluded = excludeModules.some((fn2) => fn2(name2, module2, type));
          if (excluded) return ["1"];
        }
      },
      getOptions: () => ({
        groupChildren: false,
        force: true
      }),
      createGroup: (_key, children, _modules) => ({
        type: "hidden modules",
        filteredChildren: children.length,
        ...moduleGroup(children)
      })
    });
  }
});
var RESULT_GROUPERS = {
  "compilation.assets": ASSETS_GROUPERS,
  "asset.related": ASSETS_GROUPERS,
  "compilation.modules": MODULES_GROUPERS("module"),
  "chunk.modules": MODULES_GROUPERS("chunk"),
  "chunk.rootModules": MODULES_GROUPERS("root-of-chunk"),
  "module.modules": MODULES_GROUPERS("nested")
};
var ASSET_SORTERS = {
  assetsSort: (comparators, _context, { assetsSort }) => {
    comparators.push(sortByField(assetsSort));
  },
  _: (comparators) => {
    comparators.push(compareSelect((a) => a.name, compareIds2));
  }
};
var RESULT_SORTERS = {
  "compilation.chunks": {
    chunksSort: (comparators, _context, { chunksSort }) => {
      comparators.push(sortByField(chunksSort));
    }
  },
  "compilation.modules": {
    modulesSort: (comparators, _context, { modulesSort }) => {
      comparators.push(sortByField(modulesSort));
    }
  },
  "chunk.modules": {
    chunkModulesSort: (comparators, _context, { chunkModulesSort }) => {
      comparators.push(sortByField(chunkModulesSort));
    }
  },
  "module.modules": {
    nestedModulesSort: (comparators, _context, { nestedModulesSort }) => {
      comparators.push(sortByField(nestedModulesSort));
    }
  },
  "compilation.assets": ASSET_SORTERS,
  "asset.related": ASSET_SORTERS
};
var MODULES_SORTER = {
  _: (comparators) => {
    comparators.push(
      compareSelect(
        (m) => m.commonAttributes.depth,
        compareNumbers
      ),
      compareSelect(
        (m) => m.commonAttributes.preOrderIndex,
        compareNumbers
      ),
      compareSelect(
        (m) => {
          var _a;
          return (_a = m.commonAttributes.moduleDescriptor) == null ? void 0 : _a.identifier;
        },
        compareIds2
      )
    );
  }
};
var SORTERS = {
  "compilation.chunks": {
    _: (comparators) => {
      comparators.push(compareSelect((c) => c.id, compareIds2));
    }
  },
  "compilation.modules": MODULES_SORTER,
  "chunk.rootModules": MODULES_SORTER,
  "chunk.modules": MODULES_SORTER,
  "module.modules": MODULES_SORTER,
  "module.reasons": {
    _: (comparators) => {
      comparators.push(
        compareSelect((x) => x.moduleIdentifier, compareIds2)
      );
      comparators.push(
        compareSelect(
          (x) => x.resolvedModuleIdentifier,
          compareIds2
        )
      );
      comparators.push(
        compareSelect(
          (x) => x.dependency,
          compareSelect((x) => x.type, compareIds2)
          // concatComparators(
          // 	compareSelect(
          // 		/**
          // 		 * @param {Dependency} x dependency
          // 		 * @returns {DependencyLocation} location
          // 		 */
          // 		x => x.loc,
          // 		compareLocations
          // 	),
          // 	compareSelect(x => x.type, compareIds)
          // )
        )
      );
    }
  },
  "chunk.origins": {
    _: (comparators) => {
      comparators.push(
        compareSelect(
          (origin) => origin.moduleId,
          compareIds2
        ),
        compareSelect((origin) => origin.loc, compareIds2),
        compareSelect((origin) => origin.request, compareIds2)
      );
    }
  }
};
var EXTRACT_ERROR = {
  _: (object, error) => {
    object.message = error.message;
    if (error.chunkName) {
      object.chunkName = error.chunkName;
    }
    if (error.chunkEntry) {
      object.chunkEntry = error.chunkEntry;
    }
    if (error.chunkInitial) {
      object.chunkInitial = error.chunkInitial;
    }
    if (error.file) {
      object.file = error.file;
    }
    if (error.moduleDescriptor) {
      object.moduleIdentifier = error.moduleDescriptor.identifier;
      object.moduleName = error.moduleDescriptor.name;
    }
    if ("loc" in error) {
      object.loc = error.loc;
    }
  },
  ids: (object, error) => {
    if (error.chunkId) {
      object.chunkId = error.chunkId;
    }
    if (error.moduleDescriptor) {
      object.moduleId = error.moduleDescriptor.id;
    }
  },
  moduleTrace: (object, error, context2, _, factory) => {
    const { type } = context2;
    object.moduleTrace = factory.create(
      `${type}.moduleTrace`,
      error.moduleTrace,
      context2
    );
  },
  errorDetails: (object, error) => {
    object.details = error.details;
  },
  errorStack: (object, error) => {
    object.stack = error.stack;
  }
};
var SIMPLE_EXTRACTORS = {
  compilation: {
    _: (object, compilation, context2, options) => {
      const statsCompilation = context2.getStatsCompilation(compilation);
      if (!context2.makePathsRelative) {
        context2.makePathsRelative = makePathsRelative.bindContextCache(
          compilation.compiler.context,
          compilation.compiler.root
        );
      }
      if (!context2.cachedGetErrors) {
        context2.cachedGetErrors = (_compilation) => {
          return statsCompilation.errors;
        };
      }
      if (!context2.cachedGetWarnings) {
        context2.cachedGetWarnings = (_compilation) => {
          const warnings = statsCompilation.warnings;
          return compilation.hooks.processWarnings.call(
            warnings
          );
        };
      }
      if (compilation.name) {
        object.name = compilation.name;
      }
      const logging = options.logging;
      const loggingDebug = options.loggingDebug;
      const loggingTrace = options.loggingTrace;
      if (logging || loggingDebug && loggingDebug.length > 0) {
        let collapsedGroups = false;
        let acceptedTypes;
        if (logging === "verbose" || loggingDebug && loggingDebug.length > 0) {
          acceptedTypes = getLogTypesBitFlag([
            LogType.error,
            LogType.warn,
            LogType.info,
            LogType.log,
            LogType.group,
            LogType.groupEnd,
            LogType.groupCollapsed,
            LogType.profile,
            LogType.profileEnd,
            LogType.time,
            LogType.status,
            LogType.clear,
            LogType.cache
          ]);
          collapsedGroups = true;
        } else if (logging === "log" || logging === true) {
          acceptedTypes = getLogTypesBitFlag([
            LogType.error,
            LogType.warn,
            LogType.info,
            LogType.log,
            LogType.group,
            LogType.groupEnd,
            LogType.groupCollapsed,
            LogType.clear
          ]);
        } else if (logging === "info") {
          acceptedTypes = getLogTypesBitFlag([
            LogType.error,
            LogType.warn,
            LogType.info
          ]);
        } else if (logging === "warn") {
          acceptedTypes = getLogTypesBitFlag([LogType.error, LogType.warn]);
        } else if (logging === "error") {
          acceptedTypes = getLogTypesBitFlag([LogType.error]);
        } else {
          acceptedTypes = getLogTypesBitFlag([]);
        }
        object.logging = {};
        const compilationLogging = compilation.logging;
        for (const { name: name2, ...rest } of context2.getInner(compilation).getLogging(acceptedTypes)) {
          const value = compilationLogging.get(name2);
          const entry2 = {
            type: rest.type,
            trace: rest.trace,
            args: rest.args ?? []
          };
          if (value) {
            value.push(entry2);
          } else {
            compilationLogging.set(name2, [entry2]);
          }
        }
        let depthInCollapsedGroup = 0;
        for (const [origin, logEntries] of compilationLogging) {
          const debugMode = loggingDebug.some((fn2) => fn2(origin));
          if (logging === false && !debugMode) continue;
          const groupStack = [];
          const rootList = [];
          let currentList = rootList;
          let processedLogEntries = 0;
          for (const entry2 of logEntries) {
            let type = entry2.type;
            const typeBitFlag = getLogTypeBitFlag(type);
            if (!debugMode && (acceptedTypes & typeBitFlag) !== typeBitFlag)
              continue;
            if (type === LogType.groupCollapsed && (debugMode || collapsedGroups))
              type = LogType.group;
            if (depthInCollapsedGroup === 0) {
              processedLogEntries++;
            }
            if (type === LogType.groupEnd) {
              groupStack.pop();
              if (groupStack.length > 0) {
                currentList = groupStack[groupStack.length - 1].children;
              } else {
                currentList = rootList;
              }
              if (depthInCollapsedGroup > 0) depthInCollapsedGroup--;
              continue;
            }
            const message = entry2.args && entry2.args.length > 0 ? util3.format(entry2.args[0], ...entry2.args.slice(1)) : "";
            const newEntry = {
              type,
              message,
              trace: loggingTrace ? entry2.trace : void 0,
              children: type === LogType.group || type === LogType.groupCollapsed ? [] : void 0
            };
            currentList.push(newEntry);
            if (newEntry.children) {
              groupStack.push(newEntry);
              currentList = newEntry.children;
              if (depthInCollapsedGroup > 0) {
                depthInCollapsedGroup++;
              } else if (type === LogType.groupCollapsed) {
                depthInCollapsedGroup = 1;
              }
            }
          }
          object.logging[origin] = {
            entries: rootList,
            filteredEntries: logEntries.length - processedLogEntries,
            debug: debugMode
          };
        }
      }
    },
    hash: (object, compilation, context2) => {
      const statsCompilation = context2.getStatsCompilation(compilation);
      object.hash = statsCompilation.hash;
    },
    version: (object) => {
      const { version: version2, webpackVersion } = require_package();
      object.version = webpackVersion;
      object.rspackVersion = version2;
    },
    env: (object, _compilation, _context, { _env }) => {
      object.env = _env;
    },
    timings: (object, compilation) => {
      object.time = compilation.endTime - compilation.startTime;
    },
    builtAt: (object, compilation) => {
      object.builtAt = compilation.endTime;
    },
    publicPath: (object, compilation) => {
      object.publicPath = compilation.getPath(
        compilation.outputOptions.publicPath || ""
      );
    },
    outputPath: (object, compilation) => {
      object.outputPath = compilation.outputOptions.path;
    },
    assets: (object, compilation, context2, options, factory) => {
      const { type, getStatsCompilation } = context2;
      const statsCompilation = getStatsCompilation(compilation);
      const compilationAssets = statsCompilation.assets;
      const assetsByChunkName = statsCompilation.assetsByChunkName;
      const assetMap = /* @__PURE__ */ new Map();
      const assets = /* @__PURE__ */ new Set();
      for (const asset of compilationAssets) {
        const item = {
          ...asset,
          type: "asset",
          related: []
        };
        assets.add(item);
        assetMap.set(asset.name, item);
      }
      for (const item of assetMap.values()) {
        const related = item.info.related;
        if (!related) continue;
        for (const { name: type2, value: relatedEntry } of related) {
          const deps = Array.isArray(relatedEntry) ? relatedEntry : [relatedEntry];
          for (const dep of deps) {
            const depItem = assetMap.get(dep);
            if (!depItem) continue;
            assets.delete(depItem);
            depItem.type = type2;
            item.related = item.related || [];
            item.related.push(depItem);
          }
        }
      }
      object.assetsByChunkName = assetsByChunkName.reduce((acc, cur) => {
        acc[cur.name] = cur.files;
        return acc;
      }, {});
      const groupedAssets = factory.create(
        `${type}.assets`,
        Array.from(assets),
        {
          ...context2
          // compilationFileToChunks
          // compilationAuxiliaryFileToChunks
        }
      );
      const limited = spaceLimited(
        groupedAssets,
        options.assetsSpace ?? Number.POSITIVE_INFINITY
      );
      object.assets = limited.children;
      object.filteredAssets = limited.filteredChildren;
    },
    chunks: (object, compilation, context2, options, factory) => {
      const { type, getStatsCompilation } = context2;
      const statsCompilation = getStatsCompilation(compilation);
      const chunks = statsCompilation.chunks;
      object.chunks = factory.create(
        `${type}.chunks`,
        chunks,
        context2
      );
    },
    modules: (object, compilation, context2, options, factory) => {
      const { type, getStatsCompilation } = context2;
      const statsCompilation = getStatsCompilation(compilation);
      const array = statsCompilation.modules;
      const groupedModules = factory.create(`${type}.modules`, array, context2);
      const limited = spaceLimited(groupedModules, options.modulesSpace);
      object.modules = limited.children;
      object.filteredModules = limited.filteredChildren;
    },
    entrypoints: (object, compilation, context2, { entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren }, factory) => {
      const { type, getStatsCompilation } = context2;
      const statsCompilation = getStatsCompilation(compilation);
      const array = statsCompilation.entrypoints.map((entrypoint) => ({
        name: entrypoint.name,
        chunkGroup: entrypoint
      }));
      const chunks = Array.from(compilation.chunks).reduce((res, chunk) => {
        res[chunk.id] = chunk;
        return res;
      }, {});
      if (entrypoints === "auto" && !chunkGroups) {
        if (array.length > 5) return;
        if (!chunkGroupChildren && array.every(({ chunkGroup }) => {
          if (chunkGroup.chunks.length !== 1) return false;
          const chunk = chunks[chunkGroup.chunks[0]];
          return chunk && chunk.files.size === 1 && (!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0);
        })) {
          return;
        }
      }
      object.entrypoints = factory.create(
        `${type}.entrypoints`,
        array,
        context2
      );
    },
    chunkGroups: (object, compilation, context2, { chunkGroupAuxiliary, chunkGroupChildren }, factory) => {
      const { type, getStatsCompilation } = context2;
      const statsCompilation = getStatsCompilation(compilation);
      const namedChunkGroups = statsCompilation.namedChunkGroups.map((cg) => ({
        name: cg.name,
        chunkGroup: cg
      }));
      object.namedChunkGroups = factory.create(
        `${type}.namedChunkGroups`,
        namedChunkGroups,
        context2
      );
    },
    errors: (object, compilation, context2, options, factory) => {
      const { type, cachedGetErrors } = context2;
      const rawErrors = cachedGetErrors(compilation);
      const factorizedErrors = factory.create(
        `${type}.errors`,
        cachedGetErrors(compilation),
        context2
      );
      let filtered = 0;
      if (options.errorDetails === "auto" && rawErrors.length >= 3) {
        filtered = rawErrors.map((e) => typeof e !== "string" && e.details).filter(Boolean).length;
      }
      if (options.errorDetails === true || !Number.isFinite(options.errorsSpace)) {
        object.errors = factorizedErrors;
        if (filtered) object.filteredErrorDetailsCount = filtered;
        return;
      }
      const { errors, filtered: filteredBySpace } = errorsSpaceLimit(
        factorizedErrors,
        options.errorsSpace
      );
      object.filteredErrorDetailsCount = filtered + filteredBySpace;
      object.errors = errors;
    },
    errorsCount: (object, compilation, { cachedGetErrors }) => {
      object.errorsCount = countWithChildren(
        compilation,
        (c) => cachedGetErrors(c)
      );
    },
    warnings: (object, compilation, context2, options, factory) => {
      const { type, cachedGetWarnings } = context2;
      const rawWarnings = factory.create(
        `${type}.warnings`,
        cachedGetWarnings(compilation),
        context2
      );
      let filtered = 0;
      if (options.errorDetails === "auto") {
        filtered = cachedGetWarnings(compilation).map((e) => typeof e !== "string" && e.details).filter(Boolean).length;
      }
      if (options.errorDetails === true || !Number.isFinite(options.warningsSpace)) {
        object.warnings = rawWarnings;
        if (filtered) object.filteredWarningDetailsCount = filtered;
        return;
      }
      const { errors: warnings, filtered: filteredBySpace } = errorsSpaceLimit(
        rawWarnings,
        options.warningsSpace
      );
      object.filteredWarningDetailsCount = filtered + filteredBySpace;
      object.warnings = warnings;
    },
    warningsCount: (object, compilation, context2) => {
      const { cachedGetWarnings } = context2;
      object.warningsCount = countWithChildren(compilation, (c) => {
        return cachedGetWarnings(c);
      });
    },
    children: (object, compilation, context2, _options, factory) => {
      const { type } = context2;
      object.children = factory.create(
        `${type}.children`,
        compilation.children,
        context2
      );
    }
  },
  asset: {
    _: (object, asset, context2, options, factory) => {
      object.type = asset.type;
      object.name = asset.name;
      object.size = asset.size;
      object.emitted = asset.emitted;
      object.info = {
        ...asset.info,
        related: Object.fromEntries(
          asset.info.related.map((i) => [i.name, i.value])
        )
      };
      const cached = !object.emitted;
      object.cached = cached;
      if (!cached || options.cachedAssets) {
        Object.assign(
          object,
          factory.create(`${context2.type}$visible`, asset, context2)
        );
      }
    }
  },
  asset$visible: {
    _: (object, asset) => {
      object.chunkNames = asset.chunkNames;
      object.chunkIdHints = asset.chunkIdHints.filter(Boolean);
      object.auxiliaryChunkNames = asset.auxiliaryChunkNames;
      object.auxiliaryChunkIdHints = asset.auxiliaryChunkIdHints.filter(Boolean);
    },
    relatedAssets: (object, asset, context2, _options, factory) => {
      const { type } = context2;
      object.related = factory.create(
        `${type.slice(0, -8)}.related`,
        asset.related,
        context2
      );
      object.filteredRelated = asset.related ? asset.related.length - object.related.length : void 0;
    },
    ids: (object, asset) => {
      object.chunks = asset.chunks;
      object.auxiliaryChunks = asset.auxiliaryChunks;
    },
    performance: (object, asset) => {
      object.isOverSizeLimit = asset.info.isOverSizeLimit;
    }
  },
  chunkGroup: {
    _: (object, { name: name2, chunkGroup }, _context, { chunkGroupMaxAssets }) => {
      object.name = name2;
      object.chunks = chunkGroup.chunks;
      object.assets = chunkGroup.assets;
      object.filteredAssets = chunkGroup.assets.length <= chunkGroupMaxAssets ? 0 : chunkGroup.assets.length;
      object.assetsSize = chunkGroup.assetsSize;
      object.auxiliaryAssets = chunkGroup.auxiliaryAssets;
      object.auxiliaryAssetsSize = chunkGroup.auxiliaryAssetsSize;
      object.children = chunkGroup.children;
      object.childAssets = chunkGroup.childAssets;
    },
    performance: (object, { chunkGroup }) => {
      object.isOverSizeLimit = chunkGroup.isOverSizeLimit;
    }
  },
  module: {
    _: (object, module2, context2, options, factory) => {
      const { type } = context2;
      const { commonAttributes } = module2;
      object.type = commonAttributes.type;
      object.moduleType = commonAttributes.moduleType;
      object.layer = commonAttributes.layer;
      object.size = commonAttributes.size;
      const sizes = commonAttributes.sizes.map(({ sourceType, size }) => [
        sourceType,
        size
      ]);
      sizes.sort((a, b) => -compareIds2(a, b));
      object.sizes = Object.fromEntries(sizes);
      object.built = commonAttributes.built;
      object.codeGenerated = commonAttributes.codeGenerated;
      object.buildTimeExecuted = commonAttributes.buildTimeExecuted;
      object.cached = commonAttributes.cached;
      if (commonAttributes.built || commonAttributes.codeGenerated || options.cachedModules) {
        Object.assign(
          object,
          factory.create(`${type}$visible`, module2, context2)
        );
      }
    }
  },
  module$visible: {
    _: (object, module2, context2, _options, factory) => {
      var _a, _b;
      const { type } = context2;
      const { commonAttributes } = module2;
      if (commonAttributes.moduleDescriptor) {
        object.identifier = commonAttributes.moduleDescriptor.identifier;
        object.name = commonAttributes.moduleDescriptor.name;
      }
      object.nameForCondition = commonAttributes.nameForCondition;
      object.index = commonAttributes.preOrderIndex;
      object.preOrderIndex = commonAttributes.preOrderIndex;
      object.index2 = commonAttributes.postOrderIndex;
      object.postOrderIndex = commonAttributes.postOrderIndex;
      object.cacheable = commonAttributes.cacheable;
      object.optional = commonAttributes.optional;
      object.orphan = commonAttributes.orphan;
      object.dependent = module2.dependent;
      object.issuer = (_a = module2.issuerDescriptor) == null ? void 0 : _a.identifier;
      object.issuerName = (_b = module2.issuerDescriptor) == null ? void 0 : _b.name;
      object.issuerPath = module2.issuerDescriptor && factory.create(
        `${type.slice(0, -8)}.issuerPath`,
        module2.issuerPath,
        context2
      );
      object.failed = commonAttributes.failed;
      object.errors = commonAttributes.errors;
      object.warnings = commonAttributes.warnings;
      const profile2 = commonAttributes.profile;
      if (profile2) {
        object.profile = factory.create(`${type}.profile`, profile2, context2);
      }
    },
    ids: (object, module2) => {
      var _a;
      const { commonAttributes } = module2;
      if (commonAttributes.moduleDescriptor) {
        object.id = commonAttributes.moduleDescriptor.id;
      }
      object.issuerId = (_a = module2.issuerDescriptor) == null ? void 0 : _a.id;
      object.chunks = commonAttributes.chunks;
    },
    moduleAssets: (object, module2) => {
      object.assets = module2.commonAttributes.assets;
    },
    reasons: (object, module2, context2, options, factory) => {
      const { type } = context2;
      const groupsReasons = factory.create(
        `${type.slice(0, -8)}.reasons`,
        module2.commonAttributes.reasons,
        context2
      );
      const limited = spaceLimited(groupsReasons, options.reasonsSpace);
      object.reasons = limited.children;
      object.filteredReasons = limited.filteredChildren;
    },
    source: (object, module2) => {
      const { commonAttributes } = module2;
      object.source = commonAttributes.source;
    },
    usedExports: (object, module2) => {
      if (typeof module2.usedExports === "string") {
        if (module2.usedExports === "null") {
          object.usedExports = null;
        } else {
          object.usedExports = module2.usedExports === "true";
        }
      } else if (Array.isArray(module2.usedExports)) {
        object.usedExports = module2.usedExports;
      } else {
        object.usedExports = null;
      }
    },
    providedExports: (object, module2) => {
      const { commonAttributes } = module2;
      if (Array.isArray(commonAttributes.providedExports)) {
        object.providedExports = commonAttributes.providedExports;
      } else {
        object.providedExports = null;
      }
    },
    optimizationBailout: (object, module2) => {
      object.optimizationBailout = module2.commonAttributes.optimizationBailout || null;
    },
    depth: (object, module2) => {
      object.depth = module2.commonAttributes.depth;
    },
    nestedModules: (object, module2, context2, options, factory) => {
      const { type } = context2;
      const innerModules = (
        /** @type {Module & { modules?: Module[] }} */
        module2.modules
      );
      if (Array.isArray(innerModules) && innerModules.length > 0) {
        const groupedModules = factory.create(
          `${type.slice(0, -8)}.modules`,
          innerModules,
          context2
        );
        const limited = spaceLimited(
          groupedModules,
          options.nestedModulesSpace
        );
        object.modules = limited.children;
        object.filteredModules = limited.filteredChildren;
      }
    }
  },
  profile: {
    _: (object, profile2) => {
      const factory = resolveStatsMillisecond(profile2.factory);
      const building = resolveStatsMillisecond(profile2.building);
      const statsProfile = {
        total: factory + building,
        resolving: factory,
        building
      };
      Object.assign(object, statsProfile);
    }
  },
  moduleIssuer: {
    _: (object, module2, _context, _options, _factory) => {
      if (module2.moduleDescriptor) {
        object.identifier = module2.moduleDescriptor.identifier;
        object.name = module2.moduleDescriptor.name;
      }
    },
    ids: (object, module2) => {
      object.id = module2.moduleDescriptor.id;
    }
  },
  moduleReason: {
    _: (object, reason) => {
      if (reason.moduleDescriptor) {
        object.moduleIdentifier = reason.moduleDescriptor.identifier;
        object.moduleName = reason.moduleDescriptor.name;
      }
      object.type = reason.type;
      object.userRequest = reason.userRequest;
      if (reason.resolvedModuleDescriptor) {
        object.resolvedModuleIdentifier = reason.resolvedModuleDescriptor.identifier;
        object.resolvedModule = reason.resolvedModuleDescriptor.name;
      }
    },
    ids: (object, reason) => {
      object.moduleId = reason.moduleDescriptor ? reason.moduleDescriptor.id : null;
      object.resolvedModuleId = reason.resolvedModuleDescriptor ? reason.resolvedModuleDescriptor.id : null;
    }
  },
  chunk: {
    _: (object, chunk) => {
      object.type = chunk.type;
      object.rendered = chunk.rendered;
      object.initial = chunk.initial;
      object.entry = chunk.entry;
      object.reason = chunk.reason;
      object.size = chunk.size;
      object.sizes = Object.fromEntries(
        chunk.sizes.map(({ sourceType, size }) => [sourceType, size])
      );
      object.names = chunk.names;
      object.idHints = chunk.idHints;
      object.runtime = chunk.runtime;
      object.files = chunk.files;
      object.auxiliaryFiles = chunk.auxiliaryFiles;
      object.hash = chunk.hash;
      object.childrenByOrder = chunk.childrenByOrder;
    },
    ids: (object, chunk) => {
      object.id = chunk.id;
    },
    chunkRelations: (object, chunk) => {
      object.siblings = chunk.siblings;
      object.parents = chunk.parents;
      object.children = chunk.children;
    },
    chunkModules: (object, chunk, context2, options, factory) => {
      const { type } = context2;
      const groupedModules = factory.create(
        `${type}.modules`,
        chunk.modules,
        context2
      );
      const limited = spaceLimited(groupedModules, options.chunkModulesSpace);
      object.modules = limited.children;
      object.filteredModules = limited.filteredChildren;
    },
    chunkOrigins: (object, chunk, context2, _options, factory) => {
      const { type } = context2;
      object.origins = factory.create(
        `${type}.origins`,
        chunk.origins,
        context2
      );
    }
  },
  chunkOrigin: {
    _: (object, origin, _context) => {
      const { moduleDescriptor, loc, request } = origin;
      const statsChunkOrigin = {
        module: moduleDescriptor ? moduleDescriptor.identifier : "",
        moduleIdentifier: moduleDescriptor ? moduleDescriptor.identifier : "",
        moduleName: moduleDescriptor ? moduleDescriptor.name : "",
        loc,
        request
      };
      Object.assign(object, statsChunkOrigin);
    },
    ids: (object, origin) => {
      var _a;
      object.moduleId = (_a = origin.moduleDescriptor) == null ? void 0 : _a.id;
    }
  },
  error: EXTRACT_ERROR,
  warning: EXTRACT_ERROR,
  moduleTraceItem: {
    _: (object, { origin, module: module2 }, _context, { requestShortener }, _factory) => {
      if (origin.moduleDescriptor) {
        object.originIdentifier = origin.moduleDescriptor.identifier;
        object.originName = origin.moduleDescriptor.name;
      }
      if (module2.moduleDescriptor) {
        object.moduleIdentifier = module2.moduleDescriptor.identifier;
        object.moduleName = module2.moduleDescriptor.name;
      }
    },
    ids: (object, { origin, module: module2 }) => {
      object.originId = origin.moduleDescriptor.id;
      object.moduleId = module2.moduleDescriptor.id;
    }
  }
  // - moduleTraceDependency
};
var FILTER = {
  "module.reasons": {
    "!orphanModules": (reason) => {
      if (reason.moduleChunks === 0) {
        return false;
      }
    }
  }
};
var FILTER_RESULTS = {
  // Deprecated: "compilation.warnings": {}
  // Keep this object to retain this phase.
};
var DefaultStatsFactoryPlugin = class {
  apply(compiler) {
    compiler.hooks.compilation.tap("DefaultStatsFactoryPlugin", (compilation) => {
      compilation.hooks.statsFactory.tap(
        "DefaultStatsFactoryPlugin",
        (stats, options) => {
          iterateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn2) => {
            stats.hooks.extract.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (obj, data, ctx) => fn2(obj, data, ctx, options, stats)
            );
          });
          iterateConfig(FILTER, options, (hookFor, fn2) => {
            stats.hooks.filter.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (item, ctx, idx, i) => fn2(item, ctx, options, idx, i)
            );
          });
          iterateConfig(FILTER_RESULTS, options, (hookFor, fn2) => {
            stats.hooks.filterResults.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (item, ctx, idx, i) => fn2(item, ctx, options, idx, i)
            );
          });
          iterateConfig(SORTERS, options, (hookFor, fn2) => {
            stats.hooks.sort.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (comparators, ctx) => fn2(comparators, ctx, options)
            );
          });
          iterateConfig(RESULT_SORTERS, options, (hookFor, fn2) => {
            stats.hooks.sortResults.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (comparators, ctx) => fn2(comparators, ctx, options)
            );
          });
          iterateConfig(RESULT_GROUPERS, options, (hookFor, fn2) => {
            stats.hooks.groupResults.for(hookFor).tap(
              "DefaultStatsFactoryPlugin",
              (groupConfigs, ctx) => fn2(groupConfigs, ctx, options)
            );
          });
          for (const key of Object.keys(ITEM_NAMES)) {
            const itemName = ITEM_NAMES[key];
            stats.hooks.getItemName.for(key).tap("DefaultStatsFactoryPlugin", () => itemName);
          }
          for (const key of Object.keys(MERGER)) {
            const merger = MERGER[key];
            stats.hooks.merge.for(key).tap("DefaultStatsFactoryPlugin", merger);
          }
        }
      );
    });
  }
};

// src/stats/DefaultStatsPresetPlugin.ts
var applyDefaults = (options, defaults) => {
  for (const key of Object.keys(defaults)) {
    if (typeof options[key] === "undefined") {
      options[key] = defaults[key];
    }
  }
};
var NAMED_PRESETS = {
  verbose: {
    hash: true,
    builtAt: true,
    relatedAssets: true,
    entrypoints: true,
    chunkGroups: true,
    ids: true,
    modules: false,
    chunks: true,
    chunkRelations: true,
    chunkModules: true,
    dependentModules: true,
    chunkOrigins: true,
    depth: true,
    env: true,
    reasons: true,
    usedExports: true,
    providedExports: true,
    optimizationBailout: true,
    errorDetails: true,
    errorStack: true,
    publicPath: true,
    logging: "verbose",
    orphanModules: true,
    runtimeModules: true,
    // exclude: false,
    excludeModules: false,
    errorsSpace: Number.POSITIVE_INFINITY,
    warningsSpace: Number.POSITIVE_INFINITY,
    modulesSpace: Number.POSITIVE_INFINITY,
    chunkModulesSpace: Number.POSITIVE_INFINITY,
    assetsSpace: Number.POSITIVE_INFINITY,
    reasonsSpace: Number.POSITIVE_INFINITY,
    children: true
  },
  detailed: {
    hash: true,
    builtAt: true,
    relatedAssets: true,
    entrypoints: true,
    chunkGroups: true,
    ids: true,
    chunks: true,
    chunkRelations: true,
    chunkModules: false,
    chunkOrigins: true,
    depth: true,
    usedExports: true,
    providedExports: true,
    optimizationBailout: true,
    errorDetails: true,
    publicPath: true,
    logging: true,
    runtimeModules: true,
    excludeModules: false,
    errorsSpace: 1e3,
    warningsSpace: 1e3,
    modulesSpace: 1e3,
    assetsSpace: 1e3,
    reasonsSpace: 1e3
  },
  minimal: {
    all: false,
    version: true,
    timings: true,
    modules: true,
    errorsSpace: 0,
    warningsSpace: 0,
    modulesSpace: 0,
    assets: true,
    assetsSpace: 0,
    errors: true,
    errorsCount: true,
    warnings: true,
    warningsCount: true,
    logging: "warn"
  },
  "errors-only": {
    all: false,
    errors: true,
    errorsCount: true,
    errorsSpace: Number.POSITIVE_INFINITY,
    moduleTrace: true,
    logging: "error"
  },
  "errors-warnings": {
    all: false,
    errors: true,
    errorsCount: true,
    errorsSpace: Number.POSITIVE_INFINITY,
    warnings: true,
    warningsCount: true,
    warningsSpace: Number.POSITIVE_INFINITY,
    logging: "warn"
  },
  summary: {
    all: false,
    version: true,
    errorsCount: true,
    warningsCount: true
  },
  none: {
    all: false
  }
};
var NORMAL_ON = ({ all }) => all !== false;
var NORMAL_OFF = ({ all }) => all === true;
var ON_FOR_TO_STRING = ({ all }, { forToString }) => forToString ? all !== false : all === true;
var OFF_FOR_TO_STRING = ({ all }, { forToString }) => forToString ? all === true : all !== false;
var AUTO_FOR_TO_STRING = ({ all }, { forToString }) => {
  if (all === false) return false;
  if (all === true) return true;
  if (forToString) return "auto";
  return true;
};
var DEFAULTS = {
  // context: (options, context, compilation) => compilation.compiler.context,
  // requestShortener: (options, context, compilation) =>
  // 	compilation.compiler.context === options.context
  // 		? compilation.requestShortener
  // 		: new RequestShortener(options.context, compilation.compiler.root),
  performance: NORMAL_ON,
  hash: OFF_FOR_TO_STRING,
  env: NORMAL_OFF,
  version: NORMAL_ON,
  timings: NORMAL_ON,
  builtAt: OFF_FOR_TO_STRING,
  assets: NORMAL_ON,
  entrypoints: AUTO_FOR_TO_STRING,
  chunkGroups: OFF_FOR_TO_STRING,
  chunkGroupAuxiliary: OFF_FOR_TO_STRING,
  chunkGroupChildren: OFF_FOR_TO_STRING,
  chunkGroupMaxAssets: (o, { forToString }) => forToString ? 5 : Number.POSITIVE_INFINITY,
  chunks: OFF_FOR_TO_STRING,
  chunkRelations: OFF_FOR_TO_STRING,
  chunkModules: ({ all, modules }) => {
    if (all === false) return false;
    if (all === true) return true;
    if (modules) return false;
    return true;
  },
  dependentModules: OFF_FOR_TO_STRING,
  chunkOrigins: OFF_FOR_TO_STRING,
  ids: OFF_FOR_TO_STRING,
  modules: ({ all, chunks, chunkModules }, { forToString }) => {
    if (all === false) return false;
    if (all === true) return true;
    if (forToString && chunks && chunkModules) return false;
    return true;
  },
  nestedModules: OFF_FOR_TO_STRING,
  groupModulesByType: ON_FOR_TO_STRING,
  groupModulesByCacheStatus: ON_FOR_TO_STRING,
  groupModulesByLayer: ON_FOR_TO_STRING,
  groupModulesByAttributes: ON_FOR_TO_STRING,
  groupModulesByPath: ON_FOR_TO_STRING,
  groupModulesByExtension: ON_FOR_TO_STRING,
  modulesSpace: (o, { forToString }) => forToString ? 15 : Number.POSITIVE_INFINITY,
  chunkModulesSpace: (o, { forToString }) => forToString ? 10 : Number.POSITIVE_INFINITY,
  nestedModulesSpace: (o, { forToString }) => forToString ? 10 : Number.POSITIVE_INFINITY,
  relatedAssets: OFF_FOR_TO_STRING,
  groupAssetsByEmitStatus: ON_FOR_TO_STRING,
  groupAssetsByInfo: ON_FOR_TO_STRING,
  groupAssetsByPath: ON_FOR_TO_STRING,
  groupAssetsByExtension: ON_FOR_TO_STRING,
  groupAssetsByChunk: ON_FOR_TO_STRING,
  assetsSpace: (o, { forToString }) => forToString ? 15 : Number.POSITIVE_INFINITY,
  orphanModules: OFF_FOR_TO_STRING,
  runtimeModules: ({ all, runtime }, { forToString }) => runtime !== void 0 ? runtime : forToString ? all === true : all !== false,
  cachedModules: ({ all, cached }, { forToString }) => cached !== void 0 ? cached : forToString ? all === true : all !== false,
  moduleAssets: OFF_FOR_TO_STRING,
  depth: OFF_FOR_TO_STRING,
  cachedAssets: OFF_FOR_TO_STRING,
  reasons: OFF_FOR_TO_STRING,
  reasonsSpace: (o, { forToString }) => forToString ? 15 : Number.POSITIVE_INFINITY,
  groupReasonsByOrigin: ON_FOR_TO_STRING,
  usedExports: OFF_FOR_TO_STRING,
  providedExports: OFF_FOR_TO_STRING,
  optimizationBailout: OFF_FOR_TO_STRING,
  children: OFF_FOR_TO_STRING,
  source: NORMAL_OFF,
  moduleTrace: NORMAL_ON,
  errors: NORMAL_ON,
  errorsCount: NORMAL_ON,
  errorDetails: AUTO_FOR_TO_STRING,
  errorStack: OFF_FOR_TO_STRING,
  warnings: NORMAL_ON,
  warningsCount: NORMAL_ON,
  publicPath: OFF_FOR_TO_STRING,
  logging: ({ all }, { forToString }) => forToString && all !== false ? "info" : false,
  loggingDebug: () => [],
  loggingTrace: OFF_FOR_TO_STRING,
  excludeModules: () => [],
  excludeAssets: () => [],
  modulesSort: () => "depth",
  chunkModulesSort: () => "name",
  nestedModulesSort: () => false,
  chunksSort: () => false,
  assetsSort: () => "!size",
  outputPath: OFF_FOR_TO_STRING,
  colors: () => false
};
var normalizeFilter = (item) => {
  if (typeof item === "string") {
    const regExp = new RegExp(
      `[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`
    );
    return (ident) => regExp.test(ident);
  }
  if (item && typeof item === "object" && "test" in item && typeof item.test === "function") {
    const test = item.test.bind(item);
    return (ident) => test(ident);
  }
  if (typeof item === "function") {
    return item;
  }
  if (typeof item === "boolean") {
    return () => item;
  }
};
var NORMALIZER = {
  excludeModules: (value) => {
    const array = !Array.isArray(value) ? value ? [value] : [] : value;
    return array.map(normalizeFilter);
  },
  excludeAssets: (value) => {
    const array = !Array.isArray(value) ? value ? [value] : [] : value;
    return array.map(normalizeFilter);
  },
  warningsFilter: (value) => {
    const array = !Array.isArray(value) ? value ? [value] : [] : value;
    return array.map((filter) => {
      if (typeof filter === "string") {
        return (warning, warningString) => warningString.includes(filter);
      }
      if (filter instanceof RegExp) {
        return (warning, warningString) => filter.test(warningString);
      }
      if (typeof filter === "function") {
        return filter;
      }
      throw new Error(
        `Can only filter warnings with Strings or RegExps. (Given: ${filter})`
      );
    });
  },
  logging: (value) => {
    return value === true ? "log" : value;
  },
  loggingDebug: (value) => {
    const array = !Array.isArray(value) ? value ? [value] : [] : value;
    return array.map(normalizeFilter);
  }
};
var DefaultStatsPresetPlugin = class {
  apply(compiler) {
    compiler.hooks.compilation.tap("DefaultStatsPresetPlugin", (compilation) => {
      for (const key of Object.keys(NAMED_PRESETS)) {
        const defaults = NAMED_PRESETS[key];
        compilation.hooks.statsPreset.for(key).tap("DefaultStatsPresetPlugin", (options, context2) => {
          applyDefaults(options, defaults);
        });
      }
      compilation.hooks.statsNormalize.tap(
        "DefaultStatsPresetPlugin",
        (options, context2) => {
          for (const key of Object.keys(DEFAULTS)) {
            if (options[key] === void 0)
              options[key] = DEFAULTS[key](options, context2, compilation);
          }
          for (const key of Object.keys(NORMALIZER)) {
            options[key] = NORMALIZER[key](options[key]);
          }
        }
      );
    });
  }
};

// src/util/SizeFormatHelpers.ts
var formatSize = (size) => {
  if (typeof size !== "number" || Number.isNaN(size) === true) {
    return "unknown size";
  }
  if (size <= 0) {
    return "0 bytes";
  }
  const abbreviations = ["bytes", "KiB", "MiB", "GiB"];
  const index = Math.floor(Math.log(size) / Math.log(1024));
  return `${+(size / 1024 ** index).toPrecision(3)} ${abbreviations[index]}`;
};

// src/stats/DefaultStatsPrinterPlugin.ts
var DATA_URI_CONTENT_LENGTH = 16;
var plural = (n, singular, plural2) => n === 1 ? singular : plural2;
var printSizes = (sizes, { formatSize: formatSize2 = (n) => `${n}` }) => {
  const keys = Object.keys(sizes);
  if (keys.length > 1) {
    return keys.map((key) => `${formatSize2(sizes[key])} (${key})`).join(" ");
  }
  if (keys.length === 1) {
    return formatSize2(sizes[keys[0]]);
  }
};
var getResourceName = (resource) => {
  const dataUrl = /^data:[^,]+,/.exec(resource);
  if (!dataUrl) return resource;
  const len = dataUrl[0].length + DATA_URI_CONTENT_LENGTH;
  if (resource.length < len) return resource;
  return `${resource.slice(
    0,
    Math.min(resource.length - /* '..'.length */
    2, len)
  )}..`;
};
var getModuleName = (name2) => {
  const matchResourceMatch = /^([^!]+)!=!/.exec(name2);
  const n = matchResourceMatch ? matchResourceMatch[0] + getResourceName(name2.slice(matchResourceMatch[0].length)) : name2;
  const [, prefix, resource] = /^(.*!)?([^!]*)$/.exec(n) || [];
  return [prefix, getResourceName(resource)];
};
var mapLines = (str, fn2) => str.split("\n").map(fn2).join("\n");
var twoDigit = (n) => n >= 10 ? `${n}` : `0${n}`;
var isValidId = (id) => {
  return typeof id === "number" || id;
};
var moreCount = (list, count) => {
  return list && list.length > 0 ? `+ ${count}` : `${count}`;
};
var SIMPLE_PRINTERS = {
  "compilation.summary!": (_, {
    type,
    bold,
    green,
    red,
    yellow,
    formatDateTime,
    formatTime,
    compilation: {
      name: name2,
      hash,
      rspackVersion: rspackVersion2,
      time,
      builtAt,
      errorsCount,
      warningsCount
    }
  }) => {
    const root = type === "compilation.summary!";
    const warningsMessage = warningsCount && warningsCount > 0 ? yellow(
      `${warningsCount} ${plural(warningsCount, "warning", "warnings")}`
    ) : "";
    const errorsMessage = errorsCount && errorsCount > 0 ? red(`${errorsCount} ${plural(errorsCount, "error", "errors")}`) : "";
    const timeMessage = root && time ? ` in ${formatTime(time)}` : "";
    const hashMessage = hash ? ` (${hash})` : "";
    const builtAtMessage = root && builtAt ? `${formatDateTime(builtAt)}: ` : "";
    const versionMessage = root && rspackVersion2 ? `Rspack ${rspackVersion2}` : "";
    const nameMessage = root && name2 ? bold(name2) : name2 ? `Child ${bold(name2)}` : root ? "" : "Child";
    const subjectMessage = nameMessage && versionMessage ? `${nameMessage} (${versionMessage})` : versionMessage || nameMessage || "Rspack";
    let statusMessage;
    if (errorsMessage && warningsMessage) {
      statusMessage = `compiled with ${errorsMessage} and ${warningsMessage}`;
    } else if (errorsMessage) {
      statusMessage = `compiled with ${errorsMessage}`;
    } else if (warningsMessage) {
      statusMessage = `compiled with ${warningsMessage}`;
    } else if (errorsCount === 0 && warningsCount === 0) {
      statusMessage = `compiled ${green("successfully")}`;
    } else {
      statusMessage = "compiled";
    }
    if (builtAtMessage || versionMessage || errorsMessage || warningsMessage || errorsCount === 0 && warningsCount === 0 || timeMessage || hashMessage)
      return `${builtAtMessage}${subjectMessage} ${statusMessage}${timeMessage}${hashMessage}`;
  },
  "compilation.filteredWarningDetailsCount": (count) => count ? `${count} ${plural(
    count,
    "warning has",
    "warnings have"
  )} detailed information that is not shown.
Use 'stats.errorDetails: true' resp. '--stats-error-details' to show it.` : void 0,
  "compilation.filteredErrorDetailsCount": (count, { yellow }) => count ? yellow(
    `${count} ${plural(
      count,
      "error has",
      "errors have"
    )} detailed information that is not shown.
Use 'stats.errorDetails: true' resp. '--stats-error-details' to show it.`
  ) : void 0,
  "compilation.env": (env, { bold }) => env ? `Environment (--env): ${bold(JSON.stringify(env, null, 2))}` : void 0,
  "compilation.publicPath": (publicPath2, { bold }) => `PublicPath: ${bold(publicPath2 || "(none)")}`,
  "compilation.entrypoints": (entrypoints, context2, printer) => Array.isArray(entrypoints) ? void 0 : printer.print(context2.type, Object.values(entrypoints), {
    ...context2,
    chunkGroupKind: "Entrypoint"
  }),
  "compilation.namedChunkGroups": (namedChunkGroups, context2, printer) => {
    if (!Array.isArray(namedChunkGroups)) {
      const {
        compilation: { entrypoints }
      } = context2;
      let chunkGroups = Object.values(namedChunkGroups);
      if (entrypoints) {
        chunkGroups = chunkGroups.filter(
          (group) => !Object.prototype.hasOwnProperty.call(entrypoints, group.name)
        );
      }
      return printer.print(context2.type, chunkGroups, {
        ...context2,
        chunkGroupKind: "Chunk Group"
      });
    }
  },
  "compilation.assetsByChunkName": () => "",
  "compilation.filteredModules": (filteredModules, { compilation: { modules } }) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} ${plural(
    filteredModules,
    "module",
    "modules"
  )}` : void 0,
  "compilation.filteredAssets": (filteredAssets, { compilation: { assets } }) => filteredAssets > 0 ? `${moreCount(assets, filteredAssets)} ${plural(
    filteredAssets,
    "asset",
    "assets"
  )}` : void 0,
  "compilation.logging": (logging, context2, printer) => Array.isArray(logging) ? void 0 : printer.print(
    context2.type,
    Object.entries(logging).map(([name2, value]) => ({
      ...value,
      name: name2
    })),
    context2
  ),
  "compilation.warningsInChildren!": (_, { yellow, compilation }) => {
    if (!compilation.children && compilation.warningsCount && compilation.warningsCount > 0 && compilation.warnings) {
      const childWarnings = compilation.warningsCount - compilation.warnings.length;
      if (childWarnings > 0) {
        return yellow(
          `${childWarnings} ${plural(
            childWarnings,
            "WARNING",
            "WARNINGS"
          )} in child compilations${compilation.children ? "" : " (Use 'stats.children: true' resp. '--stats-children' for more details)"}`
        );
      }
    }
  },
  "compilation.errorsInChildren!": (_, { red, compilation }) => {
    if (!compilation.children && compilation.errorsCount && compilation.errorsCount > 0 && compilation.errors) {
      const childErrors = compilation.errorsCount - compilation.errors.length;
      if (childErrors > 0) {
        return red(
          `${childErrors} ${plural(
            childErrors,
            "ERROR",
            "ERRORS"
          )} in child compilations${compilation.children ? "" : " (Use 'stats.children: true' resp. '--stats-children' for more details)"}`
        );
      }
    }
  },
  "asset.type": (type) => type,
  "asset.name": (name2, { formatFilename, asset: { isOverSizeLimit } }) => formatFilename(name2, isOverSizeLimit),
  "asset.size": (size, { asset: { isOverSizeLimit }, yellow, green, formatSize: formatSize2 }) => isOverSizeLimit ? yellow(formatSize2(size)) : formatSize2(size),
  "asset.emitted": (emitted, { green, formatFlag }) => emitted ? green(formatFlag("emitted")) : void 0,
  "asset.comparedForEmit": (comparedForEmit, { yellow, formatFlag }) => comparedForEmit ? yellow(formatFlag("compared for emit")) : void 0,
  "asset.cached": (cached, { green, formatFlag }) => cached ? green(formatFlag("cached")) : void 0,
  "asset.isOverSizeLimit": (isOverSizeLimit, { yellow, formatFlag }) => isOverSizeLimit ? yellow == null ? void 0 : yellow(formatFlag("big")) : void 0,
  "asset.info.immutable": (immutable, { green, formatFlag }) => immutable ? green(formatFlag("immutable")) : void 0,
  "asset.info.javascriptModule": (javascriptModule, { formatFlag }) => javascriptModule ? formatFlag("javascript module") : void 0,
  "asset.info.sourceFilename": (sourceFilename, { formatFlag }) => sourceFilename ? formatFlag(
    sourceFilename === true ? "from source file" : `from: ${sourceFilename}`
  ) : void 0,
  "asset.info.copied": (copied, { green, formatFlag }) => copied ? green(formatFlag("copied")) : void 0,
  "asset.info.development": (development, { green, formatFlag }) => development ? green(formatFlag("dev")) : void 0,
  "asset.info.hotModuleReplacement": (hotModuleReplacement, { green, formatFlag }) => hotModuleReplacement ? green(formatFlag("hmr")) : void 0,
  "asset.separator!": () => "\n",
  "asset.filteredRelated": (filteredRelated, { asset: { related } }) => filteredRelated > 0 ? `${moreCount(related, filteredRelated)} related ${plural(
    filteredRelated,
    "asset",
    "assets"
  )}` : void 0,
  "asset.filteredChildren": (filteredChildren, { asset: { children } }) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(
    filteredChildren,
    "asset",
    "assets"
  )}` : void 0,
  assetChunk: (id, { formatChunkId }) => formatChunkId(id),
  assetChunkName: (name2) => name2,
  assetChunkIdHint: (name2) => name2,
  "module.type": (type) => type !== "module" ? type : void 0,
  "module.id": (id, { formatModuleId }) => isValidId(id) ? formatModuleId(id) : void 0,
  "module.name": (name2, { bold }) => {
    const [prefix, resource] = getModuleName(name2);
    return `${prefix || ""}${bold(resource || "")}`;
  },
  "module.identifier": (identifier) => void 0,
  "module.layer": (layer2, { formatLayer }) => layer2 ? formatLayer(layer2) : void 0,
  "module.sizes": printSizes,
  "module.chunks[]": (id, { formatChunkId }) => formatChunkId(id),
  "module.depth": (depth, { formatFlag }) => depth !== null ? formatFlag(`depth ${depth}`) : void 0,
  "module.cacheable": (cacheable, { formatFlag, red }) => cacheable === false ? red(formatFlag("not cacheable")) : void 0,
  "module.orphan": (orphan, { formatFlag, yellow }) => orphan ? yellow(formatFlag("orphan")) : void 0,
  "module.runtime": (runtime, { formatFlag, yellow }) => runtime ? yellow(formatFlag("runtime")) : void 0,
  "module.optional": (optional, { formatFlag, yellow }) => optional ? yellow(formatFlag("optional")) : void 0,
  "module.dependent": (dependent, { formatFlag, cyan }) => dependent ? cyan(formatFlag("dependent")) : void 0,
  "module.built": (built, { formatFlag, yellow }) => built ? yellow(formatFlag("built")) : void 0,
  "module.codeGenerated": (codeGenerated, { formatFlag, yellow }) => codeGenerated ? yellow(formatFlag("code generated")) : void 0,
  "module.buildTimeExecuted": (buildTimeExecuted, { formatFlag, green }) => buildTimeExecuted ? green(formatFlag("build time executed")) : void 0,
  "module.cached": (cached, { formatFlag, green }) => cached ? green(formatFlag("cached")) : void 0,
  "module.assets": (assets, { formatFlag, magenta }) => (assets == null ? void 0 : assets.length) ? magenta(
    formatFlag(
      `${assets.length} ${plural(assets.length, "asset", "assets")}`
    )
  ) : void 0,
  "module.warnings": (warnings, { formatFlag, yellow }) => warnings === true ? yellow(formatFlag("warnings")) : warnings ? yellow(
    formatFlag(`${warnings} ${plural(warnings, "warning", "warnings")}`)
  ) : void 0,
  "module.errors": (errors, { formatFlag, red }) => errors === true ? red(formatFlag("errors")) : errors ? red(formatFlag(`${errors} ${plural(errors, "error", "errors")}`)) : void 0,
  "module.providedExports": (providedExports, { formatFlag, cyan }) => {
    if (Array.isArray(providedExports)) {
      if (providedExports.length === 0) return cyan(formatFlag("no exports"));
      return cyan(formatFlag(`exports: ${providedExports.join(", ")}`));
    }
  },
  "module.usedExports": (usedExports, { formatFlag, cyan, module: module2 }) => {
    if (usedExports !== true) {
      if (usedExports === null) return cyan(formatFlag("used exports unknown"));
      if (usedExports === false) return cyan(formatFlag("module unused"));
      if (Array.isArray(usedExports)) {
        if (usedExports.length === 0)
          return cyan(formatFlag("no exports used"));
        const providedExportsCount = Array.isArray(module2.providedExports) ? module2.providedExports.length : null;
        if (providedExportsCount !== null && providedExportsCount === usedExports.length) {
          return cyan(formatFlag("all exports used"));
        }
        return cyan(
          formatFlag(`only some exports used: ${usedExports.join(", ")}`)
        );
      }
    }
  },
  "module.optimizationBailout[]": (optimizationBailout, { yellow }) => yellow(optimizationBailout),
  "module.issuerPath": (issuerPath, { module: module2 }) => module2.profile ? void 0 : "",
  "module.profile": (profile2) => void 0,
  "module.filteredModules": (filteredModules, { module: { modules } }) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} nested ${plural(
    filteredModules,
    "module",
    "modules"
  )}` : void 0,
  "module.filteredReasons": (filteredReasons, { module: { reasons } }) => filteredReasons > 0 ? `${moreCount(reasons, filteredReasons)} ${plural(
    filteredReasons,
    "reason",
    "reasons"
  )}` : void 0,
  "module.filteredChildren": (filteredChildren, { module: { children } }) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(
    filteredChildren,
    "module",
    "modules"
  )}` : void 0,
  "module.separator!": () => "\n",
  "moduleIssuer.id": (id, { formatModuleId }) => formatModuleId(id),
  "moduleIssuer.profile.total": (value, { formatTime }) => formatTime(value),
  "moduleReason.type": (type) => type,
  "moduleReason.userRequest": (userRequest, { cyan }) => cyan(getResourceName(userRequest)),
  "moduleReason.moduleId": (moduleId, { formatModuleId }) => isValidId(moduleId) ? formatModuleId(moduleId) : void 0,
  "moduleReason.module": (module2, { magenta }) => magenta(module2),
  "moduleReason.loc": (loc) => loc,
  "moduleReason.explanation": (explanation, { cyan }) => cyan(explanation),
  "moduleReason.active": (active, { formatFlag }) => active ? void 0 : formatFlag("inactive"),
  "moduleReason.resolvedModule": (module2, { magenta }) => magenta(module2),
  "moduleReason.filteredChildren": (filteredChildren, { moduleReason: { children } }) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(
    filteredChildren,
    "reason",
    "reasons"
  )}` : void 0,
  "module.profile.total": (value, { formatTime }) => formatTime(value),
  "module.profile.resolving": (value, { formatTime }) => `resolving: ${formatTime(value)}`,
  "module.profile.restoring": (value, { formatTime }) => `restoring: ${formatTime(value)}`,
  "module.profile.integration": (value, { formatTime }) => `integration: ${formatTime(value)}`,
  "module.profile.building": (value, { formatTime }) => `building: ${formatTime(value)}`,
  "module.profile.storing": (value, { formatTime }) => `storing: ${formatTime(value)}`,
  "module.profile.additionalResolving": (value, { formatTime }) => value ? `additional resolving: ${formatTime(value)}` : void 0,
  "module.profile.additionalIntegration": (value, { formatTime }) => value ? `additional integration: ${formatTime(value)}` : void 0,
  "chunkGroup.kind!": (_, { chunkGroupKind }) => chunkGroupKind,
  "chunkGroup.separator!": () => "\n",
  "chunkGroup.name": (name2, { bold }) => bold(name2),
  "chunkGroup.isOverSizeLimit": (isOverSizeLimit, { formatFlag, yellow }) => isOverSizeLimit ? yellow(formatFlag("big")) : void 0,
  "chunkGroup.assetsSize": (size, { formatSize: formatSize2 }) => size ? formatSize2(size) : void 0,
  "chunkGroup.auxiliaryAssetsSize": (size, { formatSize: formatSize2 }) => size ? `(${formatSize2(size)})` : void 0,
  "chunkGroup.filteredAssets": (n, { chunkGroup: { assets } }) => n > 0 ? `${moreCount(assets, n)} ${plural(n, "asset", "assets")}` : void 0,
  "chunkGroup.filteredAuxiliaryAssets": (n, { chunkGroup: { auxiliaryAssets } }) => n > 0 ? `${moreCount(auxiliaryAssets, n)} auxiliary ${plural(
    n,
    "asset",
    "assets"
  )}` : void 0,
  "chunkGroup.is!": () => "=",
  "chunkGroupAsset.name": (asset, { green }) => green(asset),
  "chunkGroupAsset.size": (size, { formatSize: formatSize2, chunkGroup }) => chunkGroup.assets && chunkGroup.assets.length > 1 || chunkGroup.auxiliaryAssets && chunkGroup.auxiliaryAssets.length > 0 ? formatSize2(size) : void 0,
  "chunkGroup.children": (children, context2, printer) => Array.isArray(children) ? void 0 : printer.print(
    context2.type,
    Object.keys(children).map((key) => ({
      type: key,
      children: children[key]
    })),
    context2
  ),
  "chunkGroupChildGroup.type": (type) => `${type}:`,
  "chunkGroupChild.assets[]": (file, { formatFilename }) => formatFilename(file),
  "chunkGroupChild.chunks[]": (id, { formatChunkId }) => formatChunkId(id),
  "chunkGroupChild.name": (name2) => name2 ? `(name: ${name2})` : void 0,
  "chunk.id": (id, { formatChunkId }) => formatChunkId(id),
  "chunk.files[]": (file, { formatFilename }) => formatFilename(file),
  "chunk.names[]": (name2) => name2,
  "chunk.idHints[]": (name2) => name2,
  "chunk.runtime[]": (name2) => name2,
  "chunk.sizes": (sizes, context2) => printSizes(sizes, context2),
  "chunk.parents[]": (parents, context2) => context2.formatChunkId(parents, "parent"),
  "chunk.siblings[]": (siblings, context2) => context2.formatChunkId(siblings, "sibling"),
  "chunk.children[]": (children, context2) => context2.formatChunkId(children, "child"),
  "chunk.childrenByOrder": (childrenByOrder, context2, printer) => {
    if (Array.isArray(childrenByOrder)) {
      return void 0;
    }
    const items = Object.keys(childrenByOrder).map((key) => ({
      type: key,
      children: childrenByOrder[key]
    }));
    items.sort((a, b) => compareIds(a.type, b.type));
    return Array.isArray(childrenByOrder) ? void 0 : printer.print(context2.type, items, context2);
  },
  "chunk.childrenByOrder[].type": (type) => `${type}:`,
  "chunk.childrenByOrder[].children[]": (id, { formatChunkId }) => isValidId(id) ? formatChunkId(id) : void 0,
  "chunk.entry": (entry2, { formatFlag, yellow }) => entry2 ? yellow(formatFlag("entry")) : void 0,
  "chunk.initial": (initial, { formatFlag, yellow }) => initial ? yellow(formatFlag("initial")) : void 0,
  "chunk.rendered": (rendered, { formatFlag, green }) => rendered ? green(formatFlag("rendered")) : void 0,
  "chunk.recorded": (recorded, { formatFlag, green }) => recorded ? green(formatFlag("recorded")) : void 0,
  "chunk.reason": (reason, { yellow }) => reason ? yellow(reason) : void 0,
  "chunk.filteredModules": (filteredModules, { chunk: { modules } }) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} chunk ${plural(
    filteredModules,
    "module",
    "modules"
  )}` : void 0,
  "chunk.separator!": () => "\n",
  "chunkOrigin.request": (request) => request,
  "chunkOrigin.moduleId": (moduleId, { formatModuleId }) => isValidId(moduleId) ? formatModuleId(moduleId) : void 0,
  "chunkOrigin.moduleName": (moduleName, { bold }) => bold(moduleName),
  "chunkOrigin.loc": (loc) => loc,
  // TODO: should align webpack error
  // "error.compilerPath": (compilerPath, { bold }) =>
  // 	compilerPath ? bold(`(${compilerPath})`) : undefined,
  // "error.chunkId": (chunkId, { formatChunkId }) =>
  // 	isValidId(chunkId) ? formatChunkId(chunkId) : undefined,
  // "error.chunkEntry": (chunkEntry, { formatFlag }) =>
  // 	chunkEntry ? formatFlag("entry") : undefined,
  // "error.chunkInitial": (chunkInitial, { formatFlag }) =>
  // 	chunkInitial ? formatFlag("initial") : undefined,
  "error.file": (file, { bold }) => bold(file),
  "error.moduleName": (moduleName, { bold }) => {
    return moduleName.includes("!") ? `${bold(moduleName.replace(/^(\s|\S)*!/, ""))} (${moduleName})` : `${bold(moduleName)}`;
  },
  "error.loc": (loc, { green }) => green(loc),
  "error.message": (message, { bold, formatError }) => message.includes("\x1B[") ? message : bold(formatError(message)),
  // "error.details": (details, { formatError }) => formatError(details),
  // "error.stack": stack => stack,
  "error.moduleTrace": (moduleTrace) => void 0,
  "error.separator!": () => "\n",
  "loggingEntry(error).loggingEntry.message": (message, { red }) => mapLines(message, (x) => `<e> ${red(x)}`),
  "loggingEntry(warn).loggingEntry.message": (message, { yellow }) => mapLines(message, (x) => `<w> ${yellow(x)}`),
  "loggingEntry(info).loggingEntry.message": (message, { green }) => mapLines(message, (x) => `<i> ${green(x)}`),
  "loggingEntry(log).loggingEntry.message": (message, { bold }) => mapLines(message, (x) => `    ${bold(x)}`),
  "loggingEntry(debug).loggingEntry.message": (message) => mapLines(message, (x) => `    ${x}`),
  "loggingEntry(trace).loggingEntry.message": (message) => mapLines(message, (x) => `    ${x}`),
  "loggingEntry(status).loggingEntry.message": (message, { magenta }) => mapLines(message, (x) => `<s> ${magenta(x)}`),
  "loggingEntry(profile).loggingEntry.message": (message, { magenta }) => mapLines(message, (x) => `<p> ${magenta(x)}`),
  "loggingEntry(profileEnd).loggingEntry.message": (message, { magenta }) => mapLines(message, (x) => `</p> ${magenta(x)}`),
  "loggingEntry(time).loggingEntry.message": (message, { magenta }) => mapLines(message, (x) => `<t> ${magenta(x)}`),
  "loggingEntry(cache).loggingEntry.message": (message, { magenta }) => mapLines(message, (x) => `<c> ${magenta(x)}`),
  "loggingEntry(group).loggingEntry.message": (message, { cyan }) => mapLines(message, (x) => `<-> ${cyan(x)}`),
  "loggingEntry(groupCollapsed).loggingEntry.message": (message, { cyan }) => mapLines(message, (x) => `<+> ${cyan(x)}`),
  "loggingEntry(clear).loggingEntry": () => "    -------",
  "loggingEntry(groupCollapsed).loggingEntry.children": () => "",
  "loggingEntry.trace[]": (trace) => trace ? mapLines(trace, (x) => `| ${x}`) : void 0,
  "moduleTraceItem.originName": (originName) => originName,
  loggingGroup: (loggingGroup) => loggingGroup.entries.length === 0 ? "" : void 0,
  "loggingGroup.debug": (flag, { red }) => flag ? red("DEBUG") : void 0,
  "loggingGroup.name": (name2, { bold }) => bold(`LOG from ${name2}`),
  "loggingGroup.separator!": () => "\n",
  "loggingGroup.filteredEntries": (filteredEntries) => filteredEntries > 0 ? `+ ${filteredEntries} hidden lines` : void 0,
  "moduleTraceDependency.loc": (loc) => loc
};
var ITEM_NAMES2 = {
  "compilation.assets[]": "asset",
  "compilation.modules[]": "module",
  "compilation.chunks[]": "chunk",
  "compilation.entrypoints[]": "chunkGroup",
  "compilation.namedChunkGroups[]": "chunkGroup",
  "compilation.errors[]": "error",
  "compilation.warnings[]": "error",
  "compilation.logging[]": "loggingGroup",
  "compilation.children[]": "compilation",
  "asset.related[]": "asset",
  "asset.children[]": "asset",
  "asset.chunks[]": "assetChunk",
  "asset.auxiliaryChunks[]": "assetChunk",
  "asset.chunkNames[]": "assetChunkName",
  "asset.chunkIdHints[]": "assetChunkIdHint",
  "asset.auxiliaryChunkNames[]": "assetChunkName",
  "asset.auxiliaryChunkIdHints[]": "assetChunkIdHint",
  "chunkGroup.assets[]": "chunkGroupAsset",
  "chunkGroup.auxiliaryAssets[]": "chunkGroupAsset",
  "chunkGroupChild.assets[]": "chunkGroupAsset",
  "chunkGroupChild.auxiliaryAssets[]": "chunkGroupAsset",
  "chunkGroup.children[]": "chunkGroupChildGroup",
  "chunkGroupChildGroup.children[]": "chunkGroupChild",
  "module.modules[]": "module",
  "module.children[]": "module",
  "module.reasons[]": "moduleReason",
  "moduleReason.children[]": "moduleReason",
  "module.issuerPath[]": "moduleIssuer",
  "chunk.origins[]": "chunkOrigin",
  "chunk.modules[]": "module",
  "loggingGroup.entries[]": (logEntry) => `loggingEntry(${logEntry.type}).loggingEntry`,
  "loggingEntry.children[]": (logEntry) => `loggingEntry(${logEntry.type}).loggingEntry`,
  "error.moduleTrace[]": "moduleTraceItem",
  "moduleTraceItem.dependencies[]": "moduleTraceDependency"
};
var ERROR_PREFERRED_ORDER = [
  "compilerPath",
  "chunkId",
  "chunkEntry",
  "chunkInitial",
  "file",
  "separator!",
  "moduleName",
  "loc",
  "separator!",
  "message",
  "separator!",
  "details",
  "separator!",
  "stack",
  "separator!",
  "missing",
  "separator!",
  "moduleTrace"
];
var PREFERRED_ORDERS = {
  compilation: [
    "name",
    "hash",
    "rspackVersion",
    "time",
    "builtAt",
    "env",
    "publicPath",
    "assets",
    "filteredAssets",
    "entrypoints",
    "namedChunkGroups",
    "chunks",
    "modules",
    "filteredModules",
    "children",
    "logging",
    "warnings",
    "warningsInChildren!",
    "filteredWarningDetailsCount",
    "errors",
    "errorsInChildren!",
    "filteredErrorDetailsCount",
    "summary!",
    "needAdditionalPass"
  ],
  asset: [
    "type",
    "name",
    "size",
    "chunks",
    "auxiliaryChunks",
    "emitted",
    "comparedForEmit",
    "cached",
    "info",
    "isOverSizeLimit",
    "chunkNames",
    "auxiliaryChunkNames",
    "chunkIdHints",
    "auxiliaryChunkIdHints",
    "related",
    "filteredRelated",
    "children",
    "filteredChildren"
  ],
  "asset.info": [
    "immutable",
    "sourceFilename",
    "copied",
    "javascriptModule",
    "development",
    "hotModuleReplacement"
  ],
  chunkGroup: [
    "kind!",
    "name",
    "isOverSizeLimit",
    "assetsSize",
    "auxiliaryAssetsSize",
    "is!",
    "assets",
    "filteredAssets",
    "auxiliaryAssets",
    "filteredAuxiliaryAssets",
    "separator!",
    "children"
  ],
  chunkGroupAsset: ["name", "size"],
  chunkGroupChildGroup: ["type", "children"],
  chunkGroupChild: ["assets", "chunks", "name"],
  module: [
    "type",
    "name",
    "identifier",
    "id",
    "layer",
    "sizes",
    "chunks",
    "depth",
    "cacheable",
    "orphan",
    "runtime",
    "optional",
    "dependent",
    "built",
    "codeGenerated",
    "cached",
    "assets",
    "failed",
    "warnings",
    "errors",
    "children",
    "filteredChildren",
    "providedExports",
    "usedExports",
    "optimizationBailout",
    "reasons",
    "filteredReasons",
    "issuerPath",
    "profile",
    "modules",
    "filteredModules"
  ],
  moduleReason: [
    "active",
    "type",
    "userRequest",
    "moduleId",
    "module",
    "resolvedModule",
    "loc",
    "explanation",
    "children",
    "filteredChildren"
  ],
  "module.profile": [
    "total",
    "separator!",
    "resolving",
    "restoring",
    "integration",
    "building",
    "storing",
    "additionalResolving",
    "additionalIntegration"
  ],
  chunk: [
    "id",
    "runtime",
    "files",
    "names",
    "idHints",
    "sizes",
    "parents",
    "siblings",
    "children",
    "childrenByOrder",
    "entry",
    "initial",
    "rendered",
    "recorded",
    "reason",
    "separator!",
    "origins",
    "separator!",
    "modules",
    "separator!",
    "filteredModules"
  ],
  chunkOrigin: ["request", "moduleId", "moduleName", "loc"],
  error: ERROR_PREFERRED_ORDER,
  warning: ERROR_PREFERRED_ORDER,
  "chunk.childrenByOrder[]": ["type", "children"],
  loggingGroup: [
    "debug",
    "name",
    "separator!",
    "entries",
    "separator!",
    "filteredEntries"
  ],
  loggingEntry: ["message", "trace", "children"]
};
var itemsJoinOneLine = (items) => items.filter(Boolean).join(" ");
var itemsJoinOneLineBrackets = (items) => items.length > 0 ? `(${items.filter(Boolean).join(" ")})` : void 0;
var itemsJoinMoreSpacing = (items) => items.filter(Boolean).join("\n\n");
var itemsJoinComma = (items) => items.filter(Boolean).join(", ");
var itemsJoinCommaBrackets = (items) => items.length > 0 ? `(${items.filter(Boolean).join(", ")})` : void 0;
var itemsJoinCommaBracketsWithName = (name2) => (items) => items.length > 0 ? `(${name2}: ${items.filter(Boolean).join(", ")})` : void 0;
var SIMPLE_ITEMS_JOINER = {
  "chunk.parents": itemsJoinOneLine,
  "chunk.siblings": itemsJoinOneLine,
  "chunk.children": itemsJoinOneLine,
  "chunk.names": itemsJoinCommaBrackets,
  "chunk.idHints": itemsJoinCommaBracketsWithName("id hint"),
  "chunk.runtime": itemsJoinCommaBracketsWithName("runtime"),
  "chunk.files": itemsJoinComma,
  "chunk.childrenByOrder": itemsJoinOneLine,
  "chunk.childrenByOrder[].children": itemsJoinOneLine,
  "chunkGroup.assets": itemsJoinOneLine,
  "chunkGroup.auxiliaryAssets": itemsJoinOneLineBrackets,
  "chunkGroupChildGroup.children": itemsJoinComma,
  "chunkGroupChild.assets": itemsJoinOneLine,
  "chunkGroupChild.auxiliaryAssets": itemsJoinOneLineBrackets,
  "asset.chunks": itemsJoinComma,
  "asset.auxiliaryChunks": itemsJoinCommaBrackets,
  "asset.chunkNames": itemsJoinCommaBracketsWithName("name"),
  "asset.auxiliaryChunkNames": itemsJoinCommaBracketsWithName("auxiliary name"),
  "asset.chunkIdHints": itemsJoinCommaBracketsWithName("id hint"),
  "asset.auxiliaryChunkIdHints": itemsJoinCommaBracketsWithName("auxiliary id hint"),
  "module.chunks": itemsJoinOneLine,
  "module.issuerPath": (items) => items.filter(Boolean).map((item) => `${item} ->`).join(" "),
  "compilation.errors": itemsJoinMoreSpacing,
  "compilation.warnings": itemsJoinMoreSpacing,
  "compilation.logging": itemsJoinMoreSpacing,
  "compilation.children": (items) => indent2(itemsJoinMoreSpacing(items), "  "),
  "moduleTraceItem.dependencies": itemsJoinOneLine,
  "loggingEntry.children": (items) => indent2(items.filter(Boolean).join("\n"), "  ", false)
};
var joinOneLine = (items) => items.map((item) => item.content).filter(Boolean).join(" ");
var joinInBrackets = (items) => {
  const res = [];
  let mode2 = 0;
  for (const item of items) {
    if (item.element === "separator!") {
      switch (mode2) {
        case 0:
        case 1:
          mode2 += 2;
          break;
        case 4:
          res.push(")");
          mode2 = 3;
          break;
      }
    }
    if (!item.content) continue;
    switch (mode2) {
      case 0:
        mode2 = 1;
        break;
      case 1:
        res.push(" ");
        break;
      case 2:
        res.push("(");
        mode2 = 4;
        break;
      case 3:
        res.push(" (");
        mode2 = 4;
        break;
      case 4:
        res.push(", ");
        break;
    }
    res.push(item.content);
  }
  if (mode2 === 4) res.push(")");
  return res.join("");
};
var indent2 = (str, prefix, noPrefixInFirstLine) => {
  const rem = str.replace(/\n([^\n])/g, `
${prefix}$1`);
  if (noPrefixInFirstLine) return rem;
  const ind = str[0] === "\n" ? "" : prefix;
  return ind + rem;
};
var joinExplicitNewLine = (items, indenter) => {
  let firstInLine = true;
  let first = true;
  return items.map((item) => {
    if (!item || !item.content) return;
    let content = indent2(item.content, first ? "" : indenter, !firstInLine);
    if (firstInLine) {
      content = content.replace(/^\n+/, "");
    }
    if (!content) return;
    first = false;
    const noJoiner = firstInLine || content.startsWith("\n");
    firstInLine = content.endsWith("\n");
    return noJoiner ? content : ` ${content}`;
  }).filter(Boolean).join("").trim();
};
var joinError = (error) => (items, { red, yellow }) => `${error ? red("ERROR") : yellow("WARNING")} in ${joinExplicitNewLine(
  items,
  ""
)}`;
var SIMPLE_ELEMENT_JOINERS = {
  compilation: (items) => {
    const result2 = [];
    let lastNeedMore = false;
    for (const item of items) {
      if (!item.content) continue;
      const needMoreSpace = [
        "warnings",
        "filteredWarningDetailsCount",
        "errors",
        "filteredErrorDetailsCount",
        "logging"
      ].includes(item.element);
      if (result2.length !== 0) {
        result2.push(needMoreSpace || lastNeedMore ? "\n\n" : "\n");
      }
      result2.push(item.content);
      lastNeedMore = needMoreSpace;
    }
    if (lastNeedMore) result2.push("\n");
    return result2.join("");
  },
  asset: (items) => joinExplicitNewLine(
    items.map((item) => {
      if ((item.element === "related" || item.element === "children") && item.content) {
        return {
          ...item,
          content: `
${item.content}
`
        };
      }
      return item;
    }),
    "  "
  ),
  "asset.info": joinOneLine,
  module: (items, { module: module2 }) => {
    let hasName = false;
    return joinExplicitNewLine(
      items.map((item) => {
        switch (item.element) {
          case "id":
            if (module2 && module2.id === module2.name) {
              if (hasName) return false;
              if (item.content) hasName = true;
            }
            break;
          case "name":
            if (hasName) return false;
            if (item.content) hasName = true;
            break;
          case "providedExports":
          case "usedExports":
          case "optimizationBailout":
          case "reasons":
          case "issuerPath":
          case "profile":
          case "children":
          case "modules":
            if (item.content) {
              return {
                ...item,
                content: `
${item.content}
`
              };
            }
            break;
        }
        return item;
      }),
      "  "
    );
  },
  chunk: (items) => {
    let hasEntry = false;
    return `chunk ${joinExplicitNewLine(
      items.filter((item) => {
        switch (item.element) {
          case "entry":
            if (item.content) hasEntry = true;
            break;
          case "initial":
            if (hasEntry) return false;
            break;
        }
        return true;
      }),
      "  "
    )}`;
  },
  "chunk.childrenByOrder[]": (items) => `(${joinOneLine(items)})`,
  chunkGroup: (items) => joinExplicitNewLine(items, "  "),
  chunkGroupAsset: joinOneLine,
  chunkGroupChildGroup: joinOneLine,
  chunkGroupChild: joinOneLine,
  moduleReason: (items, { moduleReason }) => {
    let hasName = false;
    return joinExplicitNewLine(
      items.map((item) => {
        switch (item.element) {
          case "moduleId":
            if (moduleReason && moduleReason.moduleId === moduleReason.module && item.content)
              hasName = true;
            break;
          case "module":
            if (hasName) return false;
            break;
          case "resolvedModule":
            if (moduleReason && moduleReason.module === moduleReason.resolvedModule)
              return false;
            break;
          case "children":
            if (item.content) {
              return {
                ...item,
                content: `
${item.content}
`
              };
            }
            break;
        }
        return item;
      }),
      "  "
    );
  },
  "module.profile": joinInBrackets,
  moduleIssuer: joinOneLine,
  chunkOrigin: (items) => `> ${joinOneLine(items)}`,
  "errors[].error": joinError(true),
  "warnings[].error": joinError(false),
  loggingGroup: (items) => joinExplicitNewLine(items, "").trimEnd(),
  moduleTraceItem: (items) => ` @ ${joinOneLine(items)}`,
  moduleTraceDependency: joinOneLine
};
var AVAILABLE_COLORS = {
  bold: "\x1B[1m",
  yellow: "\x1B[1m\x1B[33m",
  red: "\x1B[1m\x1B[31m",
  green: "\x1B[1m\x1B[32m",
  cyan: "\x1B[1m\x1B[36m",
  magenta: "\x1B[1m\x1B[35m"
};
var AVAILABLE_FORMATS = {
  formatChunkId: (id, { yellow }, direction) => {
    switch (direction) {
      case "parent":
        return `<{${yellow(id)}}>`;
      case "sibling":
        return `={${yellow(id)}}=`;
      case "child":
        return `>{${yellow(id)}}<`;
      default:
        return `{${yellow(id)}}`;
    }
  },
  formatModuleId: (id) => `[${id}]`,
  formatFilename: (filename2, { green, yellow }, oversize) => (oversize ? yellow : green)(filename2),
  formatFlag: (flag) => `[${flag}]`,
  formatLayer: (layer2) => `(in ${layer2})`,
  formatSize,
  formatDateTime: (dateTime, { bold }) => {
    const d = new Date(dateTime);
    const x = twoDigit;
    const date = `${d.getFullYear()}-${x(d.getMonth() + 1)}-${x(d.getDate())}`;
    const time = `${x(d.getHours())}:${x(d.getMinutes())}:${x(d.getSeconds())}`;
    return `${date} ${bold(time)}`;
  },
  formatTime: (time, { timeReference, bold, green, yellow, red }, boldQuantity) => {
    let unit = " ms";
    if (timeReference && time !== timeReference) {
      const times = [
        timeReference / 2,
        timeReference / 4,
        timeReference / 8,
        timeReference / 16
      ];
      if (time < times[3]) return `${time}${unit}`;
      if (time < times[2]) return bold(`${time}${unit}`);
      if (time < times[1]) return green(`${time}${unit}`);
      if (time < times[0]) return yellow(`${time}${unit}`);
      return red(`${time}${unit}`);
    }
    let timeStr = time.toString();
    if (time > 1e3) {
      timeStr = `${(time / 1e3).toFixed(2)}`;
      unit = " s";
    }
    return `${boldQuantity ? bold(timeStr) : timeStr}${unit}`;
  },
  formatError: (msg, { green, yellow, red }) => {
    let message = msg;
    if (message.includes("\x1B[")) return message;
    const highlights = [
      { regExp: /(Did you mean .+)/g, format: green },
      {
        regExp: /(Set 'mode' option to 'development' or 'production')/g,
        format: green
      },
      { regExp: /(\(module has no exports\))/g, format: red },
      { regExp: /\(possible exports: (.+)\)/g, format: green },
      { regExp: /(?:^|\n)(.* doesn't exist)/g, format: red },
      { regExp: /('\w+' option has not been set)/g, format: red },
      {
        regExp: /(Emitted value instead of an instance of Error)/g,
        format: yellow
      },
      { regExp: /(Used? .+ instead)/gi, format: yellow },
      { regExp: /\b(deprecated|must|required)\b/g, format: yellow },
      {
        regExp: /\b(BREAKING CHANGE)\b/gi,
        format: red
      },
      {
        regExp: /\b(error|failed|unexpected|invalid|not found|not supported|not available|not possible|not implemented|doesn't support|conflict|conflicting|not existing|duplicate)\b/gi,
        format: red
      }
    ];
    for (const { regExp, format: format3 } of highlights) {
      message = message.replace(regExp, (match, content) => {
        return match.replace(content, format3(content));
      });
    }
    return message;
  }
};
var RESULT_MODIFIER = {
  "module.modules": (result2) => {
    return indent2(result2, "| ");
  }
};
var createOrder = (array, preferredOrder) => {
  const originalArray = array.slice();
  const set = new Set(array);
  const usedSet = /* @__PURE__ */ new Set();
  array.length = 0;
  for (const element of preferredOrder) {
    if (element.endsWith("!") || set.has(element)) {
      array.push(element);
      usedSet.add(element);
    }
  }
  for (const element of originalArray) {
    if (!usedSet.has(element)) {
      array.push(element);
    }
  }
  return array;
};
var DefaultStatsPrinterPlugin = class {
  apply(compiler) {
    compiler.hooks.compilation.tap("DefaultStatsPrinterPlugin", (compilation) => {
      compilation.hooks.statsPrinter.tap(
        "DefaultStatsPrinterPlugin",
        (stats, options) => {
          stats.hooks.print.for("compilation").tap(
            "DefaultStatsPrinterPlugin",
            // @ts-expect-error
            (compilation2, context2) => {
              for (const color of Object.keys(AVAILABLE_COLORS)) {
                let start;
                if (options.colors) {
                  if (typeof options.colors === "object" && typeof options.colors[color] === "string") {
                    start = options.colors[color];
                  } else {
                    start = AVAILABLE_COLORS[color];
                  }
                }
                if (start) {
                  context2[color] = (str) => `${start}${typeof str === "string" ? str.replace(
                    /((\u001b\[39m|\u001b\[22m|\u001b\[0m)+)/g,
                    `$1${start}`
                  ) : str}\x1B[39m\x1B[22m`;
                } else {
                  context2[color] = (str) => str;
                }
              }
              for (const format3 of Object.keys(AVAILABLE_FORMATS)) {
                context2[format3] = (content, ...args) => (
                  // @ts-ignore
                  AVAILABLE_FORMATS[format3](content, context2, ...args)
                );
              }
              context2.timeReference = compilation2.time;
            }
          );
          for (const key of Object.keys(SIMPLE_PRINTERS)) {
            stats.hooks.print.for(key).tap(
              "DefaultStatsPrinterPlugin",
              (obj, ctx) => SIMPLE_PRINTERS[key](
                obj,
                ctx,
                stats
              )
            );
          }
          for (const key of Object.keys(PREFERRED_ORDERS)) {
            const preferredOrder = PREFERRED_ORDERS[key];
            stats.hooks.sortElements.for(key).tap("DefaultStatsPrinterPlugin", (elements) => {
              createOrder(elements, preferredOrder);
            });
          }
          for (const key of Object.keys(ITEM_NAMES2)) {
            const itemName = ITEM_NAMES2[key];
            stats.hooks.getItemName.for(key).tap(
              "DefaultStatsPrinterPlugin",
              typeof itemName === "string" ? () => itemName : itemName
            );
          }
          for (const key of Object.keys(SIMPLE_ITEMS_JOINER)) {
            const joiner = SIMPLE_ITEMS_JOINER[key];
            stats.hooks.printItems.for(key).tap("DefaultStatsPrinterPlugin", joiner);
          }
          for (const key of Object.keys(SIMPLE_ELEMENT_JOINERS)) {
            const joiner = SIMPLE_ELEMENT_JOINERS[key];
            stats.hooks.printElements.for(key).tap("DefaultStatsPrinterPlugin", joiner);
          }
          for (const key of Object.keys(RESULT_MODIFIER)) {
            const modifier = RESULT_MODIFIER[key];
            stats.hooks.result.for(key).tap("DefaultStatsPrinterPlugin", modifier);
          }
        }
      );
    });
  }
};

// src/rspackOptionsApply.ts
var RspackOptionsApply = class {
  process(options, compiler) {
    (0, import_node_assert8.default)(
      options.output.path,
      "options.output.path should have value after `applyRspackOptionsDefaults`"
    );
    compiler.outputPath = options.output.path;
    compiler.name = options.name;
    compiler.outputFileSystem = import_graceful_fs.default;
    if (options.externals) {
      (0, import_node_assert8.default)(
        options.externalsType,
        "options.externalsType should have value after `applyRspackOptionsDefaults`"
      );
      new ExternalsPlugin(options.externalsType, options.externals).apply(
        compiler
      );
    }
    if (options.externalsPresets.node) {
      new NodeTargetPlugin().apply(compiler);
    }
    if (options.externalsPresets.electronMain) {
      new ElectronTargetPlugin("main").apply(compiler);
    }
    if (options.externalsPresets.electronPreload) {
      new ElectronTargetPlugin("preload").apply(compiler);
    }
    if (options.externalsPresets.electronRenderer) {
      new ElectronTargetPlugin("renderer").apply(compiler);
    }
    if (options.externalsPresets.electron && !options.externalsPresets.electronMain && !options.externalsPresets.electronPreload && !options.externalsPresets.electronRenderer) {
      new ElectronTargetPlugin().apply(compiler);
    }
    if (options.externalsPresets.nwjs) {
      new ExternalsPlugin("node-commonjs", "nw.gui").apply(compiler);
    }
    if (options.externalsPresets.web || options.externalsPresets.webAsync || options.externalsPresets.node && options.experiments.css) {
      new HttpExternalsRspackPlugin(
        !!options.experiments.css,
        !!options.externalsPresets.webAsync
      ).apply(compiler);
    }
    new ChunkPrefetchPreloadPlugin().apply(compiler);
    if (typeof options.output.chunkFormat === "string") {
      switch (options.output.chunkFormat) {
        case "array-push": {
          new ArrayPushCallbackChunkFormatPlugin().apply(compiler);
          break;
        }
        case "commonjs": {
          new CommonJsChunkFormatPlugin().apply(compiler);
          break;
        }
        case "module": {
          new ModuleChunkFormatPlugin().apply(compiler);
          break;
        }
        default:
          throw new Error(
            `Unsupported chunk format '${options.output.chunkFormat}'.`
          );
      }
    }
    if (options.output.enabledChunkLoadingTypes && options.output.enabledChunkLoadingTypes.length > 0) {
      for (const type of options.output.enabledChunkLoadingTypes) {
        new EnableChunkLoadingPlugin(type).apply(compiler);
      }
    }
    if (options.output.enabledWasmLoadingTypes && options.output.enabledWasmLoadingTypes.length > 0) {
      for (const type of options.output.enabledWasmLoadingTypes) {
        new EnableWasmLoadingPlugin(type).apply(compiler);
      }
    }
    const runtimeChunk = options.optimization.runtimeChunk;
    if (runtimeChunk) {
      new RuntimeChunkPlugin(runtimeChunk).apply(compiler);
    }
    if (!options.optimization.emitOnErrors) {
      new NoEmitOnErrorsPlugin().apply(compiler);
    }
    if (options.devtool) {
      if (options.devtool.includes("source-map")) {
        const hidden = options.devtool.includes("hidden");
        const inline = options.devtool.includes("inline");
        const evalWrapped = options.devtool.includes("eval");
        const cheap = options.devtool.includes("cheap");
        const moduleMaps = options.devtool.includes("module");
        const noSources = options.devtool.includes("nosources");
        const Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;
        new Plugin({
          filename: inline ? null : options.output.sourceMapFilename,
          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
          fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
          append: hidden ? false : void 0,
          module: moduleMaps ? true : !cheap,
          columns: !cheap,
          noSources,
          namespace: options.output.devtoolNamespace
        }).apply(compiler);
      } else if (options.devtool.includes("eval")) {
        new EvalDevToolModulePlugin({
          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
          namespace: options.output.devtoolNamespace
        }).apply(compiler);
      }
    }
    new JavascriptModulesPlugin().apply(compiler);
    new JsonModulesPlugin().apply(compiler);
    new AssetModulesPlugin().apply(compiler);
    if (options.experiments.asyncWebAssembly) {
      new AsyncWebAssemblyModulesPlugin().apply(compiler);
    }
    if (options.experiments.css) {
      new CssModulesPlugin().apply(compiler);
    }
    new EntryOptionPlugin_default().apply(compiler);
    assertNotNill(options.context);
    compiler.hooks.entryOption.call(options.context, options.entry);
    new RuntimePlugin().apply(compiler);
    if (options.experiments.rspackFuture.bundlerInfo) {
      new BundlerInfoRspackPlugin(
        options.experiments.rspackFuture.bundlerInfo
      ).apply(compiler);
    }
    new InferAsyncModulesPlugin().apply(compiler);
    new APIPlugin().apply(compiler);
    new DataUriPlugin().apply(compiler);
    new FileUriPlugin().apply(compiler);
    new EnsureChunkConditionsPlugin().apply(compiler);
    if (options.optimization.mergeDuplicateChunks) {
      new MergeDuplicateChunksPlugin().apply(compiler);
    }
    if (options.optimization.sideEffects) {
      new SideEffectsFlagPlugin(
        /* options.optimization.sideEffects === true */
      ).apply(
        compiler
      );
    }
    if (options.optimization.providedExports) {
      new FlagDependencyExportsPlugin().apply(compiler);
    }
    if (options.optimization.usedExports) {
      new FlagDependencyUsagePlugin(
        options.optimization.usedExports === "global"
      ).apply(compiler);
    }
    if (options.optimization.concatenateModules) {
      new ModuleConcatenationPlugin().apply(compiler);
    }
    if (options.optimization.mangleExports) {
      new MangleExportsPlugin(
        options.optimization.mangleExports !== "size"
      ).apply(compiler);
    }
    if (options.experiments.lazyCompilation) {
      const lazyOptions = options.experiments.lazyCompilation;
      new LazyCompilationPlugin(
        // this is only for test
        // @ts-expect-error cacheable is hide
        lazyOptions.cacheable ?? true,
        lazyOptions.entries ?? true,
        lazyOptions.imports ?? true,
        typeof lazyOptions.test === "function" ? (jsModule) => lazyOptions.test.call(
          lazyOptions,
          new Module(jsModule)
        ) : lazyOptions.test ? {
          source: lazyOptions.test.source,
          flags: lazyOptions.test.flags
        } : void 0,
        lazyOptions.backend
      ).apply(compiler);
    }
    if (options.output.enabledLibraryTypes && options.output.enabledLibraryTypes.length > 0) {
      for (const type of options.output.enabledLibraryTypes) {
        new EnableLibraryPlugin(type).apply(compiler);
      }
    }
    if (options.optimization.splitChunks) {
      new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
    }
    if (options.optimization.removeEmptyChunks) {
      new RemoveEmptyChunksPlugin().apply(compiler);
    }
    if (options.optimization.realContentHash) {
      new RealContentHashPlugin().apply(compiler);
    }
    const moduleIds = options.optimization.moduleIds;
    if (moduleIds) {
      switch (moduleIds) {
        case "named": {
          new NamedModuleIdsPlugin().apply(compiler);
          break;
        }
        case "natural": {
          new NaturalModuleIdsPlugin().apply(compiler);
          break;
        }
        case "deterministic": {
          new DeterministicModuleIdsPlugin().apply(compiler);
          break;
        }
        default:
          throw new Error(`moduleIds: ${moduleIds} is not implemented`);
      }
    }
    const chunkIds = options.optimization.chunkIds;
    if (chunkIds) {
      switch (chunkIds) {
        case "natural": {
          new NaturalChunkIdsPlugin().apply(compiler);
        }
        case "named": {
          new NamedChunkIdsPlugin().apply(compiler);
          break;
        }
        case "deterministic": {
          new DeterministicChunkIdsPlugin().apply(compiler);
          break;
        }
        default:
          throw new Error(`chunkIds: ${chunkIds} is not implemented`);
      }
    }
    if (options.optimization.nodeEnv) {
      new DefinePlugin({
        "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
      }).apply(compiler);
    }
    const { minimize, minimizer } = options.optimization;
    if (minimize && minimizer) {
      for (const item of minimizer) {
        if (typeof item === "function") {
          item.call(compiler, compiler);
        } else if (item !== "..." && item) {
          item.apply(compiler);
        }
      }
    }
    if (options.performance) {
      new SizeLimitsPlugin(options.performance).apply(compiler);
    }
    new WarnCaseSensitiveModulesPlugin().apply(compiler);
    if (options.cache) {
      new MemoryCachePlugin().apply(compiler);
    }
    new WorkerPlugin(
      options.output.workerChunkLoading,
      options.output.workerWasmLoading,
      options.output.module,
      options.output.workerPublicPath
    ).apply(compiler);
    new DefaultStatsFactoryPlugin().apply(compiler);
    new DefaultStatsPresetPlugin().apply(compiler);
    new DefaultStatsPrinterPlugin().apply(compiler);
    if (options.ignoreWarnings && options.ignoreWarnings.length > 0) {
      new IgnoreWarningsPlugin_default(options.ignoreWarnings).apply(compiler);
    }
    compiler.hooks.afterPlugins.call(compiler);
    if (!compiler.inputFileSystem) {
      throw new Error("No input filesystem provided");
    }
    compiler.hooks.afterResolvers.call(compiler);
  }
};

// src/lib/EnvironmentPlugin.ts
var EnvironmentPlugin = class {
  constructor(...keys) {
    if (keys.length === 1 && Array.isArray(keys[0])) {
      this.keys = keys[0];
      this.defaultValues = {};
    } else if (keys.length === 1 && keys[0] && typeof keys[0] === "object") {
      this.keys = Object.keys(keys[0]);
      this.defaultValues = keys[0];
    } else {
      this.keys = keys;
      this.defaultValues = {};
    }
  }
  /**
   * Apply the plugin
   * @param compiler the compiler instance
   * @returns
   */
  apply(compiler) {
    const definitions = {};
    for (const key of this.keys) {
      const value = process.env[key] !== void 0 ? process.env[key] : this.defaultValues[key];
      if (value === void 0) {
        compiler.hooks.thisCompilation.tap("EnvironmentPlugin", (compilation) => {
          const error = new WebpackError_default(
            `EnvironmentPlugin - ${key} environment variable is undefined.

You can pass an object with default values to suppress this warning.
See https://rspack.dev/plugins/webpack/environment-plugin for example.`
          );
          error.name = "EnvVariableNotDefinedError";
          compilation.errors.push(error);
        });
      }
      definitions[`process.env.${key}`] = value === void 0 ? "undefined" : JSON.stringify(value);
    }
    new DefinePlugin(definitions).apply(compiler);
  }
};

// src/lib/LoaderOptionsPlugin.ts
var LoaderOptionsPlugin = class {
  /**
   * @param options options object
   */
  constructor(options = {}) {
    if (!options.test) {
      options.test = {
        test: () => true
      };
    }
    this.options = options;
  }
  /**
   * Apply the plugin
   * @param compiler the compiler instance
   * @returns
   */
  apply(compiler) {
    const options = this.options;
    compiler.hooks.compilation.tap("LoaderOptionsPlugin", (compilation) => {
      NormalModule.getCompilationHooks(compilation).loader.tap(
        "LoaderOptionsPlugin",
        (context2) => {
          const resource = context2.resourcePath;
          if (!resource) return;
          if (matchObject(options, resource)) {
            for (const key of Object.keys(options)) {
              if (key === "include" || key === "exclude" || key === "test") {
                continue;
              }
              context2[key] = options[key];
            }
          }
        }
      );
    });
  }
};

// src/lib/LoaderTargetPlugin.ts
var LoaderTargetPlugin = class {
  /**
   * @param target the target
   */
  constructor(target2) {
    this.target = target2;
  }
  /**
   * Apply the plugin
   * @param compiler the compiler instance
   * @returns
   */
  apply(compiler) {
    compiler.hooks.compilation.tap("LoaderTargetPlugin", (compilation) => {
      NormalModule_default.getCompilationHooks(compilation).loader.tap(
        "LoaderTargetPlugin",
        (loaderContext) => {
          loaderContext.target = this.target;
        }
      );
    });
  }
};

// src/lib/NormalModuleReplacementPlugin.ts
var NodePath = __toESM(require("path"));
var NormalModuleReplacementPlugin = class {
  /**
   * Create an instance of the plugin
   * @param resourceRegExp the resource matcher
   * @param newResource the resource replacement
   */
  constructor(resourceRegExp, newResource) {
    this.resourceRegExp = resourceRegExp;
    this.newResource = newResource;
  }
  /**
   * Apply the plugin
   * @param compiler the compiler instance
   * @returns
   */
  apply(compiler) {
    const { resourceRegExp, newResource } = this;
    compiler.hooks.normalModuleFactory.tap(
      "NormalModuleReplacementPlugin",
      (nmf) => {
        nmf.hooks.beforeResolve.tap("NormalModuleReplacementPlugin", (result2) => {
          if (resourceRegExp.test(result2.request)) {
            if (typeof newResource === "function") {
              newResource(result2);
            } else {
              result2.request = newResource;
            }
          }
        });
        nmf.hooks.afterResolve.tap("NormalModuleReplacementPlugin", (result2) => {
          const createData = result2.createData || {};
          if (resourceRegExp.test(createData.resource || "")) {
            if (typeof newResource === "function") {
              newResource(result2);
            } else {
              if (NodePath.posix.isAbsolute(newResource) || NodePath.win32.isAbsolute(newResource)) {
                createData.resource = newResource;
              } else {
                createData.resource = NodePath.join(
                  NodePath.dirname(createData.resource || ""),
                  newResource
                );
              }
            }
          }
        });
      }
    );
  }
};

// src/node/NodeEnvironmentPlugin.ts
var import_CachedInputFileSystem = __toESM(require_CachedInputFileSystem());
var import_graceful_fs2 = __toESM(require("../compiled/graceful-fs/index.js"));

// src/logging/createConsoleLogger.ts
var filterToFunction = (item) => {
  if (typeof item === "string") {
    const regExp = new RegExp(
      `[\\\\/]${item.replace(
        // eslint-disable-next-line no-useless-escape
        /[-[\]{}()*+?.\\^$|]/g,
        "\\$&"
      )}([\\\\/]|$|!|\\?)`
    );
    return (ident) => regExp.test(ident);
  }
  if (item && typeof item === "object" && typeof item.test === "function") {
    return (ident) => item.test(ident);
  }
  if (typeof item === "function") {
    return item;
  }
  if (typeof item === "boolean") {
    return () => item;
  }
};
var LogLevel = {
  none: 6,
  false: 6,
  error: 5,
  warn: 4,
  info: 3,
  log: 2,
  true: 2,
  verbose: 1
};
var createConsoleLogger = ({
  level = "info",
  debug = false,
  console: console2
}) => {
  const debugFilters = typeof debug === "boolean" ? [() => debug] : [].concat(debug).map(filterToFunction);
  const loglevel = LogLevel[`${level}`] || 0;
  const logger = (name2, type, args) => {
    const labeledArgs = () => {
      if (Array.isArray(args)) {
        if (args.length > 0 && typeof args[0] === "string") {
          return [`[${name2}] ${args[0]}`, ...args.slice(1)];
        }
        return [`[${name2}]`, ...args];
      }
      return [];
    };
    const debug2 = debugFilters.some((f) => f(name2));
    switch (type) {
      case LogType.debug:
        if (!debug2) return;
        if (typeof console2.debug === "function") {
          console2.debug(...labeledArgs());
        } else {
          console2.log(...labeledArgs());
        }
        break;
      case LogType.log:
        if (!debug2 && loglevel > LogLevel.log) return;
        console2.log(...labeledArgs());
        break;
      case LogType.info:
        if (!debug2 && loglevel > LogLevel.info) return;
        console2.info(...labeledArgs());
        break;
      case LogType.warn:
        if (!debug2 && loglevel > LogLevel.warn) return;
        console2.warn(...labeledArgs());
        break;
      case LogType.error:
        if (!debug2 && loglevel > LogLevel.error) return;
        console2.error(...labeledArgs());
        break;
      case LogType.trace:
        if (!debug2) return;
        console2.trace();
        break;
      case LogType.groupCollapsed:
        if (!debug2 && loglevel > LogLevel.log) return;
        if (!debug2 && loglevel > LogLevel.verbose) {
          if (typeof console2.groupCollapsed === "function") {
            console2.groupCollapsed(...labeledArgs());
          } else {
            console2.log(...labeledArgs());
          }
          break;
        }
      // falls through
      case LogType.group:
        if (!debug2 && loglevel > LogLevel.log) return;
        if (typeof console2.group === "function") {
          console2.group(...labeledArgs());
        } else {
          console2.log(...labeledArgs());
        }
        break;
      case LogType.groupEnd:
        if (!debug2 && loglevel > LogLevel.log) return;
        if (typeof console2.groupEnd === "function") {
          console2.groupEnd();
        }
        break;
      case LogType.time: {
        if (!debug2 && loglevel > LogLevel.log) return;
        const ms = args[1] * 1e3 + args[2] / 1e6;
        const msg = `[${name2}] ${args[0]}: ${ms} ms`;
        if (typeof console2.logTime === "function") {
          console2.logTime(msg);
        } else {
          console2.log(msg);
        }
        break;
      }
      case LogType.profile:
        if (typeof console2.profile === "function") {
          console2.profile(...labeledArgs());
        }
        break;
      case LogType.profileEnd:
        if (typeof console2.profileEnd === "function") {
          console2.profileEnd(...labeledArgs());
        }
        break;
      case LogType.clear:
        if (!debug2 && loglevel > LogLevel.log) return;
        if (typeof console2.clear === "function") {
          console2.clear();
        }
        break;
      case LogType.status:
        if (!debug2 && loglevel > LogLevel.info) return;
        if (typeof console2.status === "function") {
          if (args.length === 0) {
            console2.status();
          } else {
            console2.status(...labeledArgs());
          }
        } else {
          if (args.length !== 0) {
            console2.info(...labeledArgs());
          }
        }
        break;
      default:
        throw new Error(`Unexpected LogType ${type}`);
    }
  };
  return logger;
};

// src/node/NodeWatchFileSystem.ts
var import_node_util5 = __toESM(require("util"));
var import_watchpack = __toESM(require("../compiled/watchpack/index.js"));
var NodeWatchFileSystem = class {
  constructor(inputFileSystem) {
    this.inputFileSystem = inputFileSystem;
    this.watcherOptions = {
      aggregateTimeout: 0
    };
    this.watcher = new import_watchpack.default(this.watcherOptions);
  }
  watch(files, directories, missing, startTime, options, callback, callbackUndelayed) {
    if (!files || typeof files[Symbol.iterator] !== "function") {
      throw new Error("Invalid arguments: 'files'");
    }
    if (!directories || typeof directories[Symbol.iterator] !== "function") {
      throw new Error("Invalid arguments: 'directories'");
    }
    if (!missing || typeof missing[Symbol.iterator] !== "function") {
      throw new Error("Invalid arguments: 'missing'");
    }
    if (typeof callback !== "function") {
      throw new Error("Invalid arguments: 'callback'");
    }
    if (typeof startTime !== "number" && startTime) {
      throw new Error("Invalid arguments: 'startTime'");
    }
    if (typeof options !== "object") {
      throw new Error("Invalid arguments: 'options'");
    }
    if (typeof callbackUndelayed !== "function" && callbackUndelayed) {
      throw new Error("Invalid arguments: 'callbackUndelayed'");
    }
    const oldWatcher = this.watcher;
    this.watcher = new import_watchpack.default(options);
    if (callbackUndelayed) {
      this.watcher.once("change", callbackUndelayed);
    }
    const fetchTimeInfo = () => {
      const fileTimeInfoEntries = /* @__PURE__ */ new Map();
      const contextTimeInfoEntries = /* @__PURE__ */ new Map();
      if (this.watcher) {
        this.watcher.collectTimeInfoEntries(
          fileTimeInfoEntries,
          contextTimeInfoEntries
        );
      }
      return { fileTimeInfoEntries, contextTimeInfoEntries };
    };
    this.watcher.once("aggregated", (changes, removals) => {
      var _a, _b, _c;
      this.watcher.pause();
      if ((_a = this.inputFileSystem) == null ? void 0 : _a.purge) {
        const fs5 = this.inputFileSystem;
        for (const item of changes) {
          (_b = fs5.purge) == null ? void 0 : _b.call(fs5, item);
        }
        for (const item of removals) {
          (_c = fs5.purge) == null ? void 0 : _c.call(fs5, item);
        }
      }
      const { fileTimeInfoEntries, contextTimeInfoEntries } = fetchTimeInfo();
      callback(
        null,
        fileTimeInfoEntries,
        contextTimeInfoEntries,
        changes,
        removals
      );
    });
    this.watcher.watch({ files, directories, missing, startTime });
    if (oldWatcher) {
      oldWatcher.close();
    }
    return {
      close: () => {
        if (this.watcher) {
          this.watcher.close();
          this.watcher = null;
        }
      },
      pause: () => {
        if (this.watcher) {
          this.watcher.pause();
        }
      },
      getAggregatedRemovals: import_node_util5.default.deprecate(
        () => {
          var _a, _b, _c;
          const items = (_a = this.watcher) == null ? void 0 : _a.aggregatedRemovals;
          if (items && ((_b = this.inputFileSystem) == null ? void 0 : _b.purge)) {
            const fs5 = this.inputFileSystem;
            for (const item of items) {
              (_c = fs5.purge) == null ? void 0 : _c.call(fs5, item);
            }
          }
          return items;
        },
        "Watcher.getAggregatedRemovals is deprecated in favor of Watcher.getInfo since that's more performant.",
        "DEP_WEBPACK_WATCHER_GET_AGGREGATED_REMOVALS"
      ),
      getAggregatedChanges: import_node_util5.default.deprecate(
        () => {
          var _a, _b, _c;
          const items = (_a = this.watcher) == null ? void 0 : _a.aggregatedChanges;
          if (items && ((_b = this.inputFileSystem) == null ? void 0 : _b.purge)) {
            const fs5 = this.inputFileSystem;
            for (const item of items) {
              (_c = fs5.purge) == null ? void 0 : _c.call(fs5, item);
            }
          }
          return items;
        },
        "Watcher.getAggregatedChanges is deprecated in favor of Watcher.getInfo since that's more performant.",
        "DEP_WEBPACK_WATCHER_GET_AGGREGATED_CHANGES"
      ),
      getFileTimeInfoEntries: import_node_util5.default.deprecate(
        () => {
          return fetchTimeInfo().fileTimeInfoEntries;
        },
        "Watcher.getFileTimeInfoEntries is deprecated in favor of Watcher.getInfo since that's more performant.",
        "DEP_WEBPACK_WATCHER_FILE_TIME_INFO_ENTRIES"
      ),
      getContextTimeInfoEntries: import_node_util5.default.deprecate(
        () => {
          return fetchTimeInfo().contextTimeInfoEntries;
        },
        "Watcher.getContextTimeInfoEntries is deprecated in favor of Watcher.getInfo since that's more performant.",
        "DEP_WEBPACK_WATCHER_CONTEXT_TIME_INFO_ENTRIES"
      ),
      getInfo: () => {
        var _a, _b, _c, _d, _e;
        const removals = (_a = this.watcher) == null ? void 0 : _a.aggregatedRemovals;
        const changes = (_b = this.watcher) == null ? void 0 : _b.aggregatedChanges;
        if ((_c = this.inputFileSystem) == null ? void 0 : _c.purge) {
          const fs5 = this.inputFileSystem;
          if (removals) {
            for (const item of removals) {
              (_d = fs5.purge) == null ? void 0 : _d.call(fs5, item);
            }
          }
          if (changes) {
            for (const item of changes) {
              (_e = fs5.purge) == null ? void 0 : _e.call(fs5, item);
            }
          }
        }
        const { fileTimeInfoEntries, contextTimeInfoEntries } = fetchTimeInfo();
        return {
          changes,
          removals,
          fileTimeInfoEntries,
          contextTimeInfoEntries
        };
      }
    };
  }
};

// src/node/nodeConsole.ts
var util5 = __toESM(require("util"));

// src/logging/truncateArgs.ts
var arraySum = (array) => {
  let sum = 0;
  for (const item of array) sum += item;
  return sum;
};
var truncateArgs = (args, maxLength) => {
  const lengths = args.map((a) => `${a}`.length);
  const availableLength = maxLength - lengths.length + 1;
  if (availableLength > 0 && args.length === 1) {
    if (availableLength >= args[0].length) {
      return args;
    }
    if (availableLength > 3) {
      return [`...${args[0].slice(-availableLength + 3)}`];
    }
    return [args[0].slice(-availableLength)];
  }
  if (availableLength < arraySum(lengths.map((i) => Math.min(i, 6)))) {
    if (args.length > 1)
      return truncateArgs(args.slice(0, args.length - 1), maxLength);
    return [];
  }
  let currentLength = arraySum(lengths);
  if (currentLength <= availableLength) return args;
  while (currentLength > availableLength) {
    const maxLength2 = Math.max(...lengths);
    const shorterItems = lengths.filter((l) => l !== maxLength2);
    const nextToMaxLength = shorterItems.length > 0 ? Math.max(...shorterItems) : 0;
    const maxReduce = maxLength2 - nextToMaxLength;
    let maxItems = lengths.length - shorterItems.length;
    let overrun = currentLength - availableLength;
    for (let i = 0; i < lengths.length; i++) {
      if (lengths[i] === maxLength2) {
        const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);
        lengths[i] -= reduce;
        currentLength -= reduce;
        overrun -= reduce;
        maxItems--;
      }
    }
  }
  return args.map((a, i) => {
    const str = `${a}`;
    const length = lengths[i];
    if (str.length === length) {
      return str;
    }
    if (length > 5) {
      return `...${str.slice(-length + 3)}`;
    }
    if (length > 0) {
      return str.slice(-length);
    }
    return "";
  });
};

// src/node/nodeConsole.ts
function nodeConsole_default({
  colors,
  appendOnly,
  stream
}) {
  let currentStatusMessage = void 0;
  let hasStatusMessage = false;
  let currentIndent = "";
  let currentCollapsed = 0;
  const indent3 = (str, prefix, colorPrefix, colorSuffix) => {
    if (str === "") return str;
    const prefixWithIndent = currentIndent + prefix;
    if (colors) {
      return prefixWithIndent + colorPrefix + str.replace(/\n/g, `${colorSuffix}
${prefix}${colorPrefix}`) + colorSuffix;
    }
    return prefixWithIndent + str.replace(/\n/g, `
${prefix}`);
  };
  const clearStatusMessage = () => {
    if (hasStatusMessage) {
      stream.write("\x1B[2K\r");
      hasStatusMessage = false;
    }
  };
  const writeStatusMessage = () => {
    if (!currentStatusMessage) return;
    const l = stream.columns;
    const args = l ? truncateArgs(currentStatusMessage, l - 1) : currentStatusMessage;
    const str = args.join(" ");
    const coloredStr = `\x1B[1m${str}\x1B[39m\x1B[22m`;
    stream.write(`\x1B[2K\r${coloredStr}`);
    hasStatusMessage = true;
  };
  const writeColored = (prefix, colorPrefix, colorSuffix) => {
    return (...args) => {
      if (currentCollapsed > 0) return;
      clearStatusMessage();
      const str = indent3(
        util5.format(...args),
        prefix,
        colorPrefix,
        colorSuffix
      );
      stream.write(`${str}
`);
      writeStatusMessage();
    };
  };
  const writeGroupMessage = writeColored(
    "<-> ",
    "\x1B[1m\x1B[36m",
    "\x1B[39m\x1B[22m"
  );
  const writeGroupCollapsedMessage = writeColored(
    "<+> ",
    "\x1B[1m\x1B[36m",
    "\x1B[39m\x1B[22m"
  );
  return {
    log: writeColored("    ", "\x1B[1m", "\x1B[22m"),
    debug: writeColored("    ", "", ""),
    trace: writeColored("    ", "", ""),
    info: writeColored("<i> ", "\x1B[1m\x1B[32m", "\x1B[39m\x1B[22m"),
    warn: writeColored("<w> ", "\x1B[1m\x1B[33m", "\x1B[39m\x1B[22m"),
    error: writeColored("<e> ", "\x1B[1m\x1B[31m", "\x1B[39m\x1B[22m"),
    logTime: writeColored(
      "<t> ",
      "\x1B[1m\x1B[35m",
      "\x1B[39m\x1B[22m"
    ),
    group: (...args) => {
      writeGroupMessage(...args);
      if (currentCollapsed > 0) {
        currentCollapsed++;
      } else {
        currentIndent += "  ";
      }
    },
    groupCollapsed: (...args) => {
      writeGroupCollapsedMessage(...args);
      currentCollapsed++;
    },
    groupEnd: () => {
      if (currentCollapsed > 0) currentCollapsed--;
      else if (currentIndent.length >= 2)
        currentIndent = currentIndent.slice(0, currentIndent.length - 2);
    },
    profile: console.profile && ((name2) => console.profile(name2)),
    profileEnd: console.profileEnd && ((name2) => console.profileEnd(name2)),
    clear: !appendOnly && console.clear && (() => {
      clearStatusMessage();
      console.clear();
      writeStatusMessage();
    }),
    status: appendOnly ? writeColored("<s> ", "", "") : (name2, ...argsWithEmpty) => {
      const args = argsWithEmpty.filter(Boolean);
      if (name2 === void 0 && args.length === 0) {
        clearStatusMessage();
        currentStatusMessage = void 0;
      } else if (typeof name2 === "string" && name2.startsWith("[webpack.Progress] ")) {
        currentStatusMessage = [name2.slice(19), ...args];
        writeStatusMessage();
      } else if (name2 === "[webpack.Progress]") {
        currentStatusMessage = [...args];
        writeStatusMessage();
      } else {
        currentStatusMessage = [name2, ...args];
        writeStatusMessage();
      }
    }
  };
}

// src/node/NodeEnvironmentPlugin.ts
var NodeEnvironmentPlugin = class {
  constructor(options) {
    this.options = options;
  }
  apply(compiler) {
    const { infrastructureLogging: infrastructureLogging2 } = this.options;
    compiler.infrastructureLogger = createConsoleLogger({
      level: infrastructureLogging2.level || "info",
      debug: infrastructureLogging2.debug || false,
      console: infrastructureLogging2.console || nodeConsole_default({
        colors: infrastructureLogging2.colors,
        appendOnly: infrastructureLogging2.appendOnly,
        stream: infrastructureLogging2.stream
      })
    });
    const inputFileSystem = new import_CachedInputFileSystem.default(
      import_graceful_fs2.default,
      6e4
    );
    compiler.inputFileSystem = inputFileSystem;
    compiler.outputFileSystem = import_graceful_fs2.default;
    compiler.intermediateFileSystem = import_graceful_fs2.default;
    compiler.watchFileSystem = new NodeWatchFileSystem(inputFileSystem);
    compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", (compiler2) => {
      var _a;
      if (compiler2.inputFileSystem === inputFileSystem) {
        compiler2.fsStartTime = Date.now();
        (_a = inputFileSystem.purge) == null ? void 0 : _a.call(inputFileSystem);
      }
    });
  }
};

// src/node/NodeTemplatePlugin.ts
var NodeTemplatePlugin = class {
  constructor(_options = {}) {
    this._options = _options;
  }
  apply(compiler) {
    const chunkLoading2 = this._options.asyncChunkLoading ? "async-node" : "require";
    compiler.options.output.chunkLoading = chunkLoading2;
    new CommonJsChunkFormatPlugin().apply(compiler);
    new EnableChunkLoadingPlugin(chunkLoading2).apply(compiler);
  }
};

// src/container/ModuleFederationRuntimePlugin.ts
var import_binding74 = require("@rspack/binding");
var ModuleFederationRuntimePlugin = create2(
  import_binding74.BuiltinPluginName.ModuleFederationRuntimePlugin,
  () => {
  }
);

// src/container/options.ts
var process2 = (options, normalizeSimple, normalizeOptions, fn2) => {
  const array = (items) => {
    for (const item of items) {
      if (typeof item === "string") {
        fn2(item, normalizeSimple(item, item));
      } else if (item && typeof item === "object") {
        object(item);
      } else {
        throw new Error("Unexpected options format");
      }
    }
  };
  const object = (obj) => {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string" || Array.isArray(value)) {
        fn2(key, normalizeSimple(value, key));
      } else {
        fn2(key, normalizeOptions(value, key));
      }
    }
  };
  if (!options) {
    return;
  }
  if (Array.isArray(options)) {
    array(options);
  } else if (typeof options === "object") {
    object(options);
  } else {
    throw new Error("Unexpected options format");
  }
};
var parseOptions = (options, normalizeSimple, normalizeOptions) => {
  const items = [];
  process2(options, normalizeSimple, normalizeOptions, (key, value) => {
    items.push([key, value]);
  });
  return items;
};

// src/container/ModuleFederationPlugin.ts
var ModuleFederationPlugin = class _ModuleFederationPlugin {
  constructor(_options) {
    this._options = _options;
  }
  apply(compiler) {
    const { webpack } = compiler;
    const paths = getPaths(this._options);
    compiler.options.resolve.alias = {
      "@module-federation/runtime-tools": paths.runtimeTools,
      "@module-federation/runtime": paths.runtime,
      ...compiler.options.resolve.alias
    };
    compiler.hooks.afterPlugins.tap(_ModuleFederationPlugin.name, () => {
      new webpack.EntryPlugin(
        compiler.context,
        getDefaultEntryRuntime(paths, this._options, compiler),
        { name: void 0 }
      ).apply(compiler);
    });
    new ModuleFederationRuntimePlugin().apply(compiler);
    new webpack.container.ModuleFederationPluginV1({
      ...this._options,
      enhanced: true
    }).apply(compiler);
  }
};
function getRemoteInfos(options) {
  if (!options.remotes) {
    return {};
  }
  function extractUrlAndGlobal(urlAndGlobal) {
    const index = urlAndGlobal.indexOf("@");
    if (index <= 0 || index === urlAndGlobal.length - 1) {
      return null;
    }
    return [
      urlAndGlobal.substring(index + 1),
      urlAndGlobal.substring(0, index)
    ];
  }
  function getExternalTypeFromExternal(external) {
    if (/^[a-z0-9-]+ /.test(external)) {
      const idx = external.indexOf(" ");
      return [
        external.slice(0, idx),
        external.slice(idx + 1)
      ];
    }
    return null;
  }
  function getExternal(external) {
    const result2 = getExternalTypeFromExternal(external);
    if (result2 === null) {
      return [remoteType, external];
    }
    return result2;
  }
  const remoteType = options.remoteType || (options.library && isValidate(options.library.type, externalsType) ? options.library.type : "script");
  const remotes = parseOptions(
    options.remotes,
    (item) => ({
      external: Array.isArray(item) ? item : [item],
      shareScope: options.shareScope || "default"
    }),
    (item) => ({
      external: Array.isArray(item.external) ? item.external : [item.external],
      shareScope: item.shareScope || options.shareScope || "default"
    })
  );
  const remoteInfos = {};
  for (const [key, config2] of remotes) {
    for (const external of config2.external) {
      const [externalType, externalRequest] = getExternal(external);
      remoteInfos[key] ??= [];
      if (externalType === "script") {
        const [url2, global] = extractUrlAndGlobal(externalRequest);
        remoteInfos[key].push({
          alias: key,
          name: global,
          entry: url2,
          externalType,
          shareScope: config2.shareScope
        });
      } else {
        remoteInfos[key].push({
          alias: key,
          name: void 0,
          entry: void 0,
          externalType,
          shareScope: config2.shareScope
        });
      }
    }
  }
  return remoteInfos;
}
function getRuntimePlugins(options) {
  return options.runtimePlugins ?? [];
}
function getPaths(options) {
  const runtimeToolsPath = options.implementation ?? require.resolve("@module-federation/runtime-tools");
  const bundlerRuntimePath = require.resolve(
    "@module-federation/webpack-bundler-runtime",
    { paths: [runtimeToolsPath] }
  );
  const runtimePath = require.resolve("@module-federation/runtime", {
    paths: [runtimeToolsPath]
  });
  return {
    runtimeTools: runtimeToolsPath,
    bundlerRuntime: bundlerRuntimePath,
    runtime: runtimePath
  };
}
function getDefaultEntryRuntime(paths, options, compiler) {
  const runtimePlugins = getRuntimePlugins(options);
  const remoteInfos = getRemoteInfos(options);
  const runtimePluginImports = [];
  const runtimePluginVars = [];
  for (let i = 0; i < runtimePlugins.length; i++) {
    const runtimePluginVar = `__module_federation_runtime_plugin_${i}__`;
    runtimePluginImports.push(
      `import ${runtimePluginVar} from ${JSON.stringify(runtimePlugins[i])}`
    );
    runtimePluginVars.push(`${runtimePluginVar}()`);
  }
  const content = [
    `import __module_federation_bundler_runtime__ from ${JSON.stringify(
      paths.bundlerRuntime
    )}`,
    ...runtimePluginImports,
    `const __module_federation_runtime_plugins__ = [${runtimePluginVars.join(
      ", "
    )}]`,
    `const __module_federation_remote_infos__ = ${JSON.stringify(remoteInfos)}`,
    `const __module_federation_container_name__ = ${JSON.stringify(
      options.name ?? compiler.options.output.uniqueName
    )}`,
    `const __module_federation_share_strategy__ = ${JSON.stringify(
      options.shareStrategy ?? "version-first"
    )}`,
    compiler.webpack.Template.getFunctionContent(
      require("./moduleFederationDefaultRuntime.js")
    )
  ].join(";");
  return `@module-federation/runtime/rspack.js!=!data:text/javascript,${content}`;
}

// src/sharing/ConsumeSharedPlugin.ts
var import_binding76 = require("@rspack/binding");

// src/sharing/ShareRuntimePlugin.ts
var import_binding75 = require("@rspack/binding");
var compilerSet = /* @__PURE__ */ new WeakSet();
function isSingleton(compiler) {
  return compilerSet.has(compiler);
}
function setSingleton(compiler) {
  compilerSet.add(compiler);
}
var ShareRuntimePlugin = class extends RspackBuiltinPlugin {
  constructor(enhanced = false) {
    super();
    this.enhanced = enhanced;
    this.name = import_binding75.BuiltinPluginName.ShareRuntimePlugin;
  }
  raw(compiler) {
    if (isSingleton(compiler)) return;
    setSingleton(compiler);
    return createBuiltinPlugin(this.name, this.enhanced);
  }
};

// src/sharing/utils.ts
var VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;
function isRequiredVersion(str) {
  return VERSION_PATTERN_REGEXP.test(str);
}

// src/sharing/ConsumeSharedPlugin.ts
var ConsumeSharedPlugin = class extends RspackBuiltinPlugin {
  constructor(options) {
    super();
    this.name = import_binding76.BuiltinPluginName.ConsumeSharedPlugin;
    this._options = {
      consumes: parseOptions(
        options.consumes,
        (item, key) => {
          if (Array.isArray(item))
            throw new Error("Unexpected array in options");
          const result2 = item === key || !isRequiredVersion(item) ? (
            // item is a request/key
            {
              import: key,
              shareScope: options.shareScope || "default",
              shareKey: key,
              requiredVersion: void 0,
              packageName: void 0,
              strictVersion: false,
              singleton: false,
              eager: false
            }
          ) : (
            // key is a request/key
            // item is a version
            {
              import: key,
              shareScope: options.shareScope || "default",
              shareKey: key,
              requiredVersion: item,
              strictVersion: true,
              packageName: void 0,
              singleton: false,
              eager: false
            }
          );
          return result2;
        },
        (item, key) => ({
          import: item.import === false ? void 0 : item.import || key,
          shareScope: item.shareScope || options.shareScope || "default",
          shareKey: item.shareKey || key,
          requiredVersion: item.requiredVersion,
          strictVersion: typeof item.strictVersion === "boolean" ? item.strictVersion : item.import !== false && !item.singleton,
          packageName: item.packageName,
          singleton: !!item.singleton,
          eager: !!item.eager
        })
      ),
      enhanced: options.enhanced ?? false
    };
  }
  raw(compiler) {
    new ShareRuntimePlugin(this._options.enhanced).apply(compiler);
    const rawOptions = {
      consumes: this._options.consumes.map(([key, v]) => ({
        key,
        ...v
      })),
      enhanced: this._options.enhanced
    };
    return createBuiltinPlugin(this.name, rawOptions);
  }
};

// src/sharing/ProvideSharedPlugin.ts
var import_binding77 = require("@rspack/binding");
var ProvideSharedPlugin = class extends RspackBuiltinPlugin {
  constructor(options) {
    super();
    this.name = import_binding77.BuiltinPluginName.ProvideSharedPlugin;
    this._provides = parseOptions(
      options.provides,
      (item) => {
        if (Array.isArray(item))
          throw new Error("Unexpected array of provides");
        return {
          shareKey: item,
          version: void 0,
          shareScope: options.shareScope || "default",
          eager: false
        };
      },
      (item) => {
        const raw = {
          shareKey: item.shareKey,
          version: item.version,
          shareScope: item.shareScope || options.shareScope || "default",
          eager: !!item.eager
        };
        if (options.enhanced) {
          const enhancedItem = item;
          return {
            ...raw,
            singleton: enhancedItem.singleton,
            requiredVersion: enhancedItem.requiredVersion,
            strictVersion: enhancedItem.strictVersion
          };
        }
        return raw;
      }
    );
    this._enhanced = options.enhanced;
  }
  raw(compiler) {
    new ShareRuntimePlugin(this._enhanced ?? false).apply(compiler);
    const rawOptions = this._provides.map(([key, v]) => ({
      key,
      ...v
    }));
    return createBuiltinPlugin(this.name, rawOptions);
  }
};

// src/sharing/SharePlugin.ts
var SharePlugin = class {
  constructor(options) {
    const sharedOptions = parseOptions(
      options.shared,
      (item, key) => {
        if (typeof item !== "string")
          throw new Error("Unexpected array in shared");
        const config2 = item === key || !isRequiredVersion(item) ? {
          import: item
        } : {
          import: key,
          requiredVersion: item
        };
        return config2;
      },
      (item) => item
    );
    const consumes = sharedOptions.map(([key, options2]) => ({
      [key]: {
        import: options2.import,
        shareKey: options2.shareKey || key,
        shareScope: options2.shareScope,
        requiredVersion: options2.requiredVersion,
        strictVersion: options2.strictVersion,
        singleton: options2.singleton,
        packageName: options2.packageName,
        eager: options2.eager
      }
    }));
    const provides = sharedOptions.filter(([, options2]) => options2.import !== false).map(([key, options2]) => ({
      [options2.import || key]: {
        shareKey: options2.shareKey || key,
        shareScope: options2.shareScope,
        version: options2.version,
        eager: options2.eager,
        singleton: options2.singleton,
        requiredVersion: options2.requiredVersion,
        strictVersion: options2.strictVersion
      }
    }));
    this._shareScope = options.shareScope;
    this._consumes = consumes;
    this._provides = provides;
    this._enhanced = options.enhanced ?? false;
  }
  apply(compiler) {
    new ConsumeSharedPlugin({
      shareScope: this._shareScope,
      consumes: this._consumes,
      enhanced: this._enhanced
    }).apply(compiler);
    new ProvideSharedPlugin({
      shareScope: this._shareScope,
      provides: this._provides,
      enhanced: this._enhanced
    }).apply(compiler);
  }
};

// src/container/ContainerPlugin.ts
var import_binding78 = require("@rspack/binding");
var ContainerPlugin = class extends RspackBuiltinPlugin {
  constructor(options) {
    super();
    this.name = import_binding78.BuiltinPluginName.ContainerPlugin;
    this._options = {
      name: options.name,
      shareScope: options.shareScope || "default",
      library: options.library || {
        type: "var",
        name: options.name
      },
      runtime: options.runtime,
      filename: options.filename,
      exposes: parseOptions(
        options.exposes,
        (item) => ({
          import: Array.isArray(item) ? item : [item],
          name: void 0
        }),
        (item) => ({
          import: Array.isArray(item.import) ? item.import : [item.import],
          name: item.name || void 0
        })
      ),
      enhanced: options.enhanced ?? false
    };
  }
  raw(compiler) {
    const { name: name2, shareScope, library: library3, runtime, filename: filename2, exposes, enhanced } = this._options;
    if (!compiler.options.output.enabledLibraryTypes.includes(library3.type)) {
      compiler.options.output.enabledLibraryTypes.push(library3.type);
    }
    new ShareRuntimePlugin(this._options.enhanced).apply(compiler);
    const rawOptions = {
      name: name2,
      shareScope,
      library: getRawLibrary(library3),
      runtime,
      filename: filename2,
      exposes: exposes.map(([key, r]) => ({ key, ...r })),
      enhanced
    };
    return createBuiltinPlugin(this.name, rawOptions);
  }
};

// src/container/ContainerReferencePlugin.ts
var import_binding79 = require("@rspack/binding");
var ContainerReferencePlugin = class extends RspackBuiltinPlugin {
  constructor(options) {
    super();
    this.name = import_binding79.BuiltinPluginName.ContainerReferencePlugin;
    this._options = {
      remoteType: options.remoteType,
      remotes: parseOptions(
        options.remotes,
        (item) => ({
          external: Array.isArray(item) ? item : [item],
          shareScope: options.shareScope || "default"
        }),
        (item) => ({
          external: Array.isArray(item.external) ? item.external : [item.external],
          shareScope: item.shareScope || options.shareScope || "default"
        })
      ),
      enhanced: options.enhanced ?? false
    };
  }
  raw(compiler) {
    const { remoteType, remotes } = this._options;
    const remoteExternals = {};
    for (const [key, config2] of remotes) {
      let i = 0;
      for (const external of config2.external) {
        if (external.startsWith("internal ")) continue;
        remoteExternals[`webpack/container/reference/${key}${i ? `/fallback-${i}` : ""}`] = external;
        i++;
      }
    }
    new ExternalsPlugin(remoteType, remoteExternals).apply(compiler);
    new ShareRuntimePlugin(this._options.enhanced).apply(compiler);
    const rawOptions = {
      remoteType: this._options.remoteType,
      remotes: this._options.remotes.map(([key, r]) => ({ key, ...r })),
      enhanced: this._options.enhanced
    };
    return createBuiltinPlugin(this.name, rawOptions);
  }
};

// src/container/ModuleFederationPluginV1.ts
var ModuleFederationPluginV1 = class {
  constructor(_options) {
    this._options = _options;
  }
  apply(compiler) {
    const { _options: options } = this;
    const enhanced = options.enhanced ?? false;
    const library3 = options.library || { type: "var", name: options.name };
    const remoteType = options.remoteType || (options.library && isValidate(options.library.type, externalsType) ? options.library.type : "script");
    if (library3 && !compiler.options.output.enabledLibraryTypes.includes(library3.type)) {
      compiler.options.output.enabledLibraryTypes.push(library3.type);
    }
    compiler.hooks.afterPlugins.tap("ModuleFederationPlugin", () => {
      new ShareRuntimePlugin(this._options.enhanced).apply(compiler);
      if (options.exposes && (Array.isArray(options.exposes) ? options.exposes.length > 0 : Object.keys(options.exposes).length > 0)) {
        new ContainerPlugin({
          name: options.name,
          library: library3,
          filename: options.filename,
          runtime: options.runtime,
          shareScope: options.shareScope,
          exposes: options.exposes,
          enhanced
        }).apply(compiler);
      }
      if (options.remotes && (Array.isArray(options.remotes) ? options.remotes.length > 0 : Object.keys(options.remotes).length > 0)) {
        new ContainerReferencePlugin({
          remoteType,
          shareScope: options.shareScope,
          remotes: options.remotes,
          enhanced
        }).apply(compiler);
      }
      if (options.shared) {
        new SharePlugin({
          shared: options.shared,
          shareScope: options.shareScope,
          enhanced
        }).apply(compiler);
      }
    });
  }
};

// src/exports.ts
var import_binding80 = require("@rspack/binding");
var rspackVersion = import_package.version;
var version = import_package.webpackVersion;
var WebpackError2 = Error;
var sources = require("../compiled/webpack-sources/index.js");
var config = {
  getNormalizedRspackOptions,
  applyRspackOptionsDefaults,
  getNormalizedWebpackOptions: getNormalizedRspackOptions,
  applyWebpackOptionsDefaults: applyRspackOptionsDefaults
};
var util6 = { createHash, cleverMerge: cachedCleverMerge };
var web = {
  FetchCompileAsyncWasmPlugin
};
var node2 = {
  NodeTargetPlugin,
  NodeTemplatePlugin,
  NodeEnvironmentPlugin
};
var electron = { ElectronTargetPlugin };
var library2 = { EnableLibraryPlugin };
var wasm = { EnableWasmLoadingPlugin };
var javascript = {
  EnableChunkLoadingPlugin,
  JavascriptModulesPlugin
};
var webworker = { WebWorkerTemplatePlugin };
var optimize = {
  LimitChunkCountPlugin,
  RuntimeChunkPlugin,
  SplitChunksPlugin
};
var container = {
  ContainerPlugin,
  ContainerReferencePlugin,
  ModuleFederationPlugin,
  ModuleFederationPluginV1
};
var sharing = {
  ProvideSharedPlugin,
  ConsumeSharedPlugin,
  SharePlugin
};
var experiments2 = {
  globalTrace: {
    register: import_binding80.registerGlobalTrace,
    cleanup: import_binding80.cleanupGlobalTrace
  }
};

// src/rspack.ts
var import_node_assert9 = __toESM(require("assert"));
var import_node_util6 = __toESM(require("util"));
function createMultiCompiler(options) {
  const compilers = options.map(createCompiler);
  const compiler = new MultiCompiler(
    compilers,
    options
  );
  for (const childCompiler of compilers) {
    if (childCompiler.options.dependencies) {
      compiler.setDependencies(
        childCompiler,
        childCompiler.options.dependencies
      );
    }
  }
  return compiler;
}
function createCompiler(userOptions) {
  const options = getNormalizedRspackOptions(userOptions);
  applyRspackOptionsBaseDefaults(options);
  (0, import_node_assert9.default)(!isNil(options.context));
  const compiler = new Compiler(options.context, options);
  new NodeEnvironmentPlugin({
    infrastructureLogging: options.infrastructureLogging
  }).apply(compiler);
  if (Array.isArray(options.plugins)) {
    for (const plugin2 of options.plugins) {
      if (typeof plugin2 === "function") {
        plugin2.call(compiler, compiler);
      } else if (plugin2) {
        plugin2.apply(compiler);
      }
    }
  }
  applyRspackOptionsDefaults(compiler.options);
  compiler.hooks.environment.call();
  compiler.hooks.afterEnvironment.call();
  new RspackOptionsApply().process(compiler.options, compiler);
  compiler.hooks.initialize.call();
  return compiler;
}
function isMultiRspackOptions(o) {
  return Array.isArray(o);
}
function rspack2(options, callback) {
  try {
    for (const o of asArray(options)) {
      validate(o, rspackOptions);
    }
  } catch (e) {
    if (e instanceof Error && callback) {
      callback(e);
      return null;
    }
    throw e;
  }
  const create3 = () => {
    if (isMultiRspackOptions(options)) {
      const compiler2 = createMultiCompiler(options);
      const watch3 = options.some((options2) => options2.watch);
      const watchOptions3 = options.map((options2) => options2.watchOptions || {});
      return { compiler: compiler2, watch: watch3, watchOptions: watchOptions3 };
    }
    const compiler = createCompiler(options);
    const watch2 = options.watch;
    const watchOptions2 = options.watchOptions || {};
    return { compiler, watch: watch2, watchOptions: watchOptions2 };
  };
  if (callback) {
    try {
      const { compiler, watch: watch2, watchOptions: watchOptions2 } = create3();
      if (watch2) {
        compiler.watch(watchOptions2, callback);
      } else {
        compiler.run((err, stats) => {
          compiler.close(() => {
            callback(err, stats);
          });
        });
      }
      return compiler;
    } catch (err) {
      process.nextTick(() => callback(err));
      return null;
    }
  } else {
    const { compiler, watch: watch2 } = create3();
    if (watch2) {
      import_node_util6.default.deprecate(
        () => {
        },
        "A 'callback' argument needs to be provided to the 'rspack(options, callback)' function when the 'watch' option is set. There is no way to handle the 'watch' option without a callback."
      )();
    }
    return compiler;
  }
}

// src/index.ts
var fn = Object.assign(rspack2, exports_exports);
fn.rspack = fn;
fn.webpack = fn;
var rspack = fn;
module.exports = rspack;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BannerPlugin,
  Compilation,
  Compiler,
  ContextReplacementPlugin,
  CopyRspackPlugin,
  CssExtractRspackPlugin,
  DefinePlugin,
  DynamicEntryPlugin,
  EntryOptionPlugin,
  EntryPlugin,
  EnvironmentPlugin,
  EvalDevToolModulePlugin,
  EvalSourceMapDevToolPlugin,
  ExternalsPlugin,
  HotModuleReplacementPlugin,
  HtmlRspackPlugin,
  IgnorePlugin,
  LightningCssMinimizerRspackPlugin,
  LoaderOptionsPlugin,
  LoaderTargetPlugin,
  ModuleFilenameHelpers,
  MultiCompiler,
  MultiStats,
  NoEmitOnErrorsPlugin,
  NormalModule,
  NormalModuleReplacementPlugin,
  ProgressPlugin,
  ProvidePlugin,
  RspackOptionsApply,
  RuntimeGlobals,
  RuntimeModule,
  SourceMapDevToolPlugin,
  Stats,
  SwcJsMinimizerRspackPlugin,
  Template,
  ValidationError,
  WebpackError,
  WebpackOptionsApply,
  config,
  container,
  electron,
  experiments,
  javascript,
  library,
  node,
  optimize,
  rspack,
  rspackVersion,
  sharing,
  sources,
  util,
  version,
  wasm,
  web,
  webworker
});
