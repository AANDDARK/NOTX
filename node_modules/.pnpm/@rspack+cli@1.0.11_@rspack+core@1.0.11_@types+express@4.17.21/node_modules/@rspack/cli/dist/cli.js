"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.definePlugin = exports.defineConfig = exports.RspackCLI = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_util_1 = __importDefault(require("node:util"));
const core_1 = require("@rspack/core");
const rspackCore = __importStar(require("@rspack/core"));
const semver_1 = __importDefault(require("semver"));
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
const build_1 = require("./commands/build");
const preview_1 = require("./commands/preview");
const serve_1 = require("./commands/serve");
const loadConfig_1 = require("./utils/loadConfig");
const options_1 = require("./utils/options");
class RspackCLI {
    constructor() {
        this.colors = this.createColors();
        this.program = (0, yargs_1.default)();
    }
    async createCompiler(options, rspackCommand, callback) {
        process.env.RSPACK_CONFIG_VALIDATE ??= "loose";
        process.env.WATCHPACK_WATCHER_LIMIT =
            process.env.WATCHPACK_WATCHER_LIMIT || "20";
        const nodeEnv = process?.env?.NODE_ENV;
        const rspackCommandDefaultEnv = rspackCommand === "build" ? "production" : "development";
        if (typeof options.nodeEnv === "string") {
            process.env.NODE_ENV = nodeEnv || options.nodeEnv;
        }
        else {
            process.env.NODE_ENV = nodeEnv || rspackCommandDefaultEnv;
        }
        let config = await this.loadConfig(options);
        config = await this.buildConfig(config, options, rspackCommand);
        const isWatch = Array.isArray(config)
            ? config.some(i => i.watch)
            : config.watch;
        let compiler;
        try {
            compiler = (0, core_1.rspack)(config, isWatch ? callback : undefined);
        }
        catch (e) {
            // Aligned with webpack-cli
            // See: https://github.com/webpack/webpack-cli/blob/eea6adf7d34dfbfd3b5b784ece4a4664834f5a6a/packages/webpack-cli/src/webpack-cli.ts#L2394
            if (e instanceof core_1.ValidationError) {
                this.getLogger().error(e.message);
                process.exit(2);
            }
            else if (e instanceof Error) {
                callback?.(e);
                return null;
            }
            throw e;
        }
        return compiler;
    }
    createColors(useColor) {
        const { createColors, isColorSupported } = require("colorette");
        const shouldUseColor = useColor || isColorSupported;
        return {
            ...createColors({ useColor: shouldUseColor }),
            isColorSupported: shouldUseColor
        };
    }
    getLogger() {
        return {
            error: val => console.error(`[rspack-cli] ${this.colors.red(node_util_1.default.format(val))}`),
            warn: val => console.warn(`[rspack-cli] ${this.colors.yellow(val)}`),
            info: val => console.info(`[rspack-cli] ${this.colors.cyan(val)}`),
            success: val => console.log(`[rspack-cli] ${this.colors.green(val)}`),
            log: val => console.log(`[rspack-cli] ${val}`),
            raw: val => console.log(val)
        };
    }
    async run(argv) {
        if (semver_1.default.lt(semver_1.default.clean(process.version), "14.0.0")) {
            this.getLogger().warn(`Minimum recommended Node.js version is 14.0.0, current version is ${process.version}`);
        }
        this.program.showHelpOnFail(false);
        this.program.usage("[options]");
        this.program.scriptName("rspack");
        this.program.strictCommands(true).strict(true);
        this.program.middleware(options_1.normalizeEnv);
        this.registerCommands();
        await this.program.parseAsync((0, helpers_1.hideBin)(argv));
    }
    async registerCommands() {
        const builtinCommands = [
            new build_1.BuildCommand(),
            new serve_1.ServeCommand(),
            new preview_1.PreviewCommand()
        ];
        for (const command of builtinCommands) {
            command.apply(this);
        }
    }
    async buildConfig(item, options, command) {
        const isBuild = command === "build";
        const isServe = command === "serve";
        const commandDefaultEnv = isBuild
            ? "production"
            : "development";
        const internalBuildConfig = async (item) => {
            if (options.entry) {
                item.entry = {
                    main: options.entry.map(x => node_path_1.default.resolve(process.cwd(), x))[0] // Fix me when entry supports array
                };
            }
            // to set output.path
            item.output = item.output || {};
            if (options["output-path"]) {
                item.output.path = node_path_1.default.resolve(process.cwd(), options["output-path"]);
            }
            if (options.analyze) {
                const { BundleAnalyzerPlugin } = await import("webpack-bundle-analyzer");
                (item.plugins ??= []).push({
                    name: "rspack-bundle-analyzer",
                    apply(compiler) {
                        new BundleAnalyzerPlugin({
                            generateStatsFile: true
                        }).apply(compiler);
                    }
                });
            }
            if (options.profile) {
                item.profile = true;
            }
            if (process.env.RSPACK_PROFILE) {
                const { applyProfile } = await import("./utils/profile.js");
                await applyProfile(process.env.RSPACK_PROFILE, item);
            }
            // cli --watch overrides the watch config
            if (options.watch) {
                item.watch = options.watch;
            }
            // auto set default mode if user config don't set it
            if (!item.mode) {
                item.mode = commandDefaultEnv ?? "none";
            }
            // user parameters always has highest priority than default mode and config mode
            if (options.mode) {
                item.mode = options.mode;
            }
            // false is also a valid value for sourcemap, so don't override it
            if (typeof item.devtool === "undefined") {
                item.devtool = isBuild ? "source-map" : "cheap-module-source-map";
            }
            if (isServe) {
                const installed = (item.plugins ||= []).find(item => item instanceof rspackCore.ProgressPlugin);
                if (!installed) {
                    (item.plugins ??= []).push(new rspackCore.ProgressPlugin());
                }
            }
            if (typeof item.stats === "undefined") {
                item.stats = { preset: "errors-warnings", timings: true };
            }
            else if (typeof item.stats === "boolean") {
                item.stats = item.stats ? { preset: "normal" } : { preset: "none" };
            }
            else if (typeof item.stats === "string") {
                item.stats = {
                    preset: item.stats
                };
            }
            if (this.colors.isColorSupported &&
                typeof item.stats.colors === "undefined") {
                item.stats.colors = true;
            }
            return item;
        };
        if (Array.isArray(item)) {
            return Promise.all(item.map(internalBuildConfig));
        }
        return internalBuildConfig(item);
    }
    async loadConfig(options) {
        let loadedConfig = (await (0, loadConfig_1.loadRspackConfig)(options));
        if (options.configName) {
            const notFoundConfigNames = [];
            loadedConfig = options.configName.map((configName) => {
                let found;
                if (Array.isArray(loadedConfig)) {
                    found = loadedConfig.find(options => options.name === configName);
                }
                else {
                    found =
                        loadedConfig.name === configName
                            ? loadedConfig
                            : undefined;
                }
                if (!found) {
                    notFoundConfigNames.push(configName);
                }
                // WARNING: if config is not found, the program will exit
                // so assert here is okay to avoid runtime filtering
                return found;
            });
            if (notFoundConfigNames.length > 0) {
                this.getLogger().error(notFoundConfigNames
                    .map(configName => `Configuration with the name "${configName}" was not found.`)
                    .join(" "));
                process.exit(2);
            }
        }
        if (typeof loadedConfig === "function") {
            loadedConfig = loadedConfig(options.argv?.env, options.argv);
            // if return promise we should await its result
            if (typeof loadedConfig.then === "function") {
                loadedConfig = await loadedConfig;
            }
        }
        return loadedConfig;
    }
    isMultipleCompiler(compiler) {
        return Boolean(compiler.compilers);
    }
    isWatch(compiler) {
        return Boolean(this.isMultipleCompiler(compiler)
            ? compiler.compilers.some(compiler => compiler.options.watch)
            : compiler.options.watch);
    }
}
exports.RspackCLI = RspackCLI;
function defineConfig(config) {
    return config;
}
exports.defineConfig = defineConfig;
function definePlugin(plugin) {
    return plugin;
}
exports.definePlugin = definePlugin;
